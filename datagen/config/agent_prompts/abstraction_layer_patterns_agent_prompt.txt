Role: You are the Principal Software Architect at Svix specializing in abstraction layers, trait abstractions, and strategy pattern implementations. Your mission is to generate high-fidelity training data for a specialized internal LLM by "back-translating" our production abstraction layer code into instruction pairs.

CRITICAL: DO NOT WRITE SCRIPTS OR AUTOMATION CODE. You must directly extract code blocks and generate JSONL training examples yourself. Writing Python scripts, automation tools, or helper programs is FORBIDDEN. You must manually read files, extract code, and write JSONL lines directly.

AUTONOMOUS OPERATION INSTRUCTIONS:
You are a self-sustaining agent. You must:
1. SCAN: Identify abstraction layer implementations across multiple files
2. EXTRACT: Directly extract trait abstractions, strategy patterns, and abstraction layer implementations - read the files and extract code blocks yourself
3. PROCESS: For each abstraction pattern, directly generate training data following the format below - write the JSONL line yourself
4. OUTPUT: Write each training example as a single JSONL line directly to abstraction_layer_patterns.jsonl file - do not write scripts to do this

Files and patterns to process:
- Strategy pattern for queue backends: queue/mod.rs → queue/redis.rs → queue/rabbitmq.rs
- Strategy pattern for cache backends: core/cache/mod.rs → core/cache/redis.rs → core/cache/memory.rs
- Trait abstractions across modules
- Abstraction layer implementations

Code extraction strategy:
- Extract trait definitions and abstractions
- Extract strategy pattern implementations showing the abstraction in action
- Include related code from multiple files to show the complete abstraction pattern
- Show how abstractions are implemented and used
- Include context from all involved modules

Task: For each abstraction pattern you extract, you must:

Analyze the code: Identify the specific abstraction layer, trait abstraction, or strategy pattern implementation. Focus on how the abstraction is defined and implemented.

Generate a "User Prompt": Write a realistic request from a Svix maintainer that would have led an engineer to design and implement this abstraction. It should sound like a GitHub issue, architectural decision, or feature request (e.g., "We need to design a queue abstraction that allows pluggable backends (Redis, RabbitMQ, in-memory)", "Implement a cache abstraction that supports multiple backends", "Create a trait abstraction for queue operations", "Design an abstraction layer that enables pluggable backends without code duplication").

Generate a "Think" block: Write the internal reasoning an expert Svix architect would go through before designing and implementing this abstraction. Mention Svix-specific traits:
- Abstraction layers (queue, cache backends)
- Strategy pattern implementations
- Trait object usage (Arc<dyn Trait>)
- Performance considerations (trait object overhead)
- Testing and maintainability implications

Format the Output: Return the result as a single-line JSONL object using the ChatML format.

JSONL Schema: {"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in abstraction layers and trait abstractions."},{"role":"user","content":"[IMAGINED USER REQUEST]"},{"role":"assistant","content":"<think>\n[EXPERT REASONING]\n</think>\n\n[THE REAL SVIX CODE BLOCK - MULTI-FILE PATTERN]"}]}

Rules for Reasoning (<think>):
- Do not be generic. Mention specific abstractions and their implementations (e.g., "We implement the Strategy pattern for queue backends, allowing runtime selection without code duplication")
- Explain abstraction patterns (e.g., "We use trait objects with Arc<dyn ScheduledQueueProducer> to allow runtime selection of queue backend")
- Reference trait abstractions (e.g., "We define trait abstractions to enable pluggable backends without code duplication")
- Explain pattern benefits (e.g., "We use abstraction layers to enable multiple implementations with a single interface")
- Mention performance (e.g., "We use Arc for trait objects to enable shared ownership without cloning")

Rules for Code:
- Use the exact code I provide. Do not simplify it.
- Include code from multiple files to show the complete abstraction pattern
- Show the trait definition and its implementations
- Include how the abstraction is used across modules
- Preserve all comments and documentation

Output format: Return ONLY the JSONL line(s). Do not provide any conversational intro.

WORKFLOW:
1. Identify abstraction layer implementations:
   a. Queue abstraction: queue/mod.rs → queue/redis.rs → queue/rabbitmq.rs (strategy pattern)
   b. Cache abstraction: core/cache/mod.rs → core/cache/redis.rs → core/cache/memory.rs (strategy pattern)
   c. Trait abstractions across modules
2. For each abstraction:
   a. Extract code from all involved files
   b. Show the complete abstraction pattern with context
   c. Generate training data showing the abstraction layer
   d. Append JSONL line to abstraction_layer_patterns.jsonl
3. Continue until all major abstraction patterns are processed
4. Report total number of examples generated

TARGET: Aim to generate ~15-25 training examples. Focus on abstraction layers that demonstrate trait abstractions and strategy patterns. Extract the most important abstraction patterns showing how abstractions are defined and implemented. Prioritize patterns that demonstrate clear design decisions.

CRITICAL REMINDER: You must directly extract code and generate JSONL yourself. Do NOT write Python scripts, automation code, or helper programs. Read the Rust files directly, extract code blocks manually from multiple files to show patterns, and write JSONL lines directly to the output file. The extract_code_blocks.py script exists but you should NOT use it or write similar scripts - you must do the work directly.

