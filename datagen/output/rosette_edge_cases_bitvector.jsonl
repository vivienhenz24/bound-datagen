{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I am seeing weird results when shifting 4-bit bitvectors by the width or by negative amounts. Can you show a Rosette test that captures what bvshl/bvlshr should do for shift counts like 4, 5, or -1?"},{"role":"assistant","content":"<think>\nThis edge case is about shift counts that are >= the bitvector width. In Rosette, the shift amount is itself a bitvector, so (bv 4), (bv 5), and (bv -1) for width 4 all represent counts that are effectively >= 4. The helper uses define-tests with check-valid? to state simplifications for op applied to x and literal shift counts. The solver should validate that shifting by 0 returns x, and shifting by counts >= width yields (bv 0). This relies on bv literals, check-valid?, and bitvector-size semantics for @bvshl/@bvlshr.\n</think>\n\n```racket\n#lang racket\n\n(require rackunit rackunit/text-ui racket/generator (rename-in rackunit [check-exn rackunit/check-exn])\n         rosette/solver/solution \n         rosette/lib/roseunit rosette/solver/smt/boolector\n         racket/fixnum \n         rosette/base/core/term\n         rosette/base/core/bool\n         rosette/base/core/result\n         (except-in rosette/base/core/bitvector bv)\n         (only-in rosette/base/core/bitvector [bv @bv])\n         rosette/base/core/polymorphic rosette/base/core/merge \n         (only-in rosette/base/core/equality @equal?)\n         (only-in rosette/base/form/define define-symbolic define-symbolic*)\n         (only-in rosette/base/core/real @= @< @<= @integer?)\n         \"exprs.rkt\" \"solver.rkt\")\n\n(provide check-state check-bv-exn)\n\n(define BV (bitvector 4))\n(define-symbolic x y z BV)\n(define-symbolic a b c d e f g @boolean?)\n\n\n(define minval (- (expt 2 (sub1 (bitvector-size BV)))))\n(define maxval+1 (expt 2 (sub1 (bitvector-size BV)))) \n(define maxval (sub1 maxval+1))\n(define (bv v [t BV]) (@bv v t))\n\n(define-syntax-rule (check-exn e ...)\n  (begin\n    (rackunit/check-exn e ...)\n    (clear-vc!)))\n\n(define-syntax-rule (define-tests (name arg ...) body ...)\n  (define (name arg ...)\n    (begin\n     (clear-vc!)\n     body ...\n     (clear-vc!))))\n\n(define-tests (check-shift-simplifications op)\n  (check-valid? (op x (bv 0)) x)\n  (check-valid? (op (bv 0) x) (bv 0))\n  (check-valid? (op x (bv 4)) (bv 0))\n  (check-valid? (op x (bv 5)) (bv 0))\n  (check-valid? (op x (bv -1)) (bv 0)))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Can you show a Rosette test for arithmetic right shift that makes the sign-extension behavior explicit, especially when the shift amount is 4, 5, or -1 on 4-bit vectors?"},{"role":"assistant","content":"<think>\nArithmetic shift right is tricky because the shift count can exceed the bit-width and the result depends on the sign bit. The Rosette test encodes this with @bvashr, using (bv minval) as the sign-bit mask and an ite to select 0 or -1. The solver should prove that shifting by 4, 5, or -1 yields a sign-filled vector based on whether (bv minval) is set in x. This uses @bveq, @bvand, and bv literals.\n</think>\n\n```racket\n#lang racket\n\n(require rackunit rackunit/text-ui racket/generator (rename-in rackunit [check-exn rackunit/check-exn])\n         rosette/solver/solution \n         rosette/lib/roseunit rosette/solver/smt/boolector\n         racket/fixnum \n         rosette/base/core/term\n         rosette/base/core/bool\n         rosette/base/core/result\n         (except-in rosette/base/core/bitvector bv)\n         (only-in rosette/base/core/bitvector [bv @bv])\n         rosette/base/core/polymorphic rosette/base/core/merge \n         (only-in rosette/base/core/equality @equal?)\n         (only-in rosette/base/form/define define-symbolic define-symbolic*)\n         (only-in rosette/base/core/real @= @< @<= @integer?)\n         \"exprs.rkt\" \"solver.rkt\")\n\n(provide check-state check-bv-exn)\n\n(define BV (bitvector 4))\n(define-symbolic x y z BV)\n(define-symbolic a b c d e f g @boolean?)\n\n\n(define minval (- (expt 2 (sub1 (bitvector-size BV)))))\n(define maxval+1 (expt 2 (sub1 (bitvector-size BV)))) \n(define maxval (sub1 maxval+1))\n(define (bv v [t BV]) (@bv v t))\n\n(define-syntax-rule (check-exn e ...)\n  (begin\n    (rackunit/check-exn e ...)\n    (clear-vc!)))\n\n(define-syntax-rule (define-tests (name arg ...) body ...)\n  (define (name arg ...)\n    (begin\n     (clear-vc!)\n     body ...\n     (clear-vc!))))\n\n(define-tests (check-bvashr-simplifications)\n  (check-valid? (@bvashr x (bv 0)) x)\n  (check-valid? (@bvashr (bv 0) x) (bv 0))\n  (check-valid? (@bvashr (bv -1) x) (bv -1))\n  (check-valid? (@bvashr x (bv 4)) (ite (@bveq (bv 0) (@bvand x (bv minval))) (bv 0) (bv -1)))\n  (check-valid? (@bvashr x (bv 5)) (ite (@bveq (bv 0) (@bvand x (bv minval))) (bv 0) (bv -1)))\n  (check-valid? (@bvashr x (bv -1)) (ite (@bveq (bv 0) (@bvand x (bv minval))) (bv 0) (bv -1))))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I need a Rosette test that documents signed division edge cases, especially division by zero and division by minval. Do you have a minimal example?"},{"role":"assistant","content":"<think>\nSigned division has edge cases at 0 and at the minimum signed value. The Rosette test uses @bvsdiv with bv literals and minval. The special cases include division by zero yielding -1 or 1 depending on sign, and division by minval causing a conditional result. The solver should validate these equivalences using @bvslt and @bveq, capturing overflow-like behavior when negating minval.\n</think>\n\n```racket\n#lang racket\n\n(require rackunit rackunit/text-ui racket/generator (rename-in rackunit [check-exn rackunit/check-exn])\n         rosette/solver/solution \n         rosette/lib/roseunit rosette/solver/smt/boolector\n         racket/fixnum \n         rosette/base/core/term\n         rosette/base/core/bool\n         rosette/base/core/result\n         (except-in rosette/base/core/bitvector bv)\n         (only-in rosette/base/core/bitvector [bv @bv])\n         rosette/base/core/polymorphic rosette/base/core/merge \n         (only-in rosette/base/core/equality @equal?)\n         (only-in rosette/base/form/define define-symbolic define-symbolic*)\n         (only-in rosette/base/core/real @= @< @<= @integer?)\n         \"exprs.rkt\" \"solver.rkt\")\n\n(provide check-state check-bv-exn)\n\n(define BV (bitvector 4))\n(define-symbolic x y z BV)\n(define-symbolic a b c d e f g @boolean?)\n\n\n(define minval (- (expt 2 (sub1 (bitvector-size BV)))))\n(define maxval+1 (expt 2 (sub1 (bitvector-size BV)))) \n(define maxval (sub1 maxval+1))\n(define (bv v [t BV]) (@bv v t))\n\n(define-syntax-rule (check-exn e ...)\n  (begin\n    (rackunit/check-exn e ...)\n    (clear-vc!)))\n\n(define-syntax-rule (define-tests (name arg ...) body ...)\n  (define (name arg ...)\n    (begin\n     (clear-vc!)\n     body ...\n     (clear-vc!))))\n\n(define-tests (check-bvsdiv-simplifications)\n  (check-valid? (@bvsdiv (bv 3) (bv 0)) (bv -1))\n  (check-valid? (@bvsdiv (bv -3) (bv 0)) (bv 1))\n  (check-valid? (@bvsdiv x (bv 0)) (ite (@bvslt x (bv 0)) (bv 1) (bv -1)))\n  (check-valid? (@bvsdiv (bv 3) (bv 1)) (bv 3))\n  (check-valid? (@bvsdiv x (bv 1)) x)\n  (check-valid? (@bvsdiv x (bv -1)) (@bvneg x))\n  (check-valid? (@bvsdiv (bv 0) x) (ite (@bveq x (bv 0)) (bv -1) (bv 0)))\n  (check-valid? (@bvsdiv x (bv minval)) (ite (@bveq x (bv minval)) (bv 1) (bv 0)))\n  (check-valid? (@bvsdiv x x) (ite (@bveq x (bv 0)) (bv -1) (bv 1)))\n  (check-valid? (@bvsdiv x (@bvneg x)) (ite (@bveq x (bv minval)) (bv 1) (bv -1)))\n  (check-valid? (@bvsdiv (@bvneg x) x) (ite (@bveq x (bv minval)) (bv 1) (bv -1)))\n  (check-valid? (@bvsdiv (ite b (bv -6) (bv 4)) (bv 2)) (ite b (bv -3) (bv 2)))\n  (check-valid? (@bvsdiv (bv 6) (ite b (bv 2) (bv 3))) (ite b (bv 3) (bv 2))))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Can you point me to a Rosette test that nails down unsigned division by zero and self-division for bitvectors?"},{"role":"assistant","content":"<think>\nUnsigned division by zero is a solver-facing edge case: bvudiv defines a special result rather than leaving it undefined. The Rosette test uses @bvudiv with bv literals and symbolic x, asserting that dividing by zero yields (bv -1), and that x/x is 1 except when x is 0. These check-valid? constraints are crucial for solver consistency across QF_BV.\n</think>\n\n```racket\n#lang racket\n\n(require rackunit rackunit/text-ui racket/generator (rename-in rackunit [check-exn rackunit/check-exn])\n         rosette/solver/solution \n         rosette/lib/roseunit rosette/solver/smt/boolector\n         racket/fixnum \n         rosette/base/core/term\n         rosette/base/core/bool\n         rosette/base/core/result\n         (except-in rosette/base/core/bitvector bv)\n         (only-in rosette/base/core/bitvector [bv @bv])\n         rosette/base/core/polymorphic rosette/base/core/merge \n         (only-in rosette/base/core/equality @equal?)\n         (only-in rosette/base/form/define define-symbolic define-symbolic*)\n         (only-in rosette/base/core/real @= @< @<= @integer?)\n         \"exprs.rkt\" \"solver.rkt\")\n\n(provide check-state check-bv-exn)\n\n(define BV (bitvector 4))\n(define-symbolic x y z BV)\n(define-symbolic a b c d e f g @boolean?)\n\n\n(define minval (- (expt 2 (sub1 (bitvector-size BV)))))\n(define maxval+1 (expt 2 (sub1 (bitvector-size BV)))) \n(define maxval (sub1 maxval+1))\n(define (bv v [t BV]) (@bv v t))\n\n(define-syntax-rule (check-exn e ...)\n  (begin\n    (rackunit/check-exn e ...)\n    (clear-vc!)))\n\n(define-syntax-rule (define-tests (name arg ...) body ...)\n  (define (name arg ...)\n    (begin\n     (clear-vc!)\n     body ...\n     (clear-vc!))))\n\n(define-tests (check-bvudiv-simplifications)\n  (check-valid? (@bvudiv (bv 3) (bv 0)) (bv -1))\n  (check-valid? (@bvudiv x (bv 0)) (bv -1))\n  (check-valid? (@bvudiv (bv 3) (bv 1)) (bv 3))\n  (check-valid? (@bvudiv x (bv 1)) x)\n  (check-valid? (@bvudiv x (bv -1)) (ite (@bveq x (bv -1)) (bv 1) (bv 0)))\n  (check-valid? (@bvudiv (bv 0) x) (ite (@bveq x (bv 0)) (bv -1) (bv 0)))\n  (check-valid? (@bvudiv x x) (ite (@bveq x (bv 0)) (bv -1) (bv 1)))\n  (check-valid? (@bvudiv (ite b (bv 6) (bv 8)) (bv 2)) (ite b (bv 3) (bv 4)))\n  (check-valid? (@bvudiv (bv 6) (ite b (bv 2) (bv 3))) (ite b (bv 3) (bv 2))))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I want a Rosette snippet that clarifies signed remainder behavior, especially the minval divisor case. Do we have tests for that?"},{"role":"assistant","content":"<think>\nSigned remainder is subtle because it shares the same minval edge case as signed division, and the semantics depend on the sign of operands. The test suite uses a generic helper check-signed-remainder-simplifications for @bvsrem and then adds explicit constraints for a minval divisor. The solver should show that rem with minval yields 0 only when the dividend equals minval, otherwise it preserves x.\n</think>\n\n```racket\n#lang racket\n\n(require rackunit rackunit/text-ui racket/generator (rename-in rackunit [check-exn rackunit/check-exn])\n         rosette/solver/solution \n         rosette/lib/roseunit rosette/solver/smt/boolector\n         racket/fixnum \n         rosette/base/core/term\n         rosette/base/core/bool\n         rosette/base/core/result\n         (except-in rosette/base/core/bitvector bv)\n         (only-in rosette/base/core/bitvector [bv @bv])\n         rosette/base/core/polymorphic rosette/base/core/merge \n         (only-in rosette/base/core/equality @equal?)\n         (only-in rosette/base/form/define define-symbolic define-symbolic*)\n         (only-in rosette/base/core/real @= @< @<= @integer?)\n         \"exprs.rkt\" \"solver.rkt\")\n\n(provide check-state check-bv-exn)\n\n(define BV (bitvector 4))\n(define-symbolic x y z BV)\n(define-symbolic a b c d e f g @boolean?)\n\n\n(define minval (- (expt 2 (sub1 (bitvector-size BV)))))\n(define maxval+1 (expt 2 (sub1 (bitvector-size BV)))) \n(define maxval (sub1 maxval+1))\n(define (bv v [t BV]) (@bv v t))\n\n(define-syntax-rule (check-exn e ...)\n  (begin\n    (rackunit/check-exn e ...)\n    (clear-vc!)))\n\n(define-syntax-rule (define-tests (name arg ...) body ...)\n  (define (name arg ...)\n    (begin\n     (clear-vc!)\n     body ...\n     (clear-vc!))))\n\n(define-tests (check-signed-remainder-simplifications op)\n  (check-valid? (op (bv 3) (bv 1)) (bv 0))\n  (check-valid? (op (bv 0) (bv 1)) (bv 0))\n  (check-valid? (op (bv -3) (bv 1)) (bv 0))\n  (check-valid? (op x (bv 1)) (bv 0))\n  (check-valid? (op (@bvadd x y) (bv 1)) (bv 0))\n  (check-valid? (op (bv 3) (bv -1)) (bv 0))\n  (check-valid? (op (bv 0) (bv -1)) (bv 0))\n  (check-valid? (op (bv -3) (bv -1)) (bv 0))\n  (check-valid? (op x (bv -1)) (bv 0))\n  (check-valid? (op (@bvadd x y) (bv -1)) (bv 0))\n  (check-valid? (op (bv 3) (bv 0)) (bv 3))\n  (check-valid? (op (bv 0) (bv 0)) (bv 0))\n  (check-valid? (op (bv -3) (bv 0)) (bv -3))\n  (check-valid? (op x (bv 0)) x)\n  (check-valid? (op (@bvadd x y) (bv 0)) (@bvadd x y))\n  (check-valid? (op (bv 0) (bv 3)) (bv 0))\n  (check-valid? (op (bv 0) (bv -3)) (bv 0))\n  (check-valid? (op (bv 0) x) (bv 0))\n  (check-valid? (op (bv 0) (@bvadd x y)) (bv 0))\n  (check-valid? (op x x) (bv 0))\n  (check-valid? (op x (@bvneg x)) (bv 0))\n  (check-valid? (op (@bvneg x) x) (bv 0))\n  (check-valid? (op (ite b (bv 6) (bv 4)) (bv 3)) (ite b (bv 0) (bv 1)))\n  (check-valid? (op (bv 6) (ite b (bv 4) (bv 5))) (ite b (bv 2) (bv 1))))\n\n(define-tests (check-bvsrem-simplifications)\n  (check-signed-remainder-simplifications @bvsrem)\n  (check-valid? (@bvsrem x (bv minval)) (ite (@bveq x (bv minval)) (bv 0) x))\n  (check-valid? (@bvsrem (@bvadd x y) (bv minval)) (ite (@bveq (@bvadd x y) (bv minval)) (bv 0) (@bvadd x y))))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Rotates are giving me headaches. Do we have Rosette tests that show rotate counts wrapping the width and rejecting out-of-range integer rotates?"},{"role":"assistant","content":"<think>\nRotate edge cases show up when the rotate amount is a bitvector (wraps modulo width) versus an integer (must be bounded). The bvlib tests express both: check-bvrotate asserts that (bv 8 4) is a no-op and that (bv -1 4) wraps to (bv 3 4), while check-rotate enforces integer bounds with explicit asserts and exceptions for -1 or 5. The solver validates these via merge* and assert constraints.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui (rename-in rackunit [check-exn rackunit/check-exn])\n         rosette/lib/roseunit (only-in rosette/base/core/merge merge*))\n(require (only-in rosette/base/core/bool vc-assumes vc-asserts) )\n\n(define-symbolic z (bitvector 1))\n(define-symbolic x u (bitvector 4))\n(define-symbolic y w (bitvector 8))\n(define-symbolic i integer?)\n(define-symbolic b c boolean?)\n\n(define-syntax-rule (check-exn e ...)\n  (begin\n    (rackunit/check-exn e ...)\n    (clear-vc!)))\n\n(define-syntax-rule (check≡ actual expected)\n  (let ([ra (with-vc actual)]\n        [re (with-vc expected)])\n    (check-pred unsat?\n                (verify (assert (equal? (vc-assumes (result-state ra))\n                                        (vc-assumes (result-state re))))))\n    (check-pred unsat?\n                (verify (assert (equal? (vc-asserts (result-state ra))\n                                        (vc-asserts (result-state re))))))\n    (check-pred unsat?\n                (verify (begin (assume (&& (vc-assumes (result-state ra)) (vc-asserts (result-state ra))))\n                               (assert (equal? (result-value ra) (result-value re))))))))\n\n(define (check-bvrotate op opp)\n  (check≡ (op x (bv 0 4)) x)\n  (check≡ (op y (bv 0 8)) y)\n  (check≡ (op (if b x 1) (bv 0 4)) (begin (assert b) x))\n  (check≡ (op (if b x y) (if c (bv 0 4) (bv 0 8)))\n          (begin (assert (|| (&& b c) (&& (! b) (! c))))\n                 (merge* (cons (&& b c) x)\n                         (cons (&& (! b) (! c)) y))))\n  (check≡ (op (if b x y) (if c u w))\n          (begin (assert (|| (&& b c) (&& (! b) (! c))))\n                 (merge* (cons (&& b c) (op x u))\n                         (cons (&& (! b) (! c)) (op y w)))))\n  (check≡ (op x (bv 8 4)) x)\n  (check≡ (op x (bv 5 4)) (op x (bv 1 4)))\n  (check≡ (op x (bv -1 4)) (op x (bv 3 4)))\n  (check≡ (opp (op x u) u) x)\n  (check≡ (opp (op (if b x y) (if c u w)) (if c u w))\n          (begin (assert (|| (&& b c) (&& (! b) (! c))))\n                 (merge* (cons (&& b c) x)\n                         (cons (&& (! b) (! c)) y)))))\n\n(define (check-rotate op opp bvop)\n  (check≡ (op 0 x) x)\n  (check≡ (op 0 y) y)\n  (check≡ (op 0 (if b x 1)) (begin (assert b) x))\n  (check≡ (op (if c 0 'foo) (if b x y)) (begin (assert c) (if b x y)))\n  (check≡ (op i x)\n          (begin\n            (assert (<= 0 i))\n            (assert (< i 4))\n            (bvop x (integer->bitvector i (bitvector 4)))))\n  (check≡ (op i (if b x y))\n          (begin\n            (assert (<= 0 i))\n            (assert (=> b (< i 4)))\n            (assert (=> (! b) (< i 8)))\n            (if b\n                (bvop x (integer->bitvector i (bitvector 4)))\n                (bvop y (integer->bitvector i (bitvector 8))))))\n  (check≡ (opp i (op i x ))\n          (begin\n            (assert (<= 0 i))\n            (assert (< i 4))\n            x))\n  (check≡ (opp i (op i (if b x y )))\n          (begin\n            (assert (<= 0 i))\n            (assert (=> b (< i 4)))\n            (assert (=> (! b) (< i 8)))\n            (if b x y)))\n  (check-exn #px\">\" (thunk (op 5 x)))\n  (check-exn #px\">=\" (thunk (op -1 x))))\n```\n"}]}
