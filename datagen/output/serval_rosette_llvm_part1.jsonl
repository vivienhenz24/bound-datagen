{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in LLVM modeling with Rosette."},{"role":"user","content":"While parsing raw LLVM IR modules, how do we ensure anonymous globals, arguments, and SSA instructions pick up deterministic names before we build Rosette values?"},{"role":"assistant","content":"<think>\nLLVM parser walks globals and each function's arguments/blocks/instructions, calling `unnamed?` and `set-name!` with a counter to tag otherwise nameless values; this guarantees `value-ref` can mint `%`/`@` symbols so Rosette `module`, `function`, and `instruction` records remain referentially stable for symbolic execution.\n</think>\n\n```racket\n  (define globals\n    (let ([counter 0])\n      (for/list ([gv (in-globals m)])\n        ; assign names to unnamed global variables (e.g., from ubsan)\n        (when (unnamed? gv)\n          (set-name! gv counter)\n          (set! counter (add1 counter)))\n        ; just names for global variables\n        (value-ref gv td))))\n\n  (define functions\n    (for/list ([f (in-functions m)]\n               #:when (let ([s (value->name/string f)]) (not (or (builtin? s) (ubsan? s)))))\n\n      ; assign names to local variables\n      (let ([counter 0])\n        (for ([arg (in-arguments f)] #:when (unnamed? arg))\n          (set-name! arg counter)\n          (set! counter (add1 counter)))\n        (for ([bb (in-basic-blocks f)])\n          (define bbv (LLVMBasicBlockAsValue bb))\n          (when (unnamed? bbv)\n            (set-name! bbv counter)\n            (set! counter (add1 counter)))\n          (for ([insn (in-instructions bb)] #:when (and (typeof-ref insn) (unnamed? insn)))\n            (set-name! insn counter)\n            (set! counter (add1 counter))))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in LLVM modeling with Rosette."},{"role":"user","content":"Show me how Serval normalizes LLVM call instructions so inline asm, builtins, and UBSan thunks map to the right Rosette opcodes and operands."},{"role":"assistant","content":"<think>\n`make-instruction` inspects every `call`, splitting operands into args vs target; inline asm calls retag the opcode to `asm`, builtin names lose the `@` prefix, and UBSan helpers lift their first operand via `lift`, ensuring our Rosette `instruction` structs capture high-level semantics instead of raw LLVM call sites.\n</think>\n\n```racket\n    [(call) (let-values ([(args target) (split-at-right operands 1)])\n              (set! target (car target))\n              (cond\n                ; lift asm\n                [(asm? target)\n                 (set! opcode 'asm)\n                 (set! operands (cons target args))]\n                [else\n                 (define fname-raw (if (symbol? target) (symbol->string target) #f))\n                 (define fname\n                   (if (and fname-raw (string-prefix? fname-raw \"@\")) (substring fname-raw 1) #f))\n                 (cond\n                   ; lift ubsan handling\n                   [(and fname (ubsan? fname))\n                    ; remove @\n                    (set! opcode (string->symbol fname))\n                    ; lift the first arg\n                    (set! operands (cons (lift (LLVMGetOperand insn 0) td) (cdr args)))]\n                   ; move call target up\n                   [else\n                    ; remove @ for builtin functions\n                    (when (and fname (builtin? fname))\n                      (set! target (string->symbol fname)))\n                    (set! operands (cons target args))])]))]\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in LLVM modeling with Rosette."},{"role":"user","content":"How are LLVM getelementptr instructions translated into Rosette-friendly offset records so symbolic memory layouts stay structured?"},{"role":"assistant","content":"<think>\nWhen opcode is `getelementptr`, the parser walks the pointee type, converting each index to either `struct-offset` or `array-offset` (with ABI sizes) and keeps the base pointer as operand 0; this captures LLVM's typed pointer arithmetic in Rosette structs for later solver reasoning about memory aliasing.\n</think>\n\n```racket\n    ; emit byte offsets for gep\n    [(getelementptr)\n     (let ([type (LLVMTypeOf (LLVMGetOperand insn 0))])\n       (define indices\n         (for/list ([idx (cdr operands)])\n           (case (LLVMGetTypeKind type)\n             [(struct) (let* ([elem-idx (bitvector->natural idx)]\n                              [offset (LLVMOffsetOfElement td type elem-idx)])\n                         (set! type (LLVMStructGetTypeAtIndex type elem-idx))\n                         (struct-offset offset))]\n             [(pointer array vector)\n              (set! type (LLVMGetElementType type))\n              (array-offset idx (LLVMABISizeOfType td type))]\n             [else (raise 'llvm \"unknown GEP type: ~a\" (LLVMPrintTypeToString type))])))\n       (set! operands (cons (car operands) indices)))]\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in LLVM modeling with Rosette."},{"role":"user","content":"When lifting LLVM constants into Rosette, how do we handle ints, nulls, undef, constant expressions, and inline asm blobs?"},{"role":"assistant","content":"<think>\n`value-ref` switches on `LLVMGetValueKind` to emit Rosette-level constructors: `bv` for integer constants with widths from `typeof-ref`, `nullptr`/`undef` for special sentinels, nested `instruction` structs for constant-exprs, and parsed `asm` records for inline assembly so subsequent symbolic evaluation sees the right abstract values.\n</think>\n\n```racket\n(define (value-ref v td)\n  ; convert basic block\n  (when (LLVMBasicBlockRef? v)\n    (set! v (LLVMBasicBlockAsValue v)))\n\n  (define s (value->name/string v))\n  (define named? (non-empty-string? s))\n  (case (LLVMGetValueKind v)\n    ; inline asm\n    ; parse the asm string as the c api doesn't expose access to inline asm\n    [(inline-asm) (match (value->string v)\n                    [(pregexp #px\"asm [a-z ]*\\\"([^\\\"]*)\\\", \\\"([^\\\"]*)\\\"$\"\n                              (list _ template constraint))\n                     (asm template constraint)])]\n\n    ; constant int\n    [(constant-int) (bv (LLVMConstIntGetSExtValue (value-> v _LLVMConstantIntRef)) (typeof-ref v))]\n\n    ; null\n    [(constant-pointer-null) (nullptr)]\n\n    ; undef\n    [(undef-value) (undef (typeof-ref v))]\n\n    ; constant expressions\n    [(constant-expr) (let* ([v (value-> v _LLVMConstantExprRef)]\n                            [opcode (LLVMGetConstOpcode v)]\n                            [operands (for/list ([op (in-operands v)])\n                                        (value-ref op td))])\n                       (make-instruction td v #f #f opcode operands))]\n\n    ; global\n    [(function global-variable)\n     (when (not named?)\n       (raise-user-error 'llvm \"no name for global variable: ~a\" (value->string v)))\n     (string->symbol (string-append \"@\" s))]\n\n    ; local\n    [(argument basic-block instruction)\n     (when (not named?)\n       (raise-user-error 'llvm \"no name for local variable: ~a\" (value->string v)))\n     (string->symbol (string-append \"%\" s))]\n\n    ; debugging\n    [(metadata metadata-as-value) (nullptr)]\n\n    [else (raise-user-error 'llvm \"unknown value: ~a\" (value->string v))]))\n```"}]}
{"messages": [{"role": "system", "content": "You are the Rosette Maintainer AI, an expert in LLVM modeling with Rosette."}, {"role": "user", "content": "Once we have parsed functions, how does the LLVM printer emit Rosette code that includes opcodes, operands, attributes, and structured offsets?"}, {"role": "assistant", "content": "<think>\n`instruction->string` renders each opcode and maps operands through `operand->string`, which formats phi/switch pairs, array/struct offsets, nullptr/undef, Rosette memory cells, inline asm, and even nested constant-expression instructions; attributes become `#:key value` clauses so the generated Racket faithfully mirrors LLVM semantics.\n</think>\n\n```racket\n(define (instruction->string insn)\n  (define body\n    (string-append \"(\"\n                   (opcode->string (instruction-opcode insn))\n                   (apply string-append\n                          (map (lambda (x) (string-append \" \" (operand->string x insn)))\n                               (instruction-operands insn)))\n                   (apply string-append\n                          (map (lambda (x) (format \" #:~a ~a\" (car x) (cdr x)))\n                               (instruction-attributes insn)))\n                   \")\"))\n  (if (value-type insn) (format \"(set! ~a ~a)\" (value-name insn) body) body))\n\n(define (operand->string v insn)\n  (define opcode (instruction-opcode insn))\n  (cond\n    [(and (or (equal? opcode 'phi) (equal? opcode 'switch)) (pair? v))\n     (format \"[~a ~a]\" (car v) (cdr v))]\n    [(list? v) (string-join (for/list ([op v])\n                              (string-append \" \" (operand->string op insn)))\n                            \"\"\n                            #:before-first \"(list\"\n                            #:after-last \")\")]\n    [(array-offset? v) (format \"(array-offset ~a ~a)\" (array-offset-index v) (array-offset-size v))]\n    [(struct-offset? v) (format \"(struct-offset ~a)\" (struct-offset-value v))]\n    [(nullptr? v) \"nullptr\"]\n    [(undef? v) (format \"(undef ~a)\" (type->string (undef-type v)))]\n    [(core:marray? v) (format \"(core:marray ~a ~a)\"\n                              (core:marray-length v)\n                              (operand->string (core:marray-elements v) insn))]\n    [(core:mstruct? v)\n     (format \"(core:mstruct ~a (list~a))\"\n             (core:mstruct-size v)\n             (string-join (for/list ([f (core:mstruct-fields v)])\n                            (format \" (core:mfield ~a ~a ~a)\"\n                                    (core:mfield-name f)\n                                    (core:mfield-offset f)\n                                    (operand->string (core:mfield-element f) insn)))\n                          \"\"))]\n    [(core:mcell? v) (format \"(core:mcell ~a)\" (core:mcell-size v))]\n    [(asm? v) (let ([template (asm-template v)])\n                (cond\n                  [(equal? template \"\") \"'nop\"]\n                  [(not (string-contains? template \" \")) (string-append \"'\" template)]\n                  [else (~s template)]))]\n    ; constant expr\n    [(instruction? v) (instruction->string v)]\n    [else (~s v)]))\n```\n"}]}
