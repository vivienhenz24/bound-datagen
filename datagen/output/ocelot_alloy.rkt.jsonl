{"messages":[{"role":"system","content":"You are the Ocelot Rosette Engineer, expert in Alloy-style modeling and solving."},{"role":"user","content":"I need a macro that lets me declare a top-level Alloy signature plus several sub-relations, each with the right arity derived from its parent type list."},{"role":"assistant","content":"<think>\nSignature/type: `define-sig` registers each relation with its intended tuple arity and stores the type lineage so sub-signatures are constrained to include their parent in the domain.\nBounds/domain: Actual atom bounds are deferred to `scope`, but the macro records enough metadata for later domain restriction when scopes instantiate products.\nSBP/Solver: No solver call here; symmetry breaking arises later in run/check, so this macro just prepares the data needed for those SBP-aware solves.\n</think>\n\n```racket\n(define sigs (make-parameter '()))\n(struct sig (relation type) #:transparent)\n(define-syntax (define-sig stx)\n  (syntax-case stx ()\n    [(_ name [subname : subtype ...] ...)\n     (syntax/loc stx\n       (begin\n         (define name (let ([r (declare-relation 1 (symbol->string 'name))])\n                        (sigs (cons (sig r (list r)) (sigs)))\n                        r))\n         (define subname\n           (let* ([type (cons name (list subtype ...))]\n                  [r (declare-relation (length type) (symbol->string 'subname))])\n             (sigs (cons (sig r type) (sigs)))\n             r)) ...))]))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ocelot Rosette Engineer, expert in Alloy-style modeling and solving."},{"role":"user","content":"Build me the scope helper that instantiates n atoms, enforces domain containment, and preserves multiplicity constraints before I run any Alloy commands."},{"role":"assistant","content":"<think>\nSignature/type: `scope` walks every registered signature, ensuring unary leaves define their own atoms and higher-arity relations fold across their declared type list.\nBounds/domain: It creates `make-product-bound` entries, gathers `in` constraints for domain containment, and emits `all` multiplicity formulas so later interpretation respects the declared ranges.\nSBP/Solver: The helper just prepares bounds/domain clauses; solver-facing SBP is produced in `alloy-run/check` once these bounds are instantiated.\n</think>\n\n```racket\n(struct alloy-scope (bounds domain) #:transparent)\n(define (scope n)\n  ; Find leaf signatures (those whose type includes themselves)\n  (define leaves\n    (for/list ([s (sigs)] #:when (member (sig-relation s) (sig-type s)))\n      (let ([r (sig-relation s)])\n        (unless (= (relation-arity r) 1)\n          (error 'scope \"self-referencing relation of arity > 1: ~v\" r))\n        r)))\n  ; Instantiate leaf signatures\n  (define relation->atoms\n    (for/hash ([r leaves])\n      (values r (for/list ([i n])\n                  (string->symbol (format \"~a$~a\" (relation-name r) i))))))\n  (define atoms (append* (hash-values relation->atoms)))\n  ; Create bounds for all signatures\n  (define bnds\n    (for/list ([s (sigs)])\n      (apply make-product-bound \n             (sig-relation s)\n             (for/list ([r (sig-type s)]) (hash-ref relation->atoms r)))))\n  ; Enforce domain restrictions: the domain of each relation must be\n  ; contained in its given type.\n  (define (fold-op t [op ->])\n    (for/fold ([ret (car t)]) ([r (cdr t)]) (op ret r)))\n  (define domain\n    (for/list ([s (sigs)] #:unless (hash-has-key? relation->atoms (sig-relation s)))\n      (define arity (length (sig-type s)))\n      (define left (if (= arity 1)\n                       (sig-relation s)\n                       (fold-op (cons (sig-relation s) (make-list (sub1 arity) univ)) join)))\n      (in left (car (sig-type s)))))\n  ; Enforce the multiplicity of each signature:\n  ; sig A { f: B } means that all a: A | one a.f\n  (define mults\n    (for/list ([s (sigs)] #:when (> (length (sig-type s)) 1))\n      (all ([x (car (sig-type s))])\n        (and (one (join x (sig-relation s)))\n             (in (join x (sig-relation s)) (fold-op (cdr (sig-type s)) ->))))))\n  (alloy-scope (bounds (universe atoms) bnds) (append domain mults)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ocelot Rosette Engineer, expert in Alloy-style modeling and solving."},{"role":"user","content":"Expose an API to register Alloy facts parsed from our AST so they get asserted before every run or check."},{"role":"assistant","content":"<think>\nSignature/type: `alloy-fact` accepts only nodes that satisfy `node/formula?`, ensuring every stored constraint is a well-typed relational formula.\nBounds/domain: The function doesn't touch bounds directly but the accumulated formulas are later interpreted under the scope's bounds and domain clauses so each fact respects those ranges.\nSBP/Solver: Facts just enqueue extra conjuncts so that, when SBP-aware solves happen in `alloy-run/check`, these facts participate in the sat/unsat queries.\n</think>\n\n```racket\n(define alloy-facts (make-parameter '()))\n(define (alloy-fact f)\n  (unless (node/formula? f)\n    (raise-argument-error 'alloy-assert \"formula?\" f))\n  (alloy-facts (cons f (alloy-facts))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ocelot Rosette Engineer, expert in Alloy-style modeling and solving."},{"role":"user","content":"Implement the Alloy-style `run` command that interprets the target formula under a scope, adds any stored facts, and returns whether a satisfying instance exists."},{"role":"assistant","content":"<think>\nSignature/type: The `f` argument is any Alloy formula while `scope` carries the previously declared signature metadata, ensuring interpretation happens with consistent relation types.\nBounds/domain: `alloy-run` instantiates the scope's bounds, interprets persisted facts plus scope-domain guards, and conjoins them with the requested post condition.\nSBP/Solver: It generates symmetry-breaking predicates via `generate-sbp` and calls `solve`/`sat?`, so the result reports whether a model exists under SBP-constrained search.\n</think>\n\n```racket\n(define (alloy-run f scope)\n  (define bnds (alloy-scope-bounds scope))\n  (define interp (instantiate-bounds bnds))\n  (define pre (for/list ([a (alloy-facts)]) (interpret* a interp)))\n  (define dom (for/list ([d (alloy-scope-domain scope)]) (interpret* d interp)))\n  (define post (interpret* f interp))\n  (define sbp (generate-sbp interp (alloy-scope-bounds scope)))\n  (sat? (solve (assert (and sbp (apply && pre) (apply && dom) post)))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ocelot Rosette Engineer, expert in Alloy-style modeling and solving."},{"role":"user","content":"Add the Alloy `check` operator that ensures an assertion cannot be violated within the given scope."},{"role":"assistant","content":"<think>\nSignature/type: Like `run`, this function interprets a typed formula `f` against the same scoped relations so the negated property matches the signature layout.\nBounds/domain: It reuses instantiated bounds plus the accumulated domain and fact constraints so the negated property is evaluated over the identical atom universe.\nSBP/Solver: `generate-sbp` enforces symmetry breaking and the solver queries `unsat?` on the negated post, signaling success only when no counterexample exists.\n</think>\n\n```racket\n(define (alloy-check f scope)\n  (define bnds (alloy-scope-bounds scope))\n  (define interp (instantiate-bounds bnds))\n  (define pre (for/list ([a (alloy-facts)]) (interpret* a interp)))\n  (define dom (for/list ([d (alloy-scope-domain scope)]) (interpret* d interp)))\n  (define post (interpret* f interp))\n  (define sbp (generate-sbp interp (alloy-scope-bounds scope)))\n  (unsat? (solve (assert (and sbp (apply && dom) (apply && pre) (not post))))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ocelot Rosette Engineer, expert in Alloy-style modeling and solving."},{"role":"user","content":"Provide a reset hook that wipes every stored fact and signature so subsequent scopes and runs start from a clean Alloy state."},{"role":"assistant","content":"<think>\nSignature/type: `clear-alloy!` calls `clear-alloy-facts!` and resets the `sigs` parameter, so no stale signature/type information leaks into the next modeling session.\nBounds/domain: With the signature table emptied, the next `scope` call will rebuild bounds and domain guards from scratch rather than reusing atoms that no longer exist.\nSBP/Solver: Clearing state ensures future SBP generation and solver queries are based only on the newly declared relations and facts, avoiding ghosts from prior sat/unsat checks.\n</think>\n\n```racket\n(define (clear-alloy-facts!)\n  (alloy-facts '()))\n\n(define (clear-alloy!)\n  (clear-alloy-facts!)\n  (sigs '()))\n```"}]}
