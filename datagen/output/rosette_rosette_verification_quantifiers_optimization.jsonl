{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"In Rosette, run a battery of solves over nested forall/exists linear integer formulas so I can tell which obligations are satisfiable and what witnesses the solver finds."},{"role":"assistant","content":"<think>\nThese checks bind integer symbolics `a b c d` and feed each quantified formula to `solve`, with `check-sol` verifying that the solver either finds a witness (e.g., `c` ↦ 0 when the existential block demands it) or proves the obligation unsatisfiable. Every `forall`/`exists` nest captures a different arithmetic invariant, so comparing the returned model against the expected `sat`/`unsat` outcome exercises Rosette's quantified solving pipeline.\n</think>\n\n```racket\n(define (check-sol actual expected)\n  (check-equal? (sat? actual) (sat? expected))\n  (when (sat? expected)\n    (check-equal? (model actual) (model expected))))\n\n(define (check-solve)\n  (define-symbolic a b c d integer?)\n  (check-sol\n   (solve (assert (forall (list a c) (exists (list b) (not (= (+ a c) b))))))\n   (sat))\n  (check-sol\n   (solve (assert (exists (list c) (forall (list b) (not (= (+ b c) b))))))\n   (sat))\n  (check-sol\n   (solve (assert (exists (list a) (forall (list b) (and (= a 0) (= (+ b c) (+ a b)))))))\n   (sat (hash c 0)))\n  (check-sol\n   (solve (assert (exists (list a) (forall (list b) (< a (- b a))))))\n   (unsat))\n  (check-sol\n   (solve\n    (begin\n      (assert (forall (list a) (exists (list b) (and (= a b) (= (+ a c) b)))))\n      (assert (forall (list a) (exists (list b c) (and (not (= a b)) (= (+ a c) b)))))))\n   (sat (hash c 0)))\n  (check-sol\n   (solve\n    (begin\n      (assert (forall (list a) (exists (list b) (and (= a b) (= (+ a c) b)))))\n      (assert (forall (list a c) (exists (list b c) (and (not (= a b)) (= (+ a c) b)))))))\n   (sat (hash c 0)))\n  (check-sol\n   (solve\n    (begin\n      (assert (forall (list a) (exists (list b) (and (= a b) (= (+ a c) b)))))\n      (assert (forall (list a c) (exists (list b) (= (+ a c) b))))))\n   (sat (hash c 0)))\n  (check-sol\n   (solve\n    (begin \n      (assert (forall (list a) (exists (list b) (and (= a b) (= (+ a c) b)))))\n      (assert (forall (list a) (exists (list b) (and (not (= a b)) (= (+ a c) b)))))))\n   (unsat)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Show how to solve quantified Rosette formulas and immediately re-evaluate them under the returned model so I can see the normalization effect on both integer and bitvector quantifiers."},{"role":"assistant","content":"<think>\n`check-eval` reuses the quantified clauses from `check-solve`, but the objective now is to run `evaluate` on each `forall`/`exists` formula with the model returned by `solve`. That exposes how Rosette rewrites quantified terms—e.g., turning `(exists (list a) ...)` into a concrete equality once `a` is forced to 0, or specializing bitvector quantifiers by plugging in the solver's assignments—while ensuring the solver remains consistent with the original property.\n</think>\n\n```racket\n(define (check-eval)\n  (define-symbolic a b c d integer?)\n  (define-symbolic x y (bitvector 4))\n  (let ([f (forall (list a c) (exists (list b) (not (= (+ a c) b))))])\n    (check-equal? (evaluate f (solve (assert f))) f))\n  (let ([f  (exists (list c) (forall (list b) (not (= (+ b c) b))))])\n    (check-equal? (evaluate f (solve (assert f))) f))\n  (let ([f  (exists (list a) (forall (list b) (and (= a 0) (= (+ b c) (+ a b)))))])\n    (check-equal?\n     (evaluate f (solve (assert f)))\n     (exists (list a) (forall (list b) (and (= a 0) (= b (+ a b)))))))\n  (let* ([f (forall (list a) (exists (list b) (and (= a b) (= (+ a c) b))))]\n         [g (forall (list a) (exists (list b c) (and (not (= a b)) (= (+ a c) b)))]\n         [s (solve (begin (assert f) (assert g)))])    \n    (check-equal?\n     (evaluate f s)\n     (forall (list a) (exists (list b) (and (= a b) (= a b)))))\n    (check-equal?\n     (evaluate g s)\n     g))\n  (let ([f (forall (list x) (bveq (bvadd x y) x))])\n    (check-equal?\n     (evaluate f (solve (assert f)))\n     (forall (list x) (bveq (bvadd x (bv 0 4)) x)))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Demonstrate quantified Rosette checks over uninterpreted functions, and show how to plug the synthesized model back into a follow-up verify call to confirm it matches the spec."},{"role":"assistant","content":"<think>\nEach block quantifies over booleans, integers, or reals plus an uninterpreted function such as `(~> boolean? boolean? boolean?)`. The solver's job is to find a function model satisfying the `forall` constraint (if one exists), and the follow-up `verify` call asserts that re-evaluating the function with the returned model preserves the expected behavior, which should be unsatisfiable if the synthesized interpreter differs from the spec. This pattern stresses quantified reasoning with solver objectives centered on consistent function interpretations.\n</think>\n\n```racket\n(define (check-uninterpreted)\n  (let ()\n    (define-symbolic x y boolean?)\n    (define-symbolic f (~> boolean? boolean? boolean?))\n    (define sol (solve (assert (forall (list x y) (equal? (f x y) (or x y))))))\n    (check-pred (disjoin sat? unknown?) sol)\n    (when (sat? sol)\n      (check-unsat (verify (assert (equal? (evaluate (f x y) sol) (or x y)))))))\n\n  (let ()\n    (define-symbolic x integer?)\n    (define-symbolic f (~> integer? integer?))\n    (define sol (solve (assert (forall (list x) (= x (f x))))))\n    (check-pred (disjoin sat? unknown?) sol)\n    (when (sat? sol)\n      (check-unsat (verify (assert (equal? (evaluate (f x) sol) (identity x)))))))\n\n  (let ()\n    (define-symbolic offset integer?)\n    (define-symbolic a (~> integer? integer?))\n    (define-symbolic disk (~> integer? integer? integer?))\n    (define sol (solve (assert (forall (list offset) (= (a offset) (disk 5 offset))))))\n    (check-pred (disjoin sat? unknown?) sol)\n    (when (sat? sol)\n      (check-unsat (verify (assert (equal? (evaluate (a offset) sol) (evaluate (disk 5 offset) sol)))))))\n\n  (let ()\n    (define-symbolic offset real?)\n    (define-symbolic a (~> real? real?))\n    (define-symbolic disk (~> real? real? real?))\n    (define sol (solve (assert (forall (list offset) (= (a offset) (disk 5.35 offset))))))\n    (check-pred (disjoin sat? unknown?) sol)\n    (when (sat? sol)\n      (check-unsat (verify (assert (equal? (evaluate (a offset) sol) (evaluate (disk 5.35 offset) sol))))))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Set up a quantified verification harness that proves vectorized OpenCL kernels (scalar, vector, and optimized variants) refine the sequential matrix multiply for every dimension/array drawn from a range."},{"role":"assistant","content":"<think>\nEach `verify_*` procedure issues a `verify` query with a `#:forall` block that quantifies over loop bounds and symbolic arrays, driving Rosette to treat every size-conforming input as an obligation. The `#:ensure` clause compares the candidate kernel (scalar, vector, optimized) against the sequential spec via `check`, so the solver objective is to prove there is no counterexample in the quantified domain—exactly what we need to guarantee the optimized kernels preserve semantics.\n</think>\n\n```racket\n(procedure void (verify_scalar [int from] [int to])\n  (verify #:forall [(: int n in (range from to))\n                    (: int p in (range from to))\n                    (: int m in (range from to))\n                    (: int[(* n p)] A) \n                    (: int[(* p m)] B)] \n          #:ensure (check (mmulScalar A B n p m) \n                          (mmulSequential A B n p m)\n                          (* n m))))\n\n(procedure void (verify_vector [int from] [int to])\n  (verify #:forall [(: int n in (range from to 4))\n                    (: int p in (range from to 4))\n                    (: int m in (range from to 4))       \n                    (: int[(* n p)] A) \n                    (: int[(* p m)] B)] \n          #:ensure (check (mmulVector A B n p m) \n                          (mmulSequential A B n p m)\n                          (* n m))))\n\n(procedure void (verify_vector_opt [int from] [int to])\n  (verify #:forall [(: int n in (range from to 4))\n                    (: int p in (range from to 4))\n                    (: int m in (range from to 4))       \n                    (: int[(* n p)] A) \n                    (: int[(* p m)] B)] \n          #:ensure (check (mmulVectorOpt A B n p m) \n                          (mmulSequential A B n p m)\n                          (* n m))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Illustrate the ∃∀ synthesis loop that alternates between guesser and checker solvers, scaling bitwidths until it finds a loop-free program meeting the spec for all inputs."},{"role":"assistant","content":"<think>\n`∃∀-solve` manages two Z3 instances: the guesser solves the existential side to propose an implementation, while the checker enforces the universal obligations via `φ_verify`. The helper `∃∀-solve*` interleaves candidate generation (`solver-assert` of `φ_synth`) with counterexample checks, and the outer wrapper increases the bitwidth until the model also satisfies the full-size objective. This captures the quantified optimization goal of satisfying ∃∀ constraints across widening reasoning precision.\n</think>\n\n```racket\n#lang racket\n\n(require \n  (only-in \"bvops.rkt\" BV bv* bv)\n  (only-in \"program.rkt\" trace* trace-args trace-out well-formed-program well-formed-trace)\n  rosette/query/eval \"log.rkt\"\n  (only-in rosette/base/core/term term? constant? get-type with-terms term<?)\n  (only-in rosette/base/core/bool ! || && => with-vc vc-assumes vc-asserts)\n  (only-in rosette/base/core/result result-state)\n  (only-in rosette/base/core/real @integer?)\n  (only-in rosette/base/core/bitvector bitvector bitvector-size)\n  (only-in rosette/solver/solution model sat sat? unsat? unsat)\n  (only-in rosette/solver/smt/z3 z3)\n  (only-in rosette/solver/solver solver-assert solver-check solver-clear))\n\n(provide ∃∀-solve)\n\n(define (∃∀-solve impl spec minbw)\n  (parameterize ([current-custodian (make-custodian)]\n                 [current-subprocess-custodian-mode 'kill])\n    (with-handlers ([exn? (lambda (e) (custodian-shutdown-all (current-custodian)) (raise e))])\n      (define guesser (z3))\n      (define checker (z3))\n      (define maxbw (bitvector-size (BV)))\n      (define (correct? sol)\n        (and (sat? sol)\n             (with-terms \n               (parameterize ([BV (bitvector maxbw)])\n                 (solver-clear checker)\n                 (solver-assert checker (φ_verify (evaluate (trace* impl) sol) spec))\n                 (unsat? (solver-check checker))))))\n      (let loop ([bw (min (max 1 minbw) maxbw)])\n        (define candidate\n          (with-terms\n            (parameterize ([BV (bitvector bw)])\n              (∃∀-solve* impl spec guesser checker))))\n        (cond [(or (= bw maxbw) (correct? candidate))\n               (custodian-shutdown-all (current-custodian))\n               candidate]\n              [else (loop (add1 bw))])))))\n\n(define (∃∀-solve* impl spec guesser checker)\n  (define trial 0)\n  (define t0 (trace* impl))\n  (define inputs (trace-args t0))\n  (define (init)\n    (solver-clear guesser)\n    (define impl_wfp (normal? (φ_wfp impl)))  \n    (solver-assert guesser impl_wfp)\n    (solver-assert guesser (φ_synth t0 spec))\n    (log-solver-info [trial] \"searching for an initial candidate at ~a\" (BV))\n    (begin0\n      (solution->candidate (solver-check guesser))\n      (solver-clear guesser)\n      (solver-assert guesser impl_wfp)))\n  (define (guess sol)\n    (set! trial (add1 trial))\n    (define sample (map sol inputs))\n    (log-solver-info [trial] \"searching for a candidate: ~s\" sample)\n    (solver-assert guesser (φ_synth (trace* impl sample) spec))\n    (solution->candidate (solver-check guesser)))\n  (define (check sol)\n    (solver-clear checker)\n    (solver-assert checker (φ_verify (evaluate t0 sol) spec))\n    (solution->sample (solver-check checker) inputs))\n  (let loop ([candidate (init)])\n    (cond \n      [(unsat? candidate) candidate]\n      [else\n        (let ([cex (check candidate)])\n          (cond \n            [(unsat? cex) candidate]\n            [else (loop (guess cex))]))])))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Give me a Rosette example that pushes multiple maximize objectives onto the current solver so I can confirm it honors the optimization order before returning a model."},{"role":"assistant","content":"<think>\nThis test drives the low-level solver API: it clears the solver, asserts ordering constraints over `x y z`, and then calls `solver-maximize` twice—first on `x`, then on `y`. The `check-model` helper demands that the returned solution maximizes `x` before `y`, yielding the expected `(x=3, y=2, z=4)` model, which demonstrates how Rosette tracks objective priorities.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui racket/generator\n         rosette/lib/roseunit)\n\n(current-bitwidth #f)\n(define-symbolic x y z integer?)\n\n(define (check-model sol m)\n  (check-pred sat? sol)\n  (check-equal? (model sol) m))\n\n(define optimization-order-tests\n  (test-suite+ \"Tests for the optimization order\"\n   #:features '(optimize)\n\n  (define solver (current-solver))\n  (solver-clear solver)\n  (solver-assert solver (list (< x z) (< y z) (< z 5) (not (= x y))))\n  (solver-maximize solver (list x))\n  (solver-maximize solver (list y))\n  (check-model (solver-check solver) (hash x 3 y 2 z 4))))\n```"}]}
