{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"I need the Rosette semantics for the ARM integer data processing immediate instructions, including the decode helper, bitwise and arithmetic interpreters, and the opcode table for AND through RSC."},{"role":"assistant","content":"<think>\nInstruction group: integer-data-processing immediate decoding via define-insn fields (S,Rn,Rd,imm12) using a32-expand-imm_c to materialize imm32 and carry-in. Symbolic registers and flags come from cpu-gpr-ref/set! plus cpu-pstate.{n,z,c,v}, with r15? deciding between alu-exception-return and regular writes. Constraints feed add-with-carry so the solver must relate symbolic imm12, carry, and NZCV bits, and bitwise paths propagate expanded immediates.\n</think>\n\n```racket\n(define (decode cpu S Rn Rd imm12)\n  (define d Rd)\n  (define n Rn)\n  (define setflags (bveq S (bv #b1 1)))\n  (define-values (imm32 carry) (a32-expand-imm_c imm12 (cpu-pstate.c cpu)))\n  (values d n setflags imm32 carry))\n\n(define (interpret-bitwise proc cpu S Rn Rd imm12)\n  (define-values (d n setflags imm32 carry) (decode cpu S Rn Rd imm12))\n  (define result (proc (cpu-gpr-ref cpu n) imm32))\n  (cond\n    [(r15? d)\n     (if setflags\n         (alu-exception-return cpu result)\n         (alu-write-pc cpu result))]\n    [else\n     (cpu-gpr-set! cpu d result)\n     (when setflags\n       (cpu-pstate.n-set! cpu (bit 31 result))\n       (cpu-pstate.z-set! cpu (is-zero-bit result))\n       (cpu-pstate.c-set! cpu carry)\n       ; PSTATE.V unchanged\n     )]))\n\n(define interpret-and/ands\n  (curry interpret-bitwise bvand))\n\n(define interpret-eor/eors\n  (curry interpret-bitwise bvxor))\n\n(define (interpret-arithmetic proc-Rn proc-imm32 proc-carry cpu S Rn Rd imm12)\n  (define-values (d n setflags imm32 carry) (decode cpu S Rn Rd imm12))\n  (define-values (result nzcv) (add-with-carry (proc-Rn (cpu-gpr-ref cpu n)) (proc-imm32 imm32) (proc-carry (cpu-pstate.c cpu))))\n  (cond\n    [(r15? d)\n     (if setflags\n         (alu-exception-return cpu result)\n         (alu-write-pc cpu result))]\n    [else\n     (cpu-gpr-set! cpu d result)\n     (when setflags\n       (cpu-pstate.nzcv-set! cpu nzcv))]))\n\n(define interpret-sub/subs\n  (curry interpret-arithmetic identity bvnot (const (bv #b1 1))))\n\n(define interpret-rsb/rsbs\n  (curry interpret-arithmetic bvnot identity (const (bv #b1 1))))\n\n(define interpret-add/adds\n  (curry interpret-arithmetic identity identity (const (bv #b0 1))))\n\n(define interpret-adc/adcs\n  (curry interpret-arithmetic identity identity identity))\n\n(define interpret-sbc/sbcs\n  (curry interpret-arithmetic identity bvnot identity))\n\n(define interpret-rsc/rscs\n  (curry interpret-arithmetic bvnot identity identity))\n\n\n(define-insn (S Rn Rd imm12)\n  #:encode (lambda (opc) (list (bv #b0010 4) (bv opc 3) S Rn Rd imm12))\n  [(#b000) and/ands-immediate interpret-and/ands]\n  [(#b001) eor/eors-immediate interpret-eor/eors]\n  [(#b010) sub/subs-immediate interpret-sub/subs]\n  [(#b011) rsb/rsbs-immediate interpret-rsb/rsbs]\n  [(#b100) add/adds-immediate interpret-add/adds]\n  [(#b101) adc/adcs-immediate interpret-adc/adcs]\n  [(#b110) sbc/sbcs-immediate interpret-sbc/sbcs]\n  [(#b111) rsc/rscs-immediate interpret-rsc/rscs])\n\n(define and-immediate\n  (curry and/ands-immediate (bv #b0 1)))\n\n(define ands-immediate\n  (curry and/ands-immediate (bv #b1 1)))\n\n(define eor-immediate\n  (curry eor/eors-immediate (bv #b0 1)))\n\n(define eors-immediate\n  (curry eor/eors-immediate (bv #b1 1)))\n\n(define sub-immediate\n  (curry sub/subs-immediate (bv #b0 1)))\n\n(define subs-immediate\n  (curry sub/subs-immediate (bv #b1 1)))\n\n(define rsb-immediate\n  (curry rsb/rsbs-immediate (bv #b0 1)))\n\n(define rsbs-immediate\n  (curry rsb/rsbs-immediate (bv #b1 1)))\n\n(define add-immediate\n  (curry add/adds-immediate (bv #b0 1)))\n\n(define adds-immediate\n  (curry add/adds-immediate (bv #b1 1)))\n\n(define adc-immediate\n  (curry adc/adcs-immediate (bv #b0 1)))\n\n(define adcs-immediate\n  (curry adc/adcs-immediate (bv #b1 1)))\n\n(define sbc-immediate\n  (curry sbc/sbcs-immediate (bv #b0 1)))\n\n(define sbcs-immediate\n  (curry sbc/sbcs-immediate (bv #b1 1)))\n\n(define rsc-immediate\n  (curry rsc/rscs-immediate (bv #b0 1)))\n\n(define rscs-immediate\n  (curry rsc/rscs-immediate (bv #b1 1)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"I am reviewing the ARM integer data processing register form; please show the Rosette decode, the bitwise/arithmetic interpreters, and the define-insn cases that cover AND through RSC with shifted register operands."},{"role":"assistant","content":"<think>\nInstruction group: integer-data-processing register form decoded via define-insn fields (S,Rn,Rd,imm5,stype,Rm) and decode-imm-shift to derive shift_t/shift_n. Symbolic regs include cpu-gpr-ref/set! for Rn/Rd, while symbolic shifter results and carry outs arise from shift_c/shift. add-with-carry propagates constraints tying shifted operands, carry-in, and NZCV, and r15? guards keep PC updates predictable.\n</think>\n\n```racket\n(define (decode S Rn Rd imm5 stype Rm)\n  (define d Rd)\n  (define n Rn)\n  (define m Rm)\n  (define setflags (bveq S (bv #b1 1)))\n  (define-values (shift_t shift_n) (decode-imm-shift stype imm5))\n  (values d n m setflags shift_t shift_n))\n\n(define (interpret-bitwise proc cpu S Rn Rd imm5 stype Rm)\n  (define-values (d n m setflags shift_t shift_n) (decode S Rn Rd imm5 stype Rm))\n  (define-values (shifted carry) (shift_c (cpu-gpr-ref cpu m) shift_t shift_n (cpu-pstate.c cpu)))\n  (define result (proc (cpu-gpr-ref cpu n) shifted))\n  (cond\n    [(r15? d)\n     (if setflags\n         (alu-exception-return cpu result)\n         (alu-write-pc cpu result))]\n    [else\n     (cpu-gpr-set! cpu d result)\n     (when setflags\n       (cpu-pstate.n-set! cpu (bit 31 result))\n       (cpu-pstate.z-set! cpu (is-zero-bit result))\n       (cpu-pstate.c-set! cpu carry)\n       ; PSTATE.V\n     )]))\n\n(define interpret-and/ands\n  (curry interpret-bitwise bvand))\n\n(define interpret-eor/eors\n  (curry interpret-bitwise bvxor))\n\n(define (interpret-arithmetic proc-Rn proc-shifted proc-carry cpu S Rn Rd imm5 stype Rm)\n  (define-values (d n m setflags shift_t shift_n) (decode S Rn Rd imm5 stype Rm))\n  (define shifted (shift (cpu-gpr-ref cpu m) shift_t shift_n (cpu-pstate.c cpu)))\n  (define-values (result nzcv) (add-with-carry (proc-Rn (cpu-gpr-ref cpu n)) (proc-shifted shifted) (proc-carry (cpu-pstate.c cpu))))\n  (cond\n    [(r15? d)\n     (if setflags\n         (alu-exception-return cpu result)\n         (alu-write-pc cpu result))]\n    [else\n     (cpu-gpr-set! cpu d result)\n     (when setflags\n       (cpu-pstate.nzcv-set! cpu nzcv))]))\n\n(define interpret-sub/subs\n  (curry interpret-arithmetic identity bvnot (const (bv #b1 1))))\n\n(define interpret-rsb/rsbs\n  (curry interpret-arithmetic bvnot identity (const (bv #b1 1))))\n\n(define interpret-add/adds\n  (curry interpret-arithmetic identity identity (const (bv #b0 1))))\n\n(define interpret-adc/adcs\n  (curry interpret-arithmetic identity identity identity))\n\n(define interpret-sbc/sbcs\n  (curry interpret-arithmetic identity bvnot identity))\n\n(define interpret-rsc/rscs\n  (curry interpret-arithmetic bvnot identity identity))\n\n\n(define-insn (S Rn Rd imm5 stype Rm)\n  #:encode (lambda (opc) (list (bv #b0000 4) (bv opc 3) S Rn Rd imm5 stype (bv #b0 1) Rm))\n  [(#b000) and/ands-register interpret-and/ands]\n  [(#b001) eor/eors-register interpret-eor/eors]\n  [(#b010) sub/subs-register interpret-sub/subs]\n  [(#b011) rsb/rsbs-register interpret-rsb/rsbs]\n  [(#b100) add/adds-register interpret-add/adds]\n  [(#b101) adc/adcs-register interpret-adc/adcs]\n  [(#b110) sbc/sbcs-register interpret-sbc/sbcs]\n  [(#b111) rsc/rscs-register interpret-rsc/rscs])\n\n(define and-register\n  (curry and/ands-register (bv #b0 1)))\n\n(define ands-register\n  (curry and/ands-register (bv #b1 1)))\n\n(define eor-register\n  (curry eor/eors-register (bv #b0 1)))\n\n(define eors-register\n  (curry eor/eors-register (bv #b1 1)))\n\n(define sub-register\n  (curry sub/subs-register (bv #b0 1)))\n\n(define subs-register\n  (curry sub/subs-register (bv #b1 1)))\n\n(define rsb-register\n  (curry rsb/rsbs-register (bv #b0 1)))\n\n(define rsbs-register\n  (curry rsb/rsbs-register (bv #b1 1)))\n\n(define add-register\n  (curry add/adds-register (bv #b0 1)))\n\n(define adds-register\n  (curry add/adds-register (bv #b1 1)))\n\n(define adc-register\n  (curry adc/adcs-register (bv #b0 1)))\n\n(define adcs-register\n  (curry adc/adcs-register (bv #b1 1)))\n\n(define sbc-register\n  (curry sbc/sbcs-register (bv #b0 1)))\n\n(define sbcs-register\n  (curry sbc/sbcs-register (bv #b1 1)))\n\n(define rsc-register\n  (curry rsc/rscs-register (bv #b0 1)))\n\n(define rscs-register\n  (curry rsc/rscs-register (bv #b1 1)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Could you restate the Rosette semantics for the ARM integer test/compare immediate group (TST, TEQ, CMP, CMN) including the decode helper and status flag updates?"},{"role":"assistant","content":"<think>\nInstruction group: integer-test-and-compare immediate decoded via define-insn over (Rn,imm12) with a32-expand-imm_c feeding symbolic imm32 and carry. Symbolic registers flow through cpu-gpr-ref while the interpreter writes cpu-pstate.{n,z,c,v}, leaving V untouched for logical ops and using add-with-carry for CMP/CMN. Solver obligations include maintaining bit 31 extraction, zero detection, and NZCV tuple constraints for symbolic operands.\n</think>\n\n```racket\n(define (decode cpu Rn imm12)\n  (define n Rn)\n  (define-values (imm32 carry) (a32-expand-imm_c imm12 (cpu-pstate.c cpu)))\n  (values n imm32 carry))\n\n(define (interpret-t* proc cpu Rn imm12)\n  (define-values (n imm32 carry) (decode cpu Rn imm12))\n  (define result (proc (cpu-gpr-ref cpu n) imm32))\n  (cpu-pstate.n-set! cpu (bit 31 result))\n  (cpu-pstate.z-set! cpu (is-zero-bit result))\n  (cpu-pstate.c-set! cpu carry)\n  ; PSTATE.V unchanged\n)\n\n(define interpret-tst\n  (curry interpret-t* bvand))\n\n(define interpret-teq\n  (curry interpret-t* bvxor))\n\n(define (interpret-c* proc cpu Rn imm12)\n  (define-values (n imm32 _) (decode cpu Rn imm12))\n  (define-values (result nzcv) (add-with-carry (cpu-gpr-ref cpu n) (proc imm32) (proc (bv #b0 1))))\n  (cpu-pstate.nzcv-set! cpu nzcv))\n\n(define interpret-cmp\n  (curry interpret-c* bvnot))\n\n(define interpret-cmn\n  (curry interpret-c* identity))\n\n\n(define-insn (Rn imm12)\n  #:encode (lambda (opc) (list (bv #b00110 5) (bv opc 2) (bv #b1 1) Rn (bv #b0000 4) imm12))\n  [(#b00) tst-immediate interpret-tst]\n  [(#b01) teq-immediate interpret-teq]\n  [(#b10) cmp-immediate interpret-cmp]\n  [(#b11) cmn-immediate interpret-cmn])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Please give me the Rosette snippet for the ARM register-based TST/TEQ/CMP/CMN instructions, showing how the shifter operand and NZCV writes are modeled."},{"role":"assistant","content":"<think>\nInstruction group: integer-test-and-compare register form with decode extracting (Rn,imm5,stype,Rm) and decode-imm-shift producing shift_t/n. Symbolic operands come from cpu-gpr-ref plus shift_c/shift to deliver both shifted value and carry. Constraints ensure zero detection, bit 31, and add-with-carry NZCV tuple respect the shifter result, while the solver must track the carry returned from shift_c and CPC flag usage.\n</think>\n\n```racket\n(define (decode Rn imm5 stype Rm)\n  (define n Rn)\n  (define m Rm)\n  (define-values (shift_t shift_n) (decode-imm-shift stype imm5))\n  (values n m shift_t shift_n))\n\n(define (interpret-t* proc cpu Rn imm5 stype Rm)\n  (define-values (n m shift_t shift_n) (decode Rn imm5 stype Rm))\n  (define-values (shifted carry) (shift_c (cpu-gpr-ref cpu m) shift_t shift_n (cpu-pstate.c cpu)))\n  (define result (proc (cpu-gpr-ref cpu n) shifted))\n  (cpu-pstate.n-set! cpu (bit 31 result))\n  (cpu-pstate.z-set! cpu (is-zero-bit result))\n  (cpu-pstate.c-set! cpu carry)\n  ; PSTATE.V unchanged\n)\n\n(define interpret-tst\n  (curry interpret-t* bvand))\n\n(define interpret-teq\n  (curry interpret-t* bvxor))\n\n(define (interpret-c* proc cpu Rn imm5 stype Rm)\n  (define-values (n m shift_t shift_n) (decode Rn imm5 stype Rm))\n  (define shifted (shift (cpu-gpr-ref cpu m) shift_t shift_n (cpu-pstate.c cpu)))\n  (define-values (result nzcv) (add-with-carry (cpu-gpr-ref cpu n) (proc shifted) (proc (bv #b0 1))))\n  (cpu-pstate.nzcv-set! cpu nzcv))\n\n(define interpret-cmp\n  (curry interpret-c* bvnot))\n\n(define interpret-cmn\n  (curry interpret-c* identity))\n\n\n(define-insn (Rn imm5 stype Rm)\n  #:encode (lambda (opc) (list (bv #b00010 5) (bv opc 2) (bv #b1 1) Rn (bv #b0000 4) imm5 stype (bv #b0 1) Rm))\n  [(#b00) tst-register interpret-tst]\n  [(#b01) teq-register interpret-teq]\n  [(#b10) cmp-register interpret-cmp]\n  [(#b11) cmn-register interpret-cmn])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Show me the Rosette definition for the logical/arithmetic immediate group (ORR/ORRS, MOV/MOVS) so I can see how the immediate expansion and flag writes are modeled."},{"role":"assistant","content":"<think>\nInstruction group: logical-arithmetic immediate using define-insn over (S,Rn,Rd,imm12) with a32-expand-imm_c generating imm32 plus carry. Symbolic operands include cpu-gpr-ref for Rn, cpu-gpr-set! for Rd, and cpu-pstate bit updates conditioned on setflags. Solver reasoning ties bit 31, zero detection, and carry propagation from the expanded immediate, plus the PC write path guarded by r15?.\n</think>\n\n```racket\n(define (decode cpu S Rn Rd imm12)\n  (define d Rd)\n  (define n Rn)\n  (define setflags (bveq S (bv #b1 1)))\n  (define-values (imm32 carry) (a32-expand-imm_c imm12 (cpu-pstate.c cpu)))\n  (values d n setflags imm32 carry))\n\n(define (interpret proc cpu S Rn Rd imm12)\n  (define-values (d n setflags imm32 carry) (decode cpu S Rn Rd imm12))\n  (define result (proc cpu n imm32))\n  (cond\n    [(r15? d)\n     (if setflags\n         (alu-exception-return cpu result)\n         (alu-write-pc cpu result))]\n    [else\n     (cpu-gpr-set! cpu d result)\n     (when setflags\n       (cpu-pstate.n-set! cpu (bit 31 result))\n       (cpu-pstate.z-set! cpu (is-zero-bit result))\n       (cpu-pstate.c-set! cpu carry)\n       ; PSTATE.V unchanged\n     )]))\n\n(define interpret-orr/orrs\n  (curry interpret\n         (lambda (cpu n imm32)\n           (bvor (cpu-gpr-ref cpu n) imm32))))\n\n(define interpret-mov/movs\n  (curry interpret\n         (lambda (cpu n imm32)\n           imm32)))\n\n\n(define-insn (S Rn Rd imm12)\n  #:encode (lambda (opc) (list (bv #b00111 5) (bv opc 2) S Rn Rd imm12))\n  [(#b00) orr/orrs-immediate interpret-orr/orrs]\n  [(#b01) mov/movs-immediate interpret-mov/movs])\n\n(define orr-immediate\n  (curry orr/orrs-immediate (bv #b0 1)))\n\n(define orrs-immediate\n  (curry orr/orrs-immediate (bv #b1 1)))\n\n(define mov-immediate\n  (curry mov/movs-immediate (bv #b0 1) (integer->gpr 0)))\n\n(define movs-immediate\n  (curry mov/movs-immediate (bv #b1 1) (integer->gpr 0)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"For the register form of ORR/MOV (and the shift aliases), please provide the Rosette semantics covering decode, shifter carry, and NZCV writes."},{"role":"assistant","content":"<think>\nInstruction group: logical-arithmetic register decode pulls (S,Rn,Rd,imm5,stype,Rm) and runs decode-imm-shift, so operands plus shift metadata stay symbolic. shift_c delivers both shifted value and carry, feeding cpu-gpr-set! and cpu-pstate updates when setflags is asserted; solver work couples bit 31, zero tests, and propagated carry with optional PC write path via r15?.\n</think>\n\n```racket\n(define (decode S Rn Rd imm5 stype Rm)\n  (define d Rd)\n  (define n Rn)\n  (define m Rm)\n  (define setflags (bveq S (bv #b1 1)))\n  (define-values (shift_t shift_n) (decode-imm-shift stype imm5))\n  (values d n m setflags shift_t shift_n))\n\n(define (interpret proc cpu S Rn Rd imm5 stype Rm)\n  (define-values (d n m setflags shift_t shift_n) (decode S Rn Rd imm5 stype Rm))\n  (define-values (shifted carry) (shift_c (cpu-gpr-ref cpu m) shift_t shift_n (cpu-pstate.c cpu)))\n  (define result (proc cpu n shifted))\n  (cond\n    [(r15? d)\n     (if setflags\n         (alu-exception-return cpu result)\n         (alu-write-pc cpu result))]\n    [else\n     (cpu-gpr-set! cpu d result)\n     (when setflags\n       (cpu-pstate.n-set! cpu (bit 31 result))\n       (cpu-pstate.z-set! cpu (is-zero-bit result))\n       (cpu-pstate.c-set! cpu carry)\n       ; PSTATE.V\n     )]))\n\n(define interpret-orr/orrs\n  (curry interpret\n         (lambda (cpu n shifted)\n           (bvor (cpu-gpr-ref cpu n) shifted))))\n\n(define interpret-mov/movs\n  (curry interpret\n         (lambda (cpu n shifted)\n           shifted)))\n\n\n(define-insn (S Rn Rd imm5 stype Rm)\n  #:encode (lambda (opc) (list (bv #b00011 5) (bv opc 2) S Rn Rd imm5 stype (bv #b0 1) Rm))\n  [(#b00) orr/orrs-register interpret-orr/orrs]\n  [(#b01) mov/movs-register interpret-mov/movs])\n\n(define orr-register\n  (curry orr/orrs-register (bv #b0 1)))\n\n(define orrs-register\n  (curry orr/orrs-register (bv #b1 1)))\n\n(define mov-register\n  (curry mov/movs-register (bv #b0 1) (integer->gpr 0)))\n\n(define movs-register\n  (curry mov/movs-register (bv #b1 1) (integer->gpr 0)))\n\n; aliases\n\n(define (lsl-immediate Rd imm5 Rm)\n  (mov-register Rd imm5 (bv #b00 2) Rm))\n\n(define (lsr-immediate Rd imm5 Rm)\n  (mov-register Rd imm5 (bv #b01 2) Rm))\n\n(define (asr-immediate Rd imm5 Rm)\n  (mov-register Rd imm5 (bv #b10 2) Rm))\n\n(define (ror-immediate Rd imm5 Rm)\n  (mov-register Rd imm5 (bv #b11 2) Rm))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Please share the Rosette semantics for the ORR/MOV register-shifted register instructions so I can study the Rs-controlled shifter and NZCV handling."},{"role":"assistant","content":"<think>\nInstruction group: logical-arithmetic register-shifted-register decoding (S,Rn,Rd,Rs,stype,Rm) via define-insn and decode-reg-shift. Symbolic regs Rn,Rm,Rs feed shift_n = extract from Rs, with shift_c returning both value and carry, and unpredictable is raised if any operand is r15. solver work links zero-extended shift amount, NZCV flag writes, and cpu-gpr-set! results for symbolic shifts.\n</think>\n\n```racket\n(define (decode S Rn Rd Rs stype Rm)\n  (define d Rd)\n  (define n Rn)\n  (define m Rm)\n  (define s Rs)\n  (define setflags (bveq S (bv #b1 1)))\n  (define shift_t (decode-reg-shift stype))\n  (when (|| (r15? d) (r15? n) (r15? m) (r15? s))\n    (unpredictable))\n  (values d n m s setflags shift_t))\n\n(define (interpret proc cpu S Rn Rd Rs stype Rm)\n  (define-values (d n m s setflags shift_t) (decode S Rn Rd Rs stype Rm))\n  (define shift_n (zero-extend (extract 7 0 (cpu-gpr-ref cpu s)) (bitvector 32)))\n  (define-values (shifted carry) (shift_c (cpu-gpr-ref cpu m) shift_t shift_n (cpu-pstate.c cpu)))\n  (define result (proc cpu n shifted))\n  (cpu-gpr-set! cpu d result)\n  (when setflags\n    (cpu-pstate.n-set! cpu (bit 31 result))\n    (cpu-pstate.z-set! cpu (is-zero-bit result))\n    (cpu-pstate.c-set! cpu carry)\n    ; PSTATE.V unchanged\n  ))\n\n(define interpret-orr/orrs\n  (curry interpret\n         (lambda (cpu n shifted)\n           (bvor (cpu-gpr-ref cpu n) shifted))))\n\n(define interpret-mov/movs\n  (curry interpret\n         (lambda (cpu n shifted)\n           shifted)))\n\n\n(define-insn (S Rn Rd Rs stype Rm)\n  #:encode (lambda (opc) (list (bv #b00011 5) (bv opc 2) S Rn Rd Rs (bv #b0 1) stype (bv #b1 1) Rm))\n  [(#b00) orr/orrs-register-shifted-register interpret-orr/orrs]\n  [(#b01) mov/movs-register-shifted-register interpret-mov/movs])\n\n(define orr-register-shifted-register\n  (curry orr/orrs-register-shifted-register (bv #b0 1)))\n\n(define orrs-register-shifted-register\n  (curry orr/orrs-register-shifted-register (bv #b1 1)))\n\n(define mov-register-shifted-register\n  (curry mov/movs-register-shifted-register (bv #b0 1) (integer->gpr 0)))\n\n(define movs-register-shifted-register\n  (curry mov/movs-register-shifted-register (bv #b1 1) (integer->gpr 0)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Can you provide the Rosette semantics for MOVW and MOVT so I can see how the halfword immediate is decoded and written into the destination register?"},{"role":"assistant","content":"<think>\nInstruction group: move-halfword-immediate decoding (imm4,Rd,imm12) then concatenating to imm16 with an r15? guard. MOVW zero-extends imm16 while MOVT preserves low bits via extract/concat, so solver needs to reason about zero-extension and concatenation with symbolic register contents.\n</think>\n\n```racket\n(define (decode imm4 Rd imm12)\n  (define d Rd)\n  (define imm16 (concat imm4 imm12))\n  (when (r15? d)\n    (unpredictable))\n  (values d imm16))\n\n(define (interpret-movw cpu imm4 Rd imm12)\n  (define-values (d imm16) (decode imm4 Rd imm12))\n  (cpu-gpr-set! cpu d (zero-extend imm16 (bitvector 32))))\n\n(define (interpret-movt cpu imm4 Rd imm12)\n  (define-values (d imm16) (decode imm4 Rd imm12))\n  ; R[d]<15:0> unchanged\n  (define lower (extract 15 0 (cpu-gpr-ref cpu d)))\n  (cpu-gpr-set! cpu d (concat imm16 lower)))\n\n\n(define-insn (imm4 Rd imm12)\n  #:encode (lambda (H) (list (bv #b00110 5) (bv H 1) (bv #b00 2) imm4 Rd imm12))\n  [(#b0) movw interpret-movw]\n  [(#b1) movt interpret-movt])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"I am checking the miscellaneous BLX (register) behavior; share the Rosette interpreter so I can see how LR, target, and BX write back are handled."},{"role":"assistant","content":"<think>\nInstruction group: miscellaneous BLX register decode uses Rm only, forbidding r15, and models link register plus BX semantics. Symbolic cpu-gpr-ref supplies the branch target, lr receives pc-4 via cpu-gpr-set!, and bx-write-pc performs the indirect control transfer with reason tag. Solver links these steps plus unpredictable guard.\n</think>\n\n```racket\n(define (interpret-blx-register cpu Rm)\n  (define m Rm)\n  (when (r15? m)\n    (unpredictable))\n\n  (define target (cpu-gpr-ref cpu Rm))\n\n  (define next-instr-addr (bvsub (pc-store-value cpu) (bv 4 32)))\n  (cpu-gpr-set! cpu (integer->gpr 14) next-instr-addr)\n  (bx-write-pc cpu target 'INDCALL))\n\n\n(define-insn (Rm)\n  #:encode (lambda (op0 op1) (list (bv #b00010 5) (bv op0 2) (bv 0 1) (bv -1 12) (bv 0 1) (bv op1 3) Rm))\n  [(#b01 #b011) blx-register interpret-blx-register])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Expose the arm32 base Rosette definitions for CPU state, NZCV flags, and conditional execution so I can reuse them in new data-processing proofs."},{"role":"assistant","content":"<think>\nInstruction group: arm32 base CPU/pstate scaffolding that underpins every interpreter. Structural decoding of state allocates symbolic pc and register vectors via init-cpu, cpu-gpr-ref/set! create the r15 special-case behavior, and condition-holds formalizes CPSR-guarded execution. Solver queries relate CPSR bits, NZCV tuples, and conditional instruction wrappers to the arithmetic semantics built atop this layer.\n</think>\n\n```racket\n(struct pstate (n z c v) #:mutable #:transparent)\n\n(define (pstate.nzcv-set! pstate nzcv)\n  (set-pstate-n! pstate (first nzcv))\n  (set-pstate-z! pstate (second nzcv))\n  (set-pstate-c! pstate (third nzcv))\n  (set-pstate-v! pstate (fourth nzcv)))\n\n(define (pstate->bitvector x)\n  ; set [4:0] to supervisor for simplicity\n  (concat (pstate-n x) (pstate-z x) (pstate-c x) (pstate-v x) (bv 0 23) (bv #b10011 5)))\n\n(define (bitvector->pstate x)\n  (pstate (bit 31 x) (bit 30 x) (bit 29 x) (bit 28 x)))\n\n(define (integer->gpr n)\n  (box (bv n 4)))\n\n(struct cpu (pc rs cpsr memmgr) #:mutable #:transparent\n  #:methods core:gen:gen-cpu\n  [(define (gen-cpu-memmgr cpu) (cpu-memmgr cpu))\n   (define (gen-cpu-pc cpu) (cpu-pc cpu))])\n\n(define (cpu-pc-set! cpu v)\n  (set-cpu-pc! cpu v))\n\n(define (cpu-pc-next! cpu [size (bv 4 32)])\n  (for/all ([pc (cpu-pc cpu) #:exhaustive])\n    (cpu-pc-set! cpu (bvadd size pc))))\n\n; r15 is read as PC + 8.\n(define (cpu-gpr-ref cpu k)\n  (define rs (cpu-rs cpu))\n  (define lst\n    (cons (cons (integer->gpr 15) (bvadd (cpu-pc cpu) (bv 8 32)))\n          (map (lambda (x) (cons (integer->gpr x) (vector-ref rs x))) (range 15))))\n  (cdr (assoc k lst)))\n\n; PC must be modified explicitly using cpu-pc-set! rather than r15.\n(define (cpu-gpr-set! cpu k v)\n  (define rs (cpu-rs cpu))\n  (define lst\n    (map (lambda (x) (cons (integer->gpr x) (lambda () (vector-set! rs x v)))) (range 15)))\n  (define proc (cdr (assoc k lst)))\n  (proc))\n\n(define (cpu-pstate.nzcv-set! cpu nzcv)\n  (pstate.nzcv-set! (cpu-cpsr cpu) nzcv))\n\n(define (cpu-pstate.n cpu) (pstate-n (cpu-cpsr cpu)))\n(define (cpu-pstate.z cpu) (pstate-z (cpu-cpsr cpu)))\n(define (cpu-pstate.c cpu) (pstate-c (cpu-cpsr cpu)))\n(define (cpu-pstate.v cpu) (pstate-v (cpu-cpsr cpu)))\n\n(define (cpu-pstate.n-set! cpu b) (set-pstate-n! (cpu-cpsr cpu) b))\n(define (cpu-pstate.z-set! cpu b) (set-pstate-z! (cpu-cpsr cpu) b))\n(define (cpu-pstate.c-set! cpu b) (set-pstate-c! (cpu-cpsr cpu) b))\n(define (cpu-pstate.v-set! cpu b) (set-pstate-v! (cpu-cpsr cpu) b))\n\n(define (init-cpu memmgr)\n  (define-symbolic* pc (bitvector 32))\n  (define-symbolic* rs (bitvector 32) #:length 15)\n  (define-symbolic* n z c v (bitvector 1))\n  (define cpsr (pstate n z c v))\n  (cpu pc (list->vector rs) cpsr memmgr))\n\n(define-generics instruction\n  (instruction-encode instruction)\n  (instruction-run instruction cpu))\n\n; instruction-run returns void means that the PC should bump to\n; the next instruction.\n(define (interpret-insn cpu insn)\n  ; Bump the pc for most instructions, which return #<void>.\n  ; Skip for branching instructions, which return #f.\n  (when (instruction-run insn cpu)\n    (cpu-pc-next! cpu)))\n\n\n; conditional instructions\n\n(define (condition-holds cpu cc)\n  ; Evaluate base condition.\n  (define cond<3:1> (extract 3 1 cc))\n  (define result\n    (cond\n      [(bveq cond<3:1> (bv #b000 3)) (bveq (cpu-pstate.z cpu) (bv #b1 1))]\n      [(bveq cond<3:1> (bv #b001 3)) (bveq (cpu-pstate.c cpu) (bv #b1 1))]\n      [(bveq cond<3:1> (bv #b010 3)) (bveq (cpu-pstate.n cpu) (bv #b1 1))]\n      [(bveq cond<3:1> (bv #b011 3)) (bveq (cpu-pstate.v cpu) (bv #b1 1))]\n      [(bveq cond<3:1> (bv #b100 3)) (&& (bveq (cpu-pstate.c cpu) (bv #b1 1)) (bveq (cpu-pstate.z cpu) (bv #b0 1)))]\n      [(bveq cond<3:1> (bv #b101 3)) (bveq (cpu-pstate.n cpu) (cpu-pstate.v cpu))]\n      [(bveq cond<3:1> (bv #b110 3)) (&& (bveq (cpu-pstate.n cpu) (cpu-pstate.v cpu)) (bveq (cpu-pstate.z cpu) (bv #b0 1)))]\n      [(bveq cond<3:1> (bv #b111 3)) #t]))\n\n  ; Condition flag values in the set '111x' indicate always true.\n  ; Otherwise, invert condition if necessary.\n  (if (&& (bveq (bit 0 cc) (bv #b1 1)) (! (bveq cc (bv #b1111 4))))\n      (! result)\n      result))\n\n(define (conditional-instruction-encode insn)\n  (concat (conditional-instruction-cond insn)\n          (instruction-encode (conditional-instruction-raw insn))))\n\n(define (conditional-instruction-run insn cpu)\n  (when (condition-holds cpu (conditional-instruction-cond insn))\n    (instruction-run (conditional-instruction-raw insn) cpu)))\n\n(struct conditional-instruction (cond raw)\n  #:transparent\n  #:methods gen:instruction\n  [(define instruction-encode conditional-instruction-encode)\n   (define instruction-run conditional-instruction-run)])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Remind me how the arm32 interp.rkt module aggregates the instruction groups so I can ensure my build links the right interpreters."},{"role":"assistant","content":"<think>\nInstruction group: arm32 interpreter aggregator that re-exports all instruction modules. Decoding style here is organizational: the file requires each group (branch, integer-data-processing, logical arithmetic, etc.) and uses provide all-from-out to surface their constructors. Solver relevance is indirect, ensuring every symbolic semantics module is reachable through this umbrella module.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"interp/branch-immediate.rkt\"\n  \"interp/extend-and-add.rkt\"\n  \"interp/integer-data-processing-immediate.rkt\"\n  \"interp/integer-data-processing-register.rkt\"\n  \"interp/integer-test-and-compare-immediate.rkt\"\n  \"interp/integer-test-and-compare-register.rkt\"\n  \"interp/load-store-dual-half-signed-byte-immediate.rkt\"\n  \"interp/load-store-multiple.rkt\"\n  \"interp/load-store-word-unsigned-byte-immediate.rkt\"\n  \"interp/logical-arithmetic-immediate.rkt\"\n  \"interp/logical-arithmetic-register.rkt\"\n  \"interp/logical-arithmetic-register-shifted-register.rkt\"\n  \"interp/miscellaneous.rkt\"\n  \"interp/move-halfword-immediate.rkt\"\n  \"interp/multiply-and-accumulate.rkt\"\n  \"interp/reverse.rkt\"\n  \"interp/signed-multiply-divide.rkt\")\n\n(provide (all-from-out\n  \"interp/branch-immediate.rkt\"\n  \"interp/extend-and-add.rkt\"\n  \"interp/integer-data-processing-immediate.rkt\"\n  \"interp/integer-data-processing-register.rkt\"\n  \"interp/integer-test-and-compare-immediate.rkt\"\n  \"interp/integer-test-and-compare-register.rkt\"\n  \"interp/load-store-dual-half-signed-byte-immediate.rkt\"\n  \"interp/load-store-multiple.rkt\"\n  \"interp/load-store-word-unsigned-byte-immediate.rkt\"\n  \"interp/logical-arithmetic-immediate.rkt\"\n  \"interp/logical-arithmetic-register.rkt\"\n  \"interp/logical-arithmetic-register-shifted-register.rkt\"\n  \"interp/miscellaneous.rkt\"\n  \"interp/move-halfword-immediate.rkt\"\n  \"interp/multiply-and-accumulate.rkt\"\n  \"interp/reverse.rkt\"\n  \"interp/signed-multiply-divide.rkt\"))\n```"}]}
