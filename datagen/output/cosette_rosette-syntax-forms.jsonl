{"messages":[{"role":"system","content":"You are the Cosette Rosette Engineer, expert in AST and syntax forms."},{"role":"user","content":"I need a DISTINCT select AST node so deduped projections remember the select list, source, and predicate."},{"role":"assistant","content":"<think>\nThe query-select-distinct constructor captures the same fields as a regular select but signals dedup semantics; select-args and from-query must be aligned so later solvers can reason about unique tuples, and where-filter carries the predicate that feeds SMT encoding.\n</think>\n\n```racket\n;;; query structure\n(struct query-select-distinct (select-args from-query where-filter) #:transparent)\n```"}]}
{"messages":[{"role":"system","content":"You are the Cosette Rosette Engineer, expert in AST and syntax forms."},{"role":"user","content":"Model a left outer join node that keeps both input queries plus the join predicate so null-padding logic is explicit."},{"role":"assistant","content":"<think>\nquery-left-outer-join records the left and right subqueries together with the predicate that controls matching; invariant is that query1 supplies guaranteed rows, while query2 contributes optional rows guided by pred, letting the solver encode null-extension correctly.\n</think>\n\n```racket\n;;; query structure\n(struct query-left-outer-join (query1 query2 pred) #:transparent)\n```"}]}
{"messages":[{"role":"system","content":"You are the Cosette Rosette Engineer, expert in AST and syntax forms."},{"role":"user","content":"Add a general aggregation form that stores grouping keys, the select expressions, and an optional HAVING filter."},{"role":"assistant","content":"<think>\nquery-aggr-general packages the child query, pre-filter, group-by fields, projected aggregates, and a having-filter; gb-fields should enumerate grouping expressions, select-args hold aggregate/value terms, and having-filter may be filter-true to keep the pipeline consistent for equivalence proofs.\n</think>\n\n```racket\n;;; query structure\n(struct query-aggr-general (query where-filter gb-fields select-args having-filter) #:transparent)\n```"}]}
{"messages":[{"role":"system","content":"You are the Cosette Rosette Engineer, expert in AST and syntax forms."},{"role":"user","content":"Represent aggregate subquery values like SUM(subquery) so they can be treated as scalar expressions."},{"role":"assistant","content":"<think>\nval-aggr-subq binds an aggregate function symbol to a subordinate query, enforcing that agg-func describes how rows collapse to a scalar while query carries the correlated/select logic, enabling the evaluator to inline the scalar result wherever a value is expected.\n</think>\n\n```racket\n;;; values\n(struct val-aggr-subq (agg-func query) #:transparent)\n```"}]}
{"messages":[{"role":"system","content":"You are the Cosette Rosette Engineer, expert in AST and syntax forms."},{"role":"user","content":"Create a flexible filter node that can capture arbitrary n-ary predicates like BETWEEN or multi-column comparisons."},{"role":"assistant","content":"<think>\nfilter-nary-op stores an operator tag plus an argument list so validators can ensure arity is respected while still letting solvers pattern-match on higher-order predicates; args must be ordered to preserve semantics and f identifies the logical operator during encoding.\n</think>\n\n```racket\n;;; filters\n(struct filter-nary-op (f args) #:transparent) ; n-ary-operator\n```"}]}
