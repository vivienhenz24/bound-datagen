{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Show me a Rosette regression that proves term<? is irreflexive for both symbolic integers and boolean combinations."},{"role":"assistant","content":"<think>\nterm<? should never rank identical DAG nodes, so we instantiate symbolic ints/bools and their composite forms to ensure every reflexive comparison evaluates to #f. These checks leverage Rosette's canonical term cache, meaning the solver would need a counterexample where two identical nodes are distinguishable, which cannot happen. Keeping both arithmetic (@+) and logical (&&) terms in the sample guards against regressions across different term constructors.\n</think>\n\n```racket\n(define-symbolic x @integer?)\n(define-symbolic y @integer?)\n(define-symbolic z @integer?)\n\n(define-symbolic a @boolean?)\n(define-symbolic b @boolean?)\n(define-symbolic c @boolean?)\n\n(check-false (term<? x x))\n(check-false (term<? a a))\n(check-false (term<? (&& a b) (&& b a)))\n(check-false (term<? (@+ x y z) (@+ x y z))) \n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I need a sample that enforces the total ordering contract for term<? across booleans, integers, and compound expressions."},{"role":"assistant","content":"<think>\nThe helper `check-ordered` encodes comparability (one side must be less) plus antisymmetry (never both ways) using the primitive `term<?`. By exercising it on symbols, negations, conjunctions, and arithmetic forms, we ensure the term ordering stays strict yet total across heterogeneous shapes. Any solver counterexample would have to satisfy both `term<? v1 v2` and `term<? v2 v1`, which the conjunction in the helper forbids.\n</think>\n\n```racket\n(define (check-ordered v1 v2)\n  (check-true (and (or (term<? v1 v2) (term<? v2 v1)) \n                   (not (and (term<? v1 v2) (term<? v2 v1))))))\n\n(check-ordered b a)\n(check-ordered x a)\n(check-ordered x y)\n(check-ordered (! b) (! a))\n(check-ordered (&& b a) (&& a c))\n(check-ordered x (@* x y))\n(check-ordered (@/ x y) (@- x y))\n(check-ordered (@remainder x y) (@+ x y z))\n(check-ordered a (|| a b))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Give me a Rosette test that proves term constructors are cached so repeated applications yield pointer-equal results."},{"role":"assistant","content":"<think>\n`check-cached` maps directly onto Rosette's hash-cons table: calling the same operator with identical arguments twice should reuse the same term. By applying it to boolean connectives and arithmetic operators (@+, @*, etc.), we ensure both propositional and numeric builders stay memoized. Any violation would manifest as `equal?` returning #f, exposing a cache miss and a solver-visible duplication.\n</think>\n\n```racket\n(define (check-cached op . args)\n  (check-true (equal? (apply op args) (apply op args))))\n   \n(check-cached && a b)\n(check-cached || a b)\n(check-cached ! a)\n(check-cached @+ x y)\n(check-cached @- x y)\n(check-cached @* x y)\n(check-cached @/ x y)\n(check-cached @remainder x y)\n(check-cached @= x y)\n(check-cached @< x y)\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Can you capture how clear-terms! and gc-terms! prune the global term table down to the live roots?"},{"role":"assistant","content":"<think>\nThis scenario uses `with-terms` to sandbox the global cache, builds three symbolic arithmetic terms, and checks the size of `(terms)` as we manually evict variables. After clearing `z`, triggering GC, and later dropping `x`, the counts step from 6 -> 4 -> 3 -> 1, showing that only strongly-held nodes survive. The final dummy `list` reference ensures the solver can't reclaim `a b c` prematurely, guarding against regressions in guarded term collection.\n</think>\n\n```racket\n(with-terms '()\n  (let ()\n    (define-symbolic x y z @integer?)\n    (define a (@+ x 1))\n    (define b (@+ y 2))\n    (define c (@+ z 3))\n    (check-equal? (length (terms)) 6)\n\n    ;; this should evict z and c\n    (clear-terms! (list z))\n\n    (check-equal? (length (terms)) 4)\n\n    ;; this doesn't affect strongly-held values\n    (set! b #f)\n\n    (check-equal? (length (terms)) 4)\n\n    (gc-terms!) ; change the representation\n    (collect-garbage)\n\n    (check-equal? (length (terms)) 3)\n\n    (clear-terms! (list x))\n    (collect-garbage)\n\n    (check-equal? (length (terms)) 1)\n\n    ;; this is a dummy check to reference a, b, and c so that\n    ;; they are not garbage-collected earlier\n    (check-equal? (length (list a b c)) 3)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I want a regression that shows merge respects boolean guards and degenerates to ite semantics on constants and equal branches."},{"role":"assistant","content":"<think>\n`merge` should behave like a guard-aware `ite`, so we compare its output against direct expectations for true/false guards and equal branches. Checking `(merge a b c)` equals `(|| (&& a b) (&& (! a) c))` also proves the result's symbolic union matches the guards we expect the solver to reason about. These rackunit checks will fail if merge ever forgets to short-circuit identical branches or mishandles negated guards.\n</think>\n\n```racket\n(define-symbolic x y z w @integer?)\n\n(define-symbolic a b c @boolean?)\n\n(check-equal? (merge #t x y) x)\n(check-equal? (merge #f x y) y)\n(check-equal? (merge a x x) x)\n(check-equal? (merge (! a) x x) x)\n\n(check-equal? (merge a b c) (|| (&& a b) (&& (! a) c)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Demonstrate that nested merges flatten correctly so redundant guard structure is eliminated."},{"role":"assistant","content":"<think>\nThese equalities stress the associativity/absorption laws implemented by `merge`: when the outer guard matches an inner guard (or its negation), the result should collapse to a simpler merge. Each rackunit equality compares the optimized form to the expected canonical term, so any solver-visible redundancies would trip the test. Including both inner `a` and `(! a)` cases ensures guarded simplification works for positive and negative contexts.\n</think>\n\n```racket\n(check-equal? (merge a (merge a x y) z) (merge a x z))\n(check-equal? (merge a (merge (! a) x y) z) (merge a y z))\n(check-equal? (merge a z (merge a x y)) (merge a z y))\n(check-equal? (merge a z (merge (! a) x y)) (merge a z x))\n(check-equal? (merge a (merge a x y) (merge a w z)) (merge a x z))\n(check-equal? (merge a (merge a x y) (merge (! a) w z)) (merge a x w))\n(check-equal? (merge a (merge (! a) x y) (merge a w z)) (merge a y z))\n(check-equal? (merge a (merge (! a) x y) (merge (! a) w z)) (merge a y w))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Provide an example that verifies merge* collapses a chain of guarded pairs into the correct symbolic union."},{"role":"assistant","content":"<think>\n`merge*` consumes `(cons guard value)` pairs, so we check both the degenerate case (returning `z` for the first true guard) and the symbolic summary exposed by `check-union?`. The union literal enumerates the path conditions that survive after simplification, ensuring merge* preserves the ite* structure for overlapping guards `a`, `b`, and `c`. Any mistake in guard combination would either drop a case or mis-thread the ite*, immediately failing the union equality.\n</think>\n\n```racket\n(check-equal? (merge* (cons a b) (cons #f x) (cons b y) (cons #t z) (cons c w)) z)\n(check-union? (merge* (cons a b) (cons #f x) (cons b y) (cons c w))\n              { [a b] [(|| b c) (ite* (cons c w) (cons b y))] })\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I need to see how merge distributes over lists and records each branch in the union summary."},{"role":"assistant","content":"<think>\nList-typed merges should preserve element-wise guards, so we assert both direct equality (empty lists, singleton lists) and explicit guard/value unions via `check-union?`. By composing merges of merges, we ensure guard combinations like `(&& (! a) c)` surface correctly in the symbolic store. If merge dropped a branch or mis-ordered the list constructor, VC comparison in `check-union?` would fail.\n</think>\n\n```racket\n(check-equal? (merge a (list) (list)) (list)) \n(check-equal? (merge a (list b) (list c)) (list (|| (&& c (! a)) (&& a b))))\n(check-union? (merge a (list b) (merge a (list x y) (list)))\n              { [a (list b)] [(! a) (list)]})\n(check-union? (merge a (merge b (list b) z) (merge c (list x y) z))\n              { [(&& a b) (list b)] [(|| (&& a (! b)) (&& (! a) (! c))) z] \n                [(&& (! a) c) (list x y)]})\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Capture how merging procedures preserves procedure types and accumulates VC obligations when mixing struct-callables with arithmetic functions."},{"role":"assistant","content":"<think>\nHere we give `S` a procedure property so its instances behave like closures, then merge it with `*` under guard `a`. After clearing the VC, we ensure invoking the merged procedure returns 1 (the field) and later multiplies like `*`, while `check-vc-eqv` confirms the outstanding obligation is `(! a)` because the arithmetic branch only runs when `a` is false. Any regression in merge's procedure specialization or VC propagation would make the equality or VC checks fail.\n</think>\n\n```racket\n(struct S (x)\n  #:property prop:procedure\n  (lambda (self) (S-x self)))\n\n(struct P S ())\n(struct Q ())\n\n(define (procedure-merge-tests)\n  (check-equal? (merge a identity identity) identity)\n  (check-equal? (@procedure? (merge a identity 2)) a)\n  \n  (define s (S 1))\n  (define p (P 2))\n  (define q (Q))\n  \n  (check-true (@procedure? s))\n  (check-true (subtype? (type-of s) @procedure?))\n  (check-true (subtype? (type-of p) @procedure?))\n  (check-false (subtype? (type-of q) @procedure?))\n  \n  (clear-vc!)\n  (define s* (merge a s *))\n  (check-equal? (s*) 1)\n  (check-pred vc-true? (vc))\n  (check-equal? (s* 3 2) 6)\n  (check-vc-eqv #t (! a))\n  (clear-vc!))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Produce a guard-eval example where eval-assuming threads both store updates and VC obligations from asserts/assumes."},{"role":"assistant","content":"<think>\n`check-normal`/`check-failed` destructure the `result` values so we can compare both box state and accumulated VC triples. By running eval-assuming under guard `g`, we see how `@assert` contributes `(=> g a)` to asserts while `@assume` threads into new assumptions like `(&& g (=> a b))`. The failing cases exercise core vs user exceptions, showing the solver raises the right predicate when assumptions contradict the surrounding guard.\n</think>\n\n```racket\n(define-syntax-rule (check-normal actual e-val e-store e-assumes e-asserts)\n  (begin\n    (match-define (normal (normal v st) sp) actual)\n    (check-equal? v e-val)\n    (check-store st e-store)\n    (check-true (vc-eqv? sp e-assumes e-asserts))))\n\n(define-syntax-rule (check-failed actual e-exn? e-assumes e-asserts)\n  (begin\n    (match-define (failed ex sp) actual)\n    (check-pred e-exn? ex) \n    (check-true (vc-eqv? sp e-assumes e-asserts))))\n\n(define (check-eval-assuming)\n  (define-symbolic g a b @boolean?)\n  (define x (@box 3))\n  ;---------------------------;\n  (check-normal (eval-assuming #t (const 1))\n             1 null #t #t)\n  (check-normal (eval-assuming g (lambda () (@set-box! x 4) (@assert a)))\n             (void) `((,x 0 4)) g (=> g a))\n  (check-normal (eval-assuming g (lambda () (@set-box! x 5) (@assert a) (@assume b)))\n             (void) `((,x 0 5)) (&& g (=> a b)) (=> g a))\n  ;---------------------------;\n  (check-failed (eval-assuming g (lambda () (@set-box! x 2) (@assume (! g))))\n              exn:fail:svm:assume:user? #f #t)\n  (check-failed (eval-assuming g (lambda () (@set-box! x 5) (@assert #f)))\n              exn:fail:svm:assert:user? g (! g))\n  (check-failed (eval-assuming g (lambda () (@set-box! x 7) (1)))\n              exn:fail:svm:assert:err? g (! g))\n  ;---------------------------;\n  (check-equal? (@unbox x) 3)\n  (check-pred vc-true? (vc)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Show how eval-guarded! handles a single guard: propagating asserts to the VC and raising merge failures when assumptions conflict."},{"role":"assistant","content":"<think>\n`check-vc-and-cell` synchronizes the vc cache with the box cell so we can see exactly what eval-guarded! committed after each thunk. In the success path, an `@assert` under guard `g` yields `(=> g a)` in the VC, while chaining an `@assume b` forces the accumulated assumption `(=> g (=> a b))`. The later `@assume (! g)` and `@assert #f` thunks deliberately break the merge so we observe exn:fail:svm:merge? with the side condition (`(! g)` or `#t`) captured in the VC snapshot.\n</think>\n\n```racket\n(define-syntax-rule (check-vc-and-cell e-assumes e-asserts cell e-cell-val)\n  (begin\n    (check-vc-eqv e-assumes e-asserts)\n    (check-true (int-eqv? (@unbox cell) e-cell-val))\n    (clear-vc!)\n    (@set-box! cell 1)))\n\n(define (check-eval-guarded-0)\n  (define-symbolic g a b c @boolean?)\n  (define x (@box 1))\n  ;---------------------------;\n  (eval-guarded! (list g) (list (lambda () (@set-box! x 4) (@assert a))))\n  (check-vc-and-cell #t (=> g a) x 4)\n  (eval-guarded! (list g) (list (lambda () (@set-box! x 5) (@assert a) (@assume b))))\n  (check-vc-and-cell (=> g (=> a b)) (=> g a) x 5)\n  ;---------------------------;\n  (check-exn exn:fail:svm:merge? (thunk (eval-guarded! null null)))\n  (check-vc-and-cell c #t x 1)\n  (check-exn exn:fail:svm:merge? (thunk (eval-guarded! (list g) (list (lambda () (@set-box! x 2) (@assume (! g)))))))\n  (check-vc-and-cell (! g) #t x 1)\n  (check-exn exn:fail:svm:merge? (thunk (eval-guarded! (list g) (list (lambda () (@set-box! x 3) (@assert #f))))))\n  (check-vc-and-cell #t (! g) x 1))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Give me a multi-branch eval-guarded! example where complementary guards merge their results and conflicting obligations raise merge errors."},{"role":"assistant","content":"<think>\nWhen the guard vector is `(list g !g)`, eval-guarded! should return `merge`d values whenever both thunks finish normally, and it should surface merge-time failures if one branch produces an impossible VC. The helper closures `λ-set`, `λ-set-assume`, and `λ-set-assert` let us mix state updates with assumptions/assertions so we can observe the resulting VC snapshot via `check-vc-and-cell`. The final `exn:fail:svm:merge?` checks ensure merge-vc! aborts when one branch assumes #f while the other asserts #f, leaving the VC in the expected (`(! g)` or `g`) configuration.\n</think>\n\n```racket\n(define (check-eval-guarded-1)\n  (define-symbolic g a b c @boolean?)\n  (define-symbolic i @integer?)\n  (define !g (! g))\n  (define x (@box 1))\n  (define (λ-set v [r v]) (lambda () (@set-box! x v) r))\n  (define (λ-set-assume v a [r v]) (lambda () (@set-box! x v) (@assume a) r))\n  (define (λ-set-assert v a [r v]) (lambda () (@set-box! x v) (@assert a) r))\n  (define (λ-set-err v)      (lambda () (@set-box! x v) (1) v))\n  ;---------------------------;\n  (check-equal? (eval-guarded! (list g !g) (list (const 1) (const 2))) (merge g 1 2))\n  (check-vc-and-cell #t #t x 1)\n  (check-equal? (eval-guarded! (list g !g) (list (λ-set 2 1) (λ-set 3 2))) (merge g 1 2))\n  (check-vc-and-cell #t #t x (merge g 2 3))\n  (check-equal? (eval-guarded! (list g !g) (list (λ-set-assume 2 #f) (λ-set 3 2))) 2)\n  (check-vc-and-cell (! g) #t x 3)\n  (check-equal? (eval-guarded! (list g !g) (list (λ-set-assert 2 #f) (λ-set 3 2))) 2)\n  (check-vc-and-cell #t (! g) x 3)\n  (check-exn exn:fail:svm:merge? \n    (thunk (eval-guarded! (list g !g) (list (λ-set-assume 2 #f) (λ-set-assert 3 #f)))))\n  (check-vc-and-cell (! g) g x 1)\n  (check-exn exn:fail:svm:merge?  \n    (thunk (eval-guarded! (list g !g) (list (λ-set-assert 2 #f) (λ-set-assume 3 #f)))))\n  (check-vc-and-cell g (! g) x 1))\n```"}]}
