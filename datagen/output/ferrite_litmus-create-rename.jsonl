{"messages":[{"role":"system","content":"You are the Ferrite Rosette Litmus Engineer, expert in consistency testing and litmus design."},{"role":"user","content":"Can you validate on SeqFS that creating inode 0, writing the two-bit payload, and renaming it to slot 1 without calling fsync still stays within the allowed ondisk states?"},{"role":"assistant","content":"<think>\nOperations: creat 0, write (#t #t), rename 0->1 with no fsync; sequential execution so ordering is fixed even though durability is deferred.\nConstraints: create-rename-allow restricts ondisk entry 1 to either remain #f or store '(#t #t), so any stale rename result must violate those equalities.\nSolver: build the litmus with seq-fs 2 and verify-correctness, expecting an unsat counterexample plus four enumerated legal outcomes.\n</think>\n\n```racket\n(define create-rename-setup '())\n\n(define create-rename-test-incorrect\n  (list\n   (creat 0)\n   (write 0 '(#t #t))\n   ; (fsync 0)\n   (rename 0 1)))\n\n(define (create-rename-allow oldfs newfs)\n  (define new-1 (ondisk newfs 1))\n  (list (equal? new-1 #f)\n        (equal? new-1 '(#t #t))))\n\n(define (create-rename-fs-seqfs)\n  (seq-fs 2))\n\n(define (test-seqfs-incorrect)\n  (define test\n    (litmus create-rename-fs-seqfs create-rename-setup create-rename-test-incorrect create-rename-allow))\n  (define-values (cex state) (verify-correctness test))\n  (check-true (unsat? cex))\n  (check-false state)\n  (define all-states (all-outcomes test))\n  (check equal? (length all-states) 4))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Litmus Engineer, expert in consistency testing and litmus design."},{"role":"user","content":"I need a litmus showing that AdvFS can expose an empty target when we creat inode 0, write the payload, and rename it to slot 1 without doing fsync."},{"role":"assistant","content":"<think>\nOperations: creat 0, write '(#t #t), rename 0->1 run sequentially but AdvFS allows rename metadata to persist before the data block flushes.\nConstraints: allowance demands ondisk entry 1 is #f or '(#t #t); the counterexample sets it to '(), proving stale rename.\nSolver: run verify-correctness on the AdvFS litmus, expect sat cex plus only three enumerated states because the write never synchronizes.\n</think>\n\n```racket\n(define create-rename-setup '())\n\n(define create-rename-test-incorrect\n  (list\n   (creat 0)\n   (write 0 '(#t #t))\n   ; (fsync 0)\n   (rename 0 1)))\n\n(define (create-rename-allow oldfs newfs)\n  (define new-1 (ondisk newfs 1))\n  (list (equal? new-1 #f)\n        (equal? new-1 '(#t #t))))\n\n(define (create-rename-fs-advfs)\n  (adv-fs 2))\n\n(define (test-advfs-incorrect)\n  (define test\n    (litmus create-rename-fs-advfs create-rename-setup create-rename-test-incorrect create-rename-allow))\n  (define-values (cex state) (verify-correctness test))\n  (check-true (sat? cex))\n  (check-true (equal? (ondisk state 1) '()))\n  (define all-states (all-outcomes test))\n  (check equal? (length all-states) 3))  ; only 3 states: the write can never be synced\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Litmus Engineer, expert in consistency testing and litmus design."},{"role":"user","content":"Show me the ext4 litmus where we create inode 0, write the bits, skip fsync, and rename it to slot 1 so we can see rename reordering ahead of persistence."},{"role":"assistant","content":"<think>\nOperations: creat 0, write '(#t #t), rename 0->1 without fsync; ext4 permits metadata rename to hit disk before the data block, so the ordering can violate durability semantics.\nConstraints: allowed outcomes keep ondisk entry 1 either #f or '(#t #t); if rename lands while the data is absent we exceed that set.\nSolver: instantiate ext4-fs with capacity 2 and specified block size, call verify-correctness to obtain a sat counterexample and enumerate five possible states.\n</think>\n\n```racket\n(define small? #f)\n(define block-size (if small? 64 4096))\n(define create-rename-setup '())\n\n(define create-rename-test-incorrect\n  (list\n   (creat 0)\n   (write 0 '(#t #t))\n   ; (fsync 0)\n   (rename 0 1)))\n\n(define (create-rename-allow oldfs newfs)\n  (define new-1 (ondisk newfs 1))\n  (list (equal? new-1 #f)\n        (equal? new-1 '(#t #t))))\n\n(define (create-rename-fs-ext4)\n  (ext4-fs #:capacity 2 #:blocksize block-size))\n\n(define (test-ext4-incorrect)\n  (define test\n    (litmus create-rename-fs-ext4 create-rename-setup create-rename-test-incorrect create-rename-allow))\n  (define-values (cex state) (verify-correctness test))\n  (check-true (sat? cex)) ; rename can be reordered before sync\n  (define all-states (all-outcomes test))\n  (check equal? (length all-states) 5))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Litmus Engineer, expert in consistency testing and litmus design."},{"role":"user","content":"Can you give me the ext4 litmus that proves adding fsync before the rename keeps the create/write/rename sequence within the allowed outcomes?"},{"role":"assistant","content":"<think>\nOperations: creat 0, write '(#t #t), fsync 0, then rename 0->1; sequential ordering forces the flush before metadata relink.\nConstraints: the allow clause again restricts ondisk slot 1 to #f or '(#t #t); once fsync commits data, rename can no longer violate it.\nSolver: run verify-correctness on the ext4 litmus and confirm the solver returns unsat with four enumerated legal states.\n</think>\n\n```racket\n(define small? #f)\n(define block-size (if small? 64 4096))\n(define create-rename-setup '())\n\n(define create-rename-test-correct\n  (list\n   (creat 0)\n   (write 0 '(#t #t))\n   (fsync 0)\n   (rename 0 1)))\n\n(define (create-rename-allow oldfs newfs)\n  (define new-1 (ondisk newfs 1))\n  (list (equal? new-1 #f)\n        (equal? new-1 '(#t #t))))\n\n(define (create-rename-fs-ext4)\n  (ext4-fs #:capacity 2 #:blocksize block-size))\n\n(define (test-ext4-correct)\n  (define test\n    (litmus create-rename-fs-ext4 create-rename-setup create-rename-test-correct create-rename-allow))\n  (define-values (cex state) (verify-correctness test))\n  (check-true (unsat? cex))\n  (check-false state)\n  (define all-states (all-outcomes test))\n  (check equal? (length all-states) 4))\n```"}]}
