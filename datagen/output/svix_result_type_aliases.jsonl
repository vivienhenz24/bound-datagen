{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"We need a Result type alias that defaults to our Svix Error so every module can just use Result<T> without rewriting the error type each time."},{"role":"assistant","content":"<think>\nResult aliases keep engineering consistent across services, and defining Result<T, E = Error> bakes in our Svix error context without extra allocations. I'll place it next to the shared imports so every module can pull it in with the rest of our error plumbing.\n</think>\n\n```rust\nuse std::{error, fmt, panic::Location};\n\nuse aide::OperationOutput;\nuse axum::{\n    extract::rejection::{ExtensionRejection, PathRejection},\n    response::{IntoResponse, Response},\n    Json,\n};\nuse hyper::StatusCode;\nuse schemars::JsonSchema;\nuse sea_orm::{DbErr, RuntimeErr, TransactionError};\nuse serde::Serialize;\nuse serde_json::json;\n\nuse crate::core::webhook_http_client;\n\n/// A short-hand version of a [`std::result::Result`] that defaults to Svix'es [Error].\npub type Result<T, E = Error> = std::result::Result<T, E>;\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Define the core Error struct that every Result alias resolves to, including the trace metadata so we can inspect caller locations in production issues."},{"role":"assistant","content":"<think>\nOur Result alias wraps this Error type, so it must carry both the structured ErrorType and the Vec of Location frames for context. Keeping the trace data inline avoids extra allocations while letting us enrich errors with caller info.\n</think>\n\n```rust\n/// The error type returned from the Svix API\n#[derive(Debug)]\npub struct Error {\n    // the file name and line number of the error. Used for debugging non Http errors\n    pub trace: Vec<&'static Location<'static>>,\n    pub typ: ErrorType,\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Expose constructor helpers on Error so our Result alias callers can mint typed errors with #[track_caller] context for each backend concern (db, queue, http, cache, etc.)."},{"role":"assistant","content":"<think>\nResult<T> ties straight into Error, so providing focused constructors keeps every call site consistent and ensures we capture Location::caller without extra plumbing. Each helper just wraps ErrorType variants, and http() skips trace allocations because HTTP errors already carry status.\n</think>\n\n```rust\nimpl Error {\n    #[track_caller]\n    fn new(typ: ErrorType) -> Self {\n        let trace = vec![Location::caller()];\n        Self { trace, typ }\n    }\n\n    #[track_caller]\n    pub fn generic(s: impl fmt::Display) -> Self {\n        Self::new(ErrorType::Generic(s.to_string()))\n    }\n\n    #[track_caller]\n    pub fn database(s: impl fmt::Display) -> Self {\n        Self::new(ErrorType::Database(s.to_string()))\n    }\n\n    #[track_caller]\n    pub fn conflict(e: DbErr) -> Self {\n        Self::new(ErrorType::Conflict(e))\n    }\n\n    #[track_caller]\n    pub fn queue(s: impl fmt::Display) -> Self {\n        Self::new(ErrorType::Queue(s.to_string()))\n    }\n\n    #[track_caller]\n    pub fn validation(s: impl fmt::Display) -> Self {\n        Self::new(ErrorType::Validation(s.to_string()))\n    }\n\n    #[track_caller]\n    pub fn http(h: HttpError) -> Self {\n        Self {\n            trace: Vec::with_capacity(0), // no debugging necessary\n            typ: ErrorType::Http(h),\n        }\n    }\n\n    #[track_caller]\n    pub fn cache(s: impl fmt::Display) -> Self {\n        Self::new(ErrorType::Cache(s.to_string()))\n    }\n\n    #[track_caller]\n    pub fn timeout(s: impl fmt::Display) -> Self {\n        Self::new(ErrorType::Timeout(s.to_string()))\n    }\n\n    #[track_caller]\n    pub fn db_timeout(s: impl fmt::Display) -> Self {\n        Self::new(ErrorType::DbTimeout(s.to_string()))\n    }\n\n    #[track_caller]\n    pub fn connection_timeout(e: DbErr) -> Self {\n        Self::new(ErrorType::ConnectionTimeout(e))\n    }\n\n    #[track_caller]\n    pub fn trace(mut self) -> Self {\n        self.trace.push(Location::caller());\n        self\n    }\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Hook up Display for our Error type so anything using the Result alias formats consistently by delegating to the underlying ErrorType."},{"role":"assistant","content":"<think>\nDisplay must be cheap because Result<T> is everywhere, so I'll just forward fmt to ErrorType. That keeps the stringification logic centralized and preserves the context encoded in each variant.\n</think>\n\n```rust\nimpl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.typ.fmt(f)\n    }\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Implement std::error::Error for our Error so anything returning Result<T> integrates with anyhow and axum error stacks."},{"role":"assistant","content":"<think>\nWe don't chain underlying std::error::Error values because Svix encodes context in ErrorType. Returning None from source keeps things simple while satisfying the trait so our Result alias composes with ecosystem traits.\n</think>\n\n```rust\nimpl error::Error for Error {\n    fn source(&self) -> Option<&(dyn error::Error + 'static)> {\n        None\n    }\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Wire Error into axum's IntoResponse so Result<T> handlers automatically log traces and convert HTTP variants into proper responses."},{"role":"assistant","content":"<think>\nEvery handler returns our Result alias, so IntoResponse must preserve the trace for observability and only expose HttpError details when appropriate. I'll stringify the trace stack for logging and return 500s for non-HTTP variants.\n</think>\n\n```rust\nimpl IntoResponse for Error {\n    fn into_response(self) -> Response {\n        let stringified: Vec<String> = self.trace.into_iter().map(ToString::to_string).collect();\n        match self.typ {\n            ErrorType::Http(s) => {\n                tracing::debug!(\"{:?}, location: {:?}\", &s, stringified);\n                s.into_response()\n            }\n            s => {\n                tracing::error!(\"type: {:?}, location: {:?}\", s, stringified);\n                (StatusCode::INTERNAL_SERVER_ERROR, Json(json!({}))).into_response()\n            }\n        }\n    }\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Mark Error as an aide OperationOutput so our OpenAPI layer can surface Result aliases directly."},{"role":"assistant","content":"<think>\nThe aide integration expects OperationOutput to expose the inner type. Since our Result alias always yields Error, we can just set type Inner = Self to keep schema generation happy.\n</think>\n\n```rust\nimpl OperationOutput for Error {\n    type Inner = Self;\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Add a Traceable trait so any Result alias can push caller locations onto the Error trace stack when bubbling up failures."},{"role":"assistant","content":"<think>\nTrace augmentation needs #[track_caller] to capture the correct frame. I'll define a trait that consumes self and returns Result<T> so chained calls can append context before propagating the Error.\n</think>\n\n```rust\npub trait Traceable<T> {\n    /// Pushes the current [`Location`] onto the error's trace stack\n    #[track_caller]\n    fn trace(self) -> Result<T>;\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Provide the Traceable implementation for our Result alias so we can call .trace() in async workflows without losing caller info."},{"role":"assistant","content":"<think>\nBecause Result<T, Error> already carries the trace Vec, the impl just needs to re-wrap Err variants after invoking Error::trace(). Matching manually instead of map_err preserves #[track_caller].\n</think>\n\n```rust\nimpl<T> Traceable<T> for Result<T> {\n    fn trace(self) -> Result<T> {\n        // Using `map_err` would lose `#[track_caller]` information\n        match self {\n            Err(e) => Err(e.trace()),\n            ok => ok,\n        }\n    }\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Document the ErrorType enum that backs our Result alias so each subsystem (db, queue, cache, http, etc.) carries structured context."},{"role":"assistant","content":"<think>\nResult<T> funnels into ErrorType variants, so we need exhaustive coverage for every backend plus DbErr-based conflicts and timeouts. Keeping it documented helps downstream tooling reason about error surfaces.\n</think>\n\n```rust\n#[derive(Debug)]\npub enum ErrorType {\n    /// A generic error\n    Generic(String),\n    /// Database error\n    Database(String),\n    /// Queue error\n    Queue(String),\n    /// Database error\n    Validation(String),\n    /// Any kind of HttpError\n    Http(HttpError),\n    /// Cache error\n    Cache(String),\n    /// Timeout error\n    Timeout(String),\n    /// Database timeout error\n    DbTimeout(String),\n    /// Connection timeout error\n    ConnectionTimeout(DbErr),\n    /// Conflict error\n    Conflict(DbErr),\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Ensure ErrorType implements Display so formatting a Result<T> error delegates to the underlying payload string or HttpError."},{"role":"assistant","content":"<think>\nEach ErrorType already stores a type that implements Display, so the formatter just needs to match and forward fmt(). That gives us uniform strings everywhere our Result alias is logged.\n</think>\n\n```rust\nimpl fmt::Display for ErrorType {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Generic(s) => s.fmt(f),\n            Self::Database(s) => s.fmt(f),\n            Self::Queue(s) => s.fmt(f),\n            Self::Validation(s) => s.fmt(f),\n            Self::Http(s) => s.fmt(f),\n            Self::Cache(s) => s.fmt(f),\n            Self::Timeout(s) => s.fmt(f),\n            Self::DbTimeout(s) => s.fmt(f),\n            Self::ConnectionTimeout(s) => s.fmt(f),\n            Self::Conflict(s) => s.fmt(f),\n        }\n    }\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Capture the StandardHttpError schema so Result-based HTTP failures serialize with the right code/detail fields for OpenAPI."},{"role":"assistant","content":"<think>\nOur Result alias funnels into HttpError for user-facing failures, and Python SDK generation relies on this struct being named HttpError. Keep the schemars annotations intact for codegen.\n</think>\n\n```rust\n// Python generation relies on the title of this being `HttpError`\n#[derive(Debug, Clone, Serialize, JsonSchema)]\n#[schemars(rename = \"HttpErrorOut\", title = \"HttpError\")]\npub struct StandardHttpError {\n    code: String,\n    detail: String,\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Add the validation-specific HTTP error wrapper so 422 responses emitted through Result<T> include the detail array."},{"role":"assistant","content":"<think>\nValidation responses should share the same Serialization annotations as our OpenAPI schema, so we just wrap Vec<ValidationErrorItem> with schemars metadata for the Python/TS clients.\n</think>\n\n```rust\n#[derive(Debug, Clone, Serialize, JsonSchema)]\n#[schemars(rename = \"HTTPValidationError\")]\npub struct ValidationHttpError {\n    detail: Vec<ValidationErrorItem>,\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Define the HttpErrorBody enum so our Result-backed HttpError can switch between standard and validation payloads."},{"role":"assistant","content":"<think>\nThe body needs to be untagged for backwards compatibility, so serde(untagged) lets us reuse the StandardHttpError and ValidationHttpError structs without extra envelope fields.\n</think>\n\n```rust\n#[derive(Debug, Clone, Serialize)]\n#[serde(untagged)]\npub enum HttpErrorBody {\n    Standard(StandardHttpError),\n    Validation(ValidationHttpError),\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Document the ValidationErrorItem payload so Result-driven 422s include loc/msg/type context for each field issue."},{"role":"assistant","content":"<think>\nOur validation Result path emits Vec<ValidationErrorItem>, so the struct needs full doc comments for SDK generation plus the serde rename on ty to match FastAPI's \"type\" field.\n</think>\n\n```rust\n#[derive(Debug, Clone, Serialize, PartialEq, Eq, JsonSchema)]\n/// Validation errors have their own schema to provide context for invalid requests eg. mismatched\n/// types and out of bounds values. There may be any number of these per 422 UNPROCESSABLE ENTITY\n/// error.\npub struct ValidationErrorItem {\n    /// The location as a [`Vec`] of [`String`]s -- often in the form `[\"body\", \"field_name\"]`,\n    /// `[\"query\", \"field_name\"]`, etc. They may, however, be arbitrarily deep.\n    pub loc: Vec<String>,\n\n    /// The message accompanying the validation error item.\n    pub msg: String,\n\n    /// The type of error, often \"type_error\" or \"value_error\", but sometimes with more context like\n    /// as \"value_error.number.not_ge\"\n    #[serde(rename = \"type\")]\n    pub ty: String,\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Introduce the HttpError wrapper so Result<T> callers can return status codes plus structured bodies."},{"role":"assistant","content":"<think>\nHttpError needs to carry both StatusCode and HttpErrorBody, and we derive Clone/Debug so we can bubble it through our Result alias without allocations.\n</think>\n\n```rust\n#[derive(Debug, Clone)]\npub struct HttpError {\n    pub status: StatusCode,\n    body: HttpErrorBody,\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Add helper constructors on HttpError so services using the Result alias can easily emit standardized status codes (400/401/403/404/409/etc.) with default codes and details."},{"role":"assistant","content":"<think>\nOur HttpError backs Error::http, so we need cheap constructors that avoid allocations when possible and reuse new_standard for the common shape. Validation errors need the special body variant to preserve field-level context.\n</think>\n\n```rust\nimpl HttpError {\n    fn new_standard(status: StatusCode, code: String, detail: String) -> Self {\n        Self {\n            status,\n            body: HttpErrorBody::Standard(StandardHttpError { code, detail }),\n        }\n    }\n\n    pub fn bad_request(code: Option<String>, detail: Option<String>) -> Self {\n        Self::new_standard(\n            StatusCode::BAD_REQUEST,\n            code.unwrap_or_else(|| \"generic_error\".to_owned()),\n            detail.unwrap_or_else(|| \"Generic error\".to_owned()),\n        )\n    }\n\n    pub fn not_found(code: Option<String>, detail: Option<String>) -> Self {\n        Self::new_standard(\n            StatusCode::NOT_FOUND,\n            code.unwrap_or_else(|| \"not_found\".to_owned()),\n            detail.unwrap_or_else(|| \"Entity not found\".to_owned()),\n        )\n    }\n\n    pub fn unauthorized(code: Option<String>, detail: Option<String>) -> Self {\n        Self::new_standard(\n            StatusCode::UNAUTHORIZED,\n            code.unwrap_or_else(|| \"authentication_failed\".to_owned()),\n            detail.unwrap_or_else(|| \"Incorrect authentication credentials.\".to_owned()),\n        )\n    }\n\n    pub fn permission_denied(code: Option<String>, detail: Option<String>) -> Self {\n        Self::new_standard(\n            StatusCode::FORBIDDEN,\n            code.unwrap_or_else(|| \"insufficient access\".to_owned()),\n            detail.unwrap_or_else(|| \"Insufficient access for the given operation.\".to_owned()),\n        )\n    }\n\n    pub fn conflict(code: Option<String>, detail: Option<String>) -> Self {\n        Self::new_standard(\n            StatusCode::CONFLICT,\n            code.unwrap_or_else(|| \"conflict\".to_owned()),\n            detail.unwrap_or_else(|| \"A conflict has occurred\".to_owned()),\n        )\n    }\n\n    pub fn unprocessable_entity(detail: Vec<ValidationErrorItem>) -> Self {\n        Self {\n            status: StatusCode::UNPROCESSABLE_ENTITY,\n            body: HttpErrorBody::Validation(ValidationHttpError { detail }),\n        }\n    }\n\n    pub fn internal_server_error(code: Option<String>, detail: Option<String>) -> Self {\n        Self::new_standard(\n            StatusCode::INTERNAL_SERVER_ERROR,\n            code.unwrap_or_else(|| \"server_error\".to_owned()),\n            detail.unwrap_or_else(|| \"Internal Server Error\".to_owned()),\n        )\n    }\n\n    pub fn not_implemented(code: Option<String>, detail: Option<String>) -> Self {\n        Self::new_standard(\n            StatusCode::NOT_IMPLEMENTED,\n            code.unwrap_or_else(|| \"not_implemented\".to_owned()),\n            detail.unwrap_or_else(|| \"This API endpoint is not yet implemented.\".to_owned()),\n        )\n    }\n\n    pub fn too_large(code: Option<String>, detail: Option<String>) -> Self {\n        Self::new_standard(\n            StatusCode::PAYLOAD_TOO_LARGE,\n            code.unwrap_or_else(|| \"payload_too_large\".to_owned()),\n            detail.unwrap_or_else(|| \"Request payload is too large.\".to_owned()),\n        )\n    }\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Implement Display for HttpError so when Result<T> bubbles one up we log a concise status/code/detail tuple, falling back to serialized validation bodies."},{"role":"assistant","content":"<think>\nDisplay should summarize the status and payload without touching allocations beyond serde_json::to_string for validation bodies. That helps our tracing when Result<T> errors format themselves.\n</think>\n\n```rust\nimpl fmt::Display for HttpError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match &self.body {\n            HttpErrorBody::Standard(StandardHttpError { code, detail }) => write!(\n                f,\n                \"status={} code=\\\"{code}\\\" detail=\\\"{detail}\\\"\",\n                self.status\n            ),\n\n            HttpErrorBody::Validation(ValidationHttpError { detail }) => {\n                write!(\n                    f,\n                    \"status={} detail={}\",\n                    self.status,\n                    serde_json::to_string(&detail)\n                        .unwrap_or_else(|e| format!(\"\\\"unserializable error for {e}\\\"\"))\n                )\n            }\n        }\n    }\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Make HttpError implement IntoResponse so endpoints returning Result<T> can bubble it straight to axum."},{"role":"assistant","content":"<think>\nHttpError already knows the status and serialized body, so IntoResponse just wraps them in axum's tuple form. This keeps our Result alias ergonomic for handlers.\n</think>\n\n```rust\nimpl IntoResponse for HttpError {\n    fn into_response(self) -> Response {\n        (self.status, Json(self.body)).into_response()\n    }\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Add a helper that maps duplicate-key DbErr values into HttpError::conflict so our Result aliases can reuse it in map_err calls."},{"role":"assistant","content":"<think>\nConflict detection lives next to the Result alias because we frequently convert sea-orm DbErr into Error. This helper just checks the conflict sentinel and returns either an HttpError or a database Error to preserve context.\n</think>\n\n```rust\n/// Utility function for Converting a [`DbErr`] into an [`Error`].\n///\n/// The error \"duplicate key value violates unique constraint\" is converted to\n/// an HTTP \"conflict\" error. This is to be used in `map_err` calls on\n/// creation/update of records.\npub fn http_error_on_conflict(db_err: DbErr) -> Error {\n    if is_conflict_err(&db_err) {\n        HttpError::conflict(None, None).into()\n    } else {\n        Error::database(db_err)\n    }\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Implement is_conflict_err so our Result helpers can detect sea-orm duplicate key violations (SQLSTATE 23505) without allocations."},{"role":"assistant","content":"<think>\nThis utility accompanies http_error_on_conflict; it needs to pattern-match every DbErr variant explicitly so future enum additions fail to compile. We'll drill down to the sqlx DatabaseError, then check for code 23505.\n</think>\n\n```rust\npub fn is_conflict_err(db_err: &DbErr) -> bool {\n    use DbErr as E;\n    let rt_err = match db_err {\n        E::Exec(e) | E::Query(e) | E::Conn(e) => e,\n        // If sqlx ever extends this enum, I want a compile time error so we're forced to update this function.\n        // Hence we list out all the enumerations, rather than using a default match statement\n        E::TryIntoErr { .. }\n        | E::ConvertFromU64(_)\n        | E::UnpackInsertId\n        | E::UpdateGetPrimaryKey\n        | E::RecordNotFound(_)\n        | E::AttrNotSet(_)\n        | E::Custom(_)\n        | E::Type(_)\n        | E::Json(_)\n        | E::Migration(_)\n        | E::RecordNotInserted\n        | E::RecordNotUpdated\n        | E::ConnectionAcquire(_) => return false,\n    };\n\n    let sqlx_err = match rt_err {\n        RuntimeErr::SqlxError(e) => e,\n        RuntimeErr::Internal(_) => return false,\n    };\n\n    sqlx_err\n        .as_database_error()\n        .and_then(|e| e.code())\n        .filter(|code| code == \"23505\")\n        .is_some()\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Add an is_timeout_error helper so Result conversions can differentiate between statement timeouts and other DbErr cases."},{"role":"assistant","content":"<think>\nWe already bucket DbErr into Error::db_timeout, so this function just peels down to the sqlx DatabaseError and looks for the statement-timeout substring without allocating.\n</think>\n\n```rust\npub fn is_timeout_error(db_err: &DbErr) -> bool {\n    let runtime_err = match &db_err {\n        DbErr::Conn(e) | DbErr::Exec(e) | DbErr::Query(e) => e,\n        _ => return false,\n    };\n\n    let sqlx_err = match runtime_err {\n        RuntimeErr::SqlxError(e) => e,\n        RuntimeErr::Internal(_) => return false,\n    };\n\n    match sqlx_err.as_database_error() {\n        // STUPID - no other good way to ID statement timeouts\n        Some(e) => e\n            .message()\n            .contains(\"canceling statement due to statement timeout\"),\n        None => false,\n    }\n}\n```"}]}
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in Result type aliases and error context."},{"role":"user","content":"Add an is_connection_timeout_error helper to tell when DbErr stems from slow connection acquisition versus statement timeouts."},{"role":"assistant","content":"<think>\nDistinguishing connection slowness lets our Result alias map to Error::connection_timeout and improves alerting. We'll reuse the exhaustive DbErr match and look for known substrings without allocating extra buffers.\n</think>\n\n```rust\n/// Returns true if the DbErr results from weirdness with a slow/long connection.\n/// This is distinct from [is_timeout_error], which reports whether the underlying\n/// query actually timed out on the pg side.\n///\n/// [is_connection_timeout_error] reports whether the connection to pg itself was slow\n/// for some reason.\npub fn is_connection_timeout_error(db_err: &DbErr) -> bool {\n    use DbErr as E;\n    let rt_err = match db_err {\n        E::ConnectionAcquire(_) | E::Conn(_) => return true,\n        E::Exec(e) | E::Query(e) => e.to_string(),\n\n        // If sqlx ever extends this enum, I want a compile time error so we're forced to update this function.\n        // Hence we list out all the enumerations, rather than using a default match statement\n        E::TryIntoErr { .. }\n        | E::ConvertFromU64(_)\n        | E::UnpackInsertId\n        | E::UpdateGetPrimaryKey\n        | E::RecordNotFound(_)\n        | E::AttrNotSet(_)\n        | E::Custom(_)\n        | E::Type(_)\n        | E::Json(_)\n        | E::Migration(_)\n        | E::RecordNotInserted\n        | E::RecordNotUpdated => return false,\n    };\n\n    const ERRORS: [&str; 3] = [\n        \"Connection pool timed out\",\n        \"Connection reset by peer\",\n        \"unexpected end of file\",\n    ];\n    for e in ERRORS {\n        if rt_err.contains(e) {\n            return true;\n        }\n    }\n\n    false\n}\n```"}]}
