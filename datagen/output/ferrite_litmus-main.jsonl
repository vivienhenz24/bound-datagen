{"messages":[{"role":"system","content":"You are the Ferrite Rosette Litmus Engineer, expert in consistency testing and litmus design."},{"role":"user","content":"Can you capture Chrome's double-append workload: sync a long initial write, then issue two additional writes without extra fsyncs so we can compare SeqFS against Ext4 with and without delayed allocation and assert only prefix states reach disk?"},{"role":"assistant","content":"<think>\nSetup builds fd 0, fills it with the first chunk, and fsyncs so disk holds the baseline. The test runs two more writes without intervening syncs; only program order is fixed while the device may persist any prefix before a crash. The allow clause forces ondisk file 0 to be a prefix of an all-#t stream, so any interleaving that exposes garbage in the middle is forbidden. I instantiate this litmus with seq-fs, ext4, and ext4-nodelalloc constructors and send it to verify-correctness/synth to flag the implementations that violate the constraint.\n</think>\n\n```racket\n(define small? #f)\n(define writes (if small? '(33 2 31) '(2509 13 2500)))\n(define block-size (if small? 64 4096))\n\n(define chrome-setup \n  (list\n   (creat 0)  ; fd 0\n   (write 0 (for/list ([i (first writes)]) #t))\n   (fsync 0)))\n\n(define chrome-test\n  (list\n   (write 0 (for/list ([i (second writes)]) #t))\n   (write 0 (for/list ([i (third writes)]) #t))))\n\n(define (chrome-allow oldfs newfs)\n  ; file must be a prefix of #ts\n  (define new-0 (ondisk newfs 0))\n  (list (apply && new-0)))\n\n(define (chrome-fs-seqfs)\n  (seq-fs 2))\n\n(define (chrome-fs-ext4)\n  (ext4-fs #:capacity 2 #:blocksize block-size))\n(define (chrome-fs-ext4-nodelalloc)\n  (ext4-fs #:capacity 2 #:blocksize block-size #:nodelalloc? #t))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Litmus Engineer, expert in consistency testing and litmus design."},{"role":"user","content":"I need a litmus that shows create+write+rename is unsafe without fsync: model the incorrect trace and a corrected variant so we can run SeqFS, AdvFS, and Ext4 through verify-correctness."},{"role":"assistant","content":"<think>\nThere is no setup, so the filesystem starts empty. The incorrect body creates fd 0, writes two blocks, and renames it to name 1 without syncing; metadata can reach disk before data, leaving name 1 present but empty. Allowed states only permit name 1 being absent or containing '(#t #t), so ext4/advfs reorderings violate it. Inserting fsync 0 before rename yields the corrected trace. I instantiate seq-fs/adv-fs/ext4 constructors and run verify-correctness or synth to confirm which implementations require the barrier.\n</think>\n\n```racket\n(define small? #f)\n(define block-size (if small? 64 4096))\n\n(define create-rename-setup '())\n\n(define create-rename-test-incorrect\n  (list\n   (creat 0)\n   (write 0 '(#t #t))\n   ; (fsync 0)\n   (rename 0 1)))\n\n(define create-rename-test-correct\n  (list\n   (creat 0)\n   (write 0 '(#t #t))\n   (fsync 0)\n   (rename 0 1)))\n\n(define (create-rename-allow oldfs newfs)\n  (define new-1 (ondisk newfs 1))\n  (list (equal? new-1 #f)\n        (equal? new-1 '(#t #t))))\n(define (create-rename-fs-seqfs)\n  (seq-fs 2))\n\n(define (create-rename-fs-advfs)\n  (adv-fs 2))\n\n(define (create-rename-fs-ext4)\n  (ext4-fs #:capacity 2 #:blocksize block-size))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Litmus Engineer, expert in consistency testing and litmus design."},{"role":"user","content":"Can you capture the replace-via-temp rename pattern: start with a synced file, create a temporary replacement, and show why skipping fsync before rename risks leaving stale data on AdvFS compared to SeqFS?"},{"role":"assistant","content":"<think>\nSetup creates file 0, writes a single block, and fsyncs so the old contents are durable. The incorrect body allocates descriptor 1, writes the longer payload, skips fsync, and renames 1 over 0; a crash after the rename can expose name 0 while its data still reflects the old '(#t) prefix. Allowed states only accept ondisk slot 0 being '(#t) or '(#t #t). Adding fsync 0 before rename produces the correct sequence. I run the litmus with seq-fs and adv-fs constructors and call verify-correctness to surface the buggy ordering.\n</think>\n\n```racket\n(define replace-setup\n  (list (creat 0)  ; fd 0\n        (write 0 '(#t))\n        (fsync 0)))\n\n(define replace-test-incorrect\n  (list (creat 1)  ; fd 0\n        (write 0 '(#t #t))\n        ; (fsync 0)\n        (rename 1 0)))\n(define replace-test-correct\n  (list (creat 1)  ; fd 0\n        (write 0 '(#t #t))\n        (fsync 0)\n        (rename 1 0)))\n\n(define (replace-allow oldfs newfs)\n  (define new-0 (ondisk newfs 0))\n  (list (equal? new-0 '(#t))\n        (equal? new-0 '(#t #t))))\n(define (replace-fs-seqfs)\n  (seq-fs 2))\n\n(define (replace-fs-advfs)\n  (adv-fs 2))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Litmus Engineer, expert in consistency testing and litmus design."},{"role":"user","content":"I want a two-appends litmus: sequentially append to file 0 and file 1, but only fsync the second file, so we can show AdvFS needs an extra fsync on the first append while SeqFS already enforces the prefix outcomes."},{"role":"assistant","content":"<think>\nThe setup is empty. The incorrect trace creates descriptors 0 and 1, writes two blocks to fd 0, then appends fd 1 and only fsyncs fd 1; persistence is only ordered by crashes, so fd 1's fsync may commit while fd 0's buffered data is lost. Allowed outcomes enumerate every prefix combination for files 0 and 1 so crashes can only drop suffixes, not reorder the contents. Inserting fsync 0 before touching file 1 yields the correct body. I instantiate seq-fs and adv-fs builders and run verify-correctness to demonstrate AdvFS violates the allowed set without the extra sync.\n</think>\n\n```racket\n(define two-appends-setup '())\n\n(define two-appends-test-incorrect\n  (list\n   (creat 0)\n   (creat 1)\n   (write 0 '(#t #t))\n   ; (fsync 0)\n   (write 1 '(#t))\n   (fsync 1)))\n\n(define two-appends-test-correct\n  (list\n   (creat 0)\n   (creat 1)\n   (write 0 '(#t #t))\n   (fsync 0)\n   (write 1 '(#t))\n   (fsync 1)))\n\n(define (two-appends-allow oldfs newfs)\n  (define new-0 (ondisk newfs 0))\n  (define new-1 (ondisk newfs 1))\n  (list (and (equal? new-0 #f)  (equal? new-1 #f))\n        (and (equal? new-0 '()) (equal? new-1 #f))\n        (and (equal? new-0 '()) (equal? new-1 '()))\n        (and (equal? new-0 '(#t #t)) (equal? new-1 '()))\n        (and (equal? new-0 '(#t #t)) (equal? new-1 '(#t)))))\n(define (two-appends-fs-seqfs)\n  (seq-fs 2))\n\n(define (two-appends-fs-advfs)\n  (adv-fs 2))\n```\n"}]}
