{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Please show me the Rosette scaffolding for the ARM32 CPU state (NZCV flags, cpu struct, register helpers, condition predicate)."},{"role":"assistant","content":"<think>\nInstruction group: ARM32 core state & conditional execution scaffolding from base.rkt. Decoder style: structural definitions establishing symbolic pc/register file and flag logic. Symbolic regs/flags/memory: cpu struct carries symbolic pc, 15 GPR boxes, cpsr nzcv bits, memmgr reference. Constraints and solver queries: r15 reads as pc+8, writes happen via cpu-pc-set!, condition-holds compares nzcv bits to guard instructions.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  (prefix-in core: \"../lib/core.rkt\"))\n\n(struct pstate (n z c v) #:mutable #:transparent)\n\n(define (pstate.nzcv-set! pstate nzcv)\n  (set-pstate-n! pstate (first nzcv))\n  (set-pstate-z! pstate (second nzcv))\n  (set-pstate-c! pstate (third nzcv))\n  (set-pstate-v! pstate (fourth nzcv)))\n\n(define (integer->gpr n)\n  (box (bv n 4)))\n\n(struct cpu (pc rs cpsr memmgr) #:mutable #:transparent\n  #:methods core:gen:gen-cpu\n  [(define (gen-cpu-memmgr cpu) (cpu-memmgr cpu))\n   (define (gen-cpu-pc cpu) (cpu-pc cpu))])\n\n(define (cpu-gpr-ref cpu k)\n  (define rs (cpu-rs cpu))\n  (define lst\n    (cons (cons (integer->gpr 15) (bvadd (cpu-pc cpu) (bv 8 32)))\n          (map (lambda (x) (cons (integer->gpr x) (vector-ref rs x))) (range 15))))\n  (cdr (assoc k lst)))\n\n(define (cpu-gpr-set! cpu k v)\n  (define rs (cpu-rs cpu))\n  (define lst\n    (map (lambda (x) (cons (integer->gpr x) (lambda () (vector-set! rs x v)))) (range 15)))\n  (define proc (cdr (assoc k lst)))\n  (proc))\n\n(define (cpu-pstate.n cpu) (pstate-n (cpu-cpsr cpu)))\n(define (cpu-pstate.z cpu) (pstate-z (cpu-cpsr cpu)))\n(define (cpu-pstate.c cpu) (pstate-c (cpu-cpsr cpu)))\n(define (cpu-pstate.v cpu) (pstate-v (cpu-cpsr cpu)))\n\n(define (condition-holds cpu cc)\n  (define cond<3:1> (extract 3 1 cc))\n  (define result\n    (cond\n      [(bveq cond<3:1> (bv #b000 3)) (bveq (cpu-pstate.z cpu) (bv #b1 1))]\n      [(bveq cond<3:1> (bv #b001 3)) (bveq (cpu-pstate.c cpu) (bv #b1 1))]\n      [(bveq cond<3:1> (bv #b010 3)) (bveq (cpu-pstate.n cpu) (bv #b1 1))]\n      [(bveq cond<3:1> (bv #b011 3)) (bveq (cpu-pstate.v cpu) (bv #b1 1))]\n      [(bveq cond<3:1> (bv #b100 3)) (&& (bveq (cpu-pstate.c cpu) (bv #b1 1)) (bveq (cpu-pstate.z cpu) (bv #b0 1)))]\n      [(bveq cond<3:1> (bv #b101 3)) (bveq (cpu-pstate.n cpu) (cpu-pstate.v cpu))]\n      [(bveq cond<3:1> (bv #b110 3)) (&& (bveq (cpu-pstate.n cpu) (cpu-pstate.v cpu)) (bveq (cpu-pstate.z cpu) (bv #b0 1)))]\n      [(bveq cond<3:1> (bv #b111 3)) #t]))\n  (if (&& (bveq (bit 0 cc) (bv #b1 1)) (! (bveq cc (bv #b1111 4))))\n      (! result)\n      result))\n```\n"}]} 
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"I want the Rosette semantics for ARMv7 STR/LDR and STRB/LDRB immediate forms, including decode, unpredictable cases, and memory effects."},{"role":"assistant","content":"<think>\nInstruction group: load/store word and unsigned byte with immediate offset from load-store-word-unsigned-byte-immediate.rkt. Decoder style: P/U/W bits plus imm12 form index/add/sub and write-back behavior. Symbolic regs/flags/memory: cpu-gpr-ref/set! on registers (with r15 treated specially), memmgr load/store for 32-bit and 8-bit transfers, pc-store-value/load-write-pc for PC aliasing. Constraints and solver queries: guard unpredictable combinations (literal base, write-back hazards) and encode address arithmetic for solver via bvadd/bvsub on symbolic addresses.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  str-immediate strb-immediate\n  ldr-immediate ldrb-immediate)\n\n\n(define (decode-str P U W Rn Rt imm12)\n  (when (&& (bveq P (bv #b0 1)) (bveq W (bv #b1 1)))\n    (see \"STRT\"))\n  (define t Rt)\n  (define n Rn)\n  (define imm32 (zero-extend imm12 (bitvector 32)))\n  (define index (bveq P (bv #b1 1)))\n  (define add (bveq U (bv #b1 1)))\n  (define wback (|| (bveq P (bv #b0 1)) (bveq W (bv #b1 1))))\n  (when (&& wback (|| (r15? n) (equal? n t)))\n    (unpredictable))\n  (values t n imm32 index add wback))\n\n(define (interpret-str cpu P U W Rn Rt imm12)\n  (define-values (t n imm32 index add wback) (decode-str P U W Rn Rt imm12))\n  (define offset_addr ((if add bvadd bvsub) (cpu-gpr-ref cpu n) imm32))\n  (define address (if index offset_addr (cpu-gpr-ref cpu n)))\n  (define data (if (r15? t) (pc-store-value cpu) (cpu-gpr-ref cpu t)))\n  (core:memmgr-store! (cpu-memmgr cpu) address (bv 0 32) data (bv 4 32))\n  (when wback\n    (cpu-gpr-set! cpu n offset_addr)))\n\n\n(define (decode-strb P U W Rn Rt imm12)\n  (when (&& (bveq P (bv #b0 1)) (bveq W (bv #b1 1)))\n    (see \"STRBT\"))\n  (define t Rt)\n  (define n Rn)\n  (define imm32 (zero-extend imm12 (bitvector 32)))\n  (define index (bveq P (bv #b1 1)))\n  (define add (bveq U (bv #b1 1)))\n  (define wback (|| (bveq P (bv #b0 1)) (bveq W (bv #b1 1))))\n  (when (r15? t)\n    (unpredictable))\n  (when (&& wback (|| (r15? n) (equal? n t)))\n    (unpredictable))\n  (values t n imm32 index add wback))\n\n(define (interpret-strb cpu P U W Rn Rt imm12)\n  (define-values (t n imm32 index add wback) (decode-strb P U W Rn Rt imm12))\n  (define offset_addr ((if add bvadd bvsub) (cpu-gpr-ref cpu n) imm32))\n  (define address (if index offset_addr (cpu-gpr-ref cpu n)))\n  (define data (extract 7 0 (cpu-gpr-ref cpu t)))\n  (core:memmgr-store! (cpu-memmgr cpu) address (bv 0 32) data (bv 1 32))\n  (when wback\n    (cpu-gpr-set! cpu n offset_addr)))\n\n\n(define (decode-ldr P U W Rn Rt imm12)\n  (when (equal? Rn (integer->gpr #b1111))\n    (see \"LDR (literal)\"))\n  (when (&& (bveq P (bv #b0 1)) (bveq W (bv #b1 1)))\n    (see \"LDRT\"))\n  (define t Rt)\n  (define n Rn)\n  (define imm32 (zero-extend imm12 (bitvector 32)))\n  (define index (bveq P (bv #b1 1)))\n  (define add (bveq U (bv #b1 1)))\n  (define wback (|| (bveq P (bv #b0 1)) (bveq W (bv #b1 1))))\n  (when (&& wback (equal? n t))\n    (unpredictable))\n  (values t n imm32 index add wback))\n\n(define (interpret-ldr cpu P U W Rn Rt imm12)\n  (define-values (t n imm32 index add wback) (decode-ldr P U W Rn Rt imm12))\n  (define offset_addr ((if add bvadd bvsub) (cpu-gpr-ref cpu n) imm32))\n  (define address (if index offset_addr (cpu-gpr-ref cpu n)))\n  (define data (core:memmgr-load (cpu-memmgr cpu) address (bv 0 32) (bv 4 32)))\n  (when wback\n    (cpu-gpr-set! cpu n offset_addr))\n  (if (r15? t)\n      (if (bveq (extract 2 0 address) (bv #b00 2))\n          (load-write-pc cpu data)\n          (unpredictable))\n      (cpu-gpr-set! cpu t data)))\n\n\n(define (decode-ldrb P U W Rn Rt imm12)\n  (when (equal? Rn (integer->gpr #b1111))\n    (see \"LDRB (literal)\"))\n  (when (&& (bveq P (bv #b0 1)) (bveq W (bv #b1 1)))\n    (see \"LDRBT\"))\n  (define t Rt)\n  (define n Rn)\n  (define imm32 (zero-extend imm12 (bitvector 32)))\n  (define index (bveq P (bv #b1 1)))\n  (define add (bveq U (bv #b1 1)))\n  (define wback (|| (bveq P (bv #b0 1)) (bveq W (bv #b1 1))))\n  (when (|| (r15? t) (&& wback (equal? n t)))\n    (unpredictable))\n  (values t n imm32 index add wback))\n\n(define (interpret-ldrb cpu P U W Rn Rt imm12)\n  (define-values (t n imm32 index add wback) (decode-ldrb P U W Rn Rt imm12))\n  (define offset_addr ((if add bvadd bvsub) (cpu-gpr-ref cpu n) imm32))\n  (define address (if index offset_addr (cpu-gpr-ref cpu n)))\n  (define data (core:memmgr-load (cpu-memmgr cpu) address (bv 0 32) (bv 1 32)))\n  (cpu-gpr-set! cpu t (zero-extend data (bitvector 32)))\n  (when wback\n    (cpu-gpr-set! cpu n offset_addr)))\n\n\n(define-insn (P U W Rn Rt imm12)\n  #:encode (lambda (o2 o1) (list (bv #b010 3) P U (bv o2 1) W (bv o1 1) Rn Rt imm12))\n  [(#b0 #b0) str-immediate  interpret-str]\n  [(#b1 #b0) strb-immediate interpret-strb]\n  [(#b0 #b1) ldr-immediate  interpret-ldr]\n  [(#b1 #b1) ldrb-immediate interpret-ldrb])\n```\n"}]} 
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Provide the Rosette semantics for ARMv7 LDRD/LDRH and STRD/STRH immediate addressing, including paired-register checks and write-back rules."},{"role":"assistant","content":"<think>\nInstruction group: load/store dual word and halfword immediates from load-store-dual-half-signed-byte-immediate.rkt. Decoder style: P/U/W bits plus split imm4H/imm4L form zero-extended offsets with index/add flags, while register pair relations are validated. Symbolic regs/flags/memory: cpu-gpr-ref/set! handles Rt, Rt+1, and Rn, memmgr dual loads/stores for consecutive words and 16-bit accesses. Constraints and solver queries: unpredictable guards enforce literal-base bans, Rt pairing, wback hazards, and PC usage; solver tracks address arithmetic via bvadd/bvsub.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  ldrd-immediate ldrh-immediate\n  strd-immediate strh-immediate)\n\n\n(define (decode-ldrd P U W Rn Rt imm4H imm4L)\n  (when (equal? Rn (integer->gpr #b1111))\n    (see \"LDRD (literal)\"))\n  (when (bveq (bit 0 (unbox Rt)) (bv #b1 1))\n    (unpredictable))\n  (define t Rt)\n  (define t2 (box (bvadd1 (unbox t))))\n  (define n Rn)\n  (define imm32 (zero-extend (concat imm4H imm4L) (bitvector 32)))\n  (define index (bveq P (bv #b1 1)))\n  (define add (bveq U (bv #b1 1)))\n  (define wback (|| (bveq P (bv #b0 1)) (bveq W (bv #b1 1))))\n  (when (&& wback (|| (equal? n t) (equal? n t2)))\n    (unpredictable))\n  (when (r15? t2)\n    (unpredictable))\n  (values t t2 n imm32 index add wback))\n\n(define (interpret-ldrd cpu P U W Rn Rt imm4H imm4L)\n  (define-values (t t2 n imm32 index add wback) (decode-ldrd P U W Rn Rt imm4H imm4L))\n  (define offset_addr ((if add bvadd bvsub) (cpu-gpr-ref cpu n) imm32))\n  (define address (if index offset_addr (cpu-gpr-ref cpu n)))\n  (define mm (cpu-memmgr cpu))\n  (define pc (cpu-pc cpu))\n  (cpu-gpr-set! cpu t (core:memmgr-load mm address (bv 0 32) (bv 4 32)))\n  (cpu-gpr-set! cpu t2 (core:memmgr-load mm address (bv 4 32) (bv 4 32)))\n  (when wback\n    (cpu-gpr-set! cpu n offset_addr)))\n\n\n(define (decode-ldrh P U W Rn Rt imm4H imm4L)\n  (when (equal? Rn (integer->gpr #b1111))\n    (see \"LDRH (literal)\"))\n  (when (&& (bveq P (bv #b0 1)) (bveq W (bv #b1 1)))\n    (see \"LDRHT\"))\n  (define t Rt)\n  (define n Rn)\n  (define imm32 (zero-extend (concat imm4H imm4L) (bitvector 32)))\n  (define index (bveq P (bv #b1 1)))\n  (define add (bveq U (bv #b1 1)))\n  (define wback (|| (bveq P (bv #b0 1)) (bveq W (bv #b1 1))))\n  (when (|| (r15? t) (&& wback (equal? n t)))\n    (unpredictable))\n  (values t n imm32 index add wback))\n\n(define (interpret-ldrh cpu P U W Rn Rt imm4H imm4L)\n  (define-values (t n imm32 index add wback) (decode-ldrh P U W Rn Rt imm4H imm4L))\n  (define offset_addr ((if add bvadd bvsub) (cpu-gpr-ref cpu n) imm32))\n  (define address (if index offset_addr (cpu-gpr-ref cpu n)))\n  (define data (core:memmgr-load (cpu-memmgr cpu) address (bv 0 32) (bv 2 32)))\n  (when wback\n    (cpu-gpr-set! cpu n offset_addr))\n  (cpu-gpr-set! cpu t (zero-extend data (bitvector 32))))\n\n\n(define (decode-strd P U W Rn Rt imm4H imm4L)\n  (when (bveq (bit 0 (unbox Rt)) (bv #b1 1))\n    (unpredictable))\n  (define t Rt)\n  (define t2 (box (bvadd1 (unbox t))))\n  (define n Rn)\n  (define imm32 (zero-extend (concat imm4H imm4L) (bitvector 32)))\n  (define index (bveq P (bv #b1 1)))\n  (define add (bveq U (bv #b1 1)))\n  (define wback (|| (bveq P (bv #b0 1)) (bveq W (bv #b1 1))))\n  (when (&& wback (|| (r15? n) (equal? n t) (equal? n t2)))\n    (unpredictable))\n  (when (r15? t2)\n    (unpredictable))\n  (values t t2 n imm32 index add wback))\n\n(define (interpret-strd cpu P U W Rn Rt imm4H imm4L)\n  (define-values (t t2 n imm32 index add wback) (decode-strd P U W Rn Rt imm4H imm4L))\n  (define offset_addr ((if add bvadd bvsub) (cpu-gpr-ref cpu n) imm32))\n  (define address (if index offset_addr (cpu-gpr-ref cpu n)))\n  (define mm (cpu-memmgr cpu))\n  (define pc (cpu-pc cpu))\n  (core:memmgr-store! mm address (bv 0 32) (cpu-gpr-ref cpu t) (bv 4 32))\n  (core:memmgr-store! mm address (bv 4 32) (cpu-gpr-ref cpu t2) (bv 4 32))\n  (when wback\n    (cpu-gpr-set! cpu n offset_addr)))\n\n\n(define (decode-strh P U W Rn Rt imm4H imm4L)\n  (when (&& (bveq P (bv #b0 1)) (bveq W (bv #b1 1)))\n    (see \"STRHT\"))\n  (define t Rt)\n  (define n Rn)\n  (define imm32 (zero-extend (concat imm4H imm4L) (bitvector 32)))\n  (define index (bveq P (bv #b1 1)))\n  (define add (bveq U (bv #b1 1)))\n  (define wback (|| (bveq P (bv #b0 1)) (bveq W (bv #b1 1))))\n  (when (r15? t)\n    (unpredictable))\n  (when (&& wback (|| (r15? n) (equal? n t)))\n    (unpredictable))\n  (values t n imm32 index add wback))\n\n(define (interpret-strh cpu P U W Rn Rt imm4H imm4L)\n  (define-values (t n imm32 index add wback) (decode-strh P U W Rn Rt imm4H imm4L))\n  (define offset_addr ((if add bvadd bvsub) (cpu-gpr-ref cpu n) imm32))\n  (define address (if index offset_addr (cpu-gpr-ref cpu n)))\n  (define data (extract 15 0 (cpu-gpr-ref cpu t)))\n  (core:memmgr-store! (cpu-memmgr cpu) address (bv 0 32) data (bv 2 32))\n  (when wback\n    (cpu-gpr-set! cpu n offset_addr)))\n\n\n(define-insn (P U W Rn Rt imm4H imm4L)\n  #:encode (lambda (o1 op2) (list (bv #b000 3) P U (bv #b1 1) W (bv o1 1) Rn Rt imm4H (bv #b1 1) (bv op2 2) (bv #b1 1) imm4L))\n  [(#b0 #b10) ldrd-immediate interpret-ldrd]\n  [(#b1 #b01) ldrh-immediate interpret-ldrh]\n  [(#b0 #b11) strd-immediate interpret-strd]\n  [(#b0 #b01) strh-immediate interpret-strh])\n```\n"}]} 
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Show me the Rosette semantics for ARM STMDB/LDMIA load-store-multiple instructions, including register-list loops and write-back edge cases."},{"role":"assistant","content":"<think>\nInstruction group: load/store multiple decrement-before and increment-after forms from load-store-multiple.rkt. Decoder style: W bit plus register_list bitmap determine write-back and iteration order. Symbolic regs/flags/memory: cpu-gpr-ref/set! drive per-register transfers, memmgr handles 32-bit stores/loads, pc-store-value/load-write-pc support r15 entries. Constraints and solver queries: unpredictable checks on empty lists, base touching PC, and overlap with write-back, while address arithmetic accumulates symbolic offsets via bit-count derived scaling.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  stmdb\n  ldmia)\n\n(define (decode-stmdb W Rn register_list)\n  (define n Rn)\n  (define registers register_list)\n  (define wback (equal? W (bv 1 1)))\n  (when (|| (r15? n) (bvzero? (bit-count registers)))\n    (unpredictable))\n  (values n registers wback))\n\n(define (interpret-stmdb cpu W Rn register_list)\n  (define mm (cpu-memmgr cpu))\n\n  (define-values (n registers wback) (decode-stmdb W Rn register_list))\n\n  (define address (bvsub (cpu-gpr-ref cpu Rn)\n                         (bvmul (bv 4 32)\n                                (zero-extend (bit-count registers) (bitvector 32)))))\n\n  (for ([i (in-range 15)])\n    (when (equal? (bit i registers) (bv 1 1))\n      (if (&& (equal? (integer->gpr i) n) wback (! (equal? (bv i (type-of registers)) (lowest-set-bit registers))))\n          (unpredictable)\n          (core:memmgr-store! mm address (bv 0 32) (cpu-gpr-ref cpu (integer->gpr i)) (bv 4 32)))\n\n      (set! address (bvadd address (bv 4 (type-of address))))))\n\n  (when (equal? (bit 15 registers) (bv 1 1))\n    (core:memmgr-store! mm address (bv 0 32) (pc-store-value cpu) (bv 4 32)))\n\n  (when wback\n    (cpu-gpr-set! cpu Rn\n                  (bvsub (cpu-gpr-ref cpu Rn)\n                         (bvmul (bv 4 32)\n                                (zero-extend (bit-count registers) (bitvector 32)))))))\n\n(define (decode-ldmia W Rn register_list)\n  (define n Rn)\n  (define registers register_list)\n  (define wback (equal? W (bv 1 1)))\n  (when (|| (r15? n) (bvzero? (bit-count registers)))\n    (unpredictable))\n  (values n registers wback))\n\n(define (interpret-ldmia cpu W Rn register_list)\n  (define mm (cpu-memmgr cpu))\n  (define-values (n registers wback) (decode-ldmia W Rn register_list))\n\n  (define address (cpu-gpr-ref cpu n))\n\n  (for ([i (in-range 15)])\n    (when (equal? (bit i registers) (bv 1 1))\n      (cpu-gpr-set! cpu (integer->gpr i)\n                    (core:memmgr-load mm address (bv 0 32) (bv 4 32)))\n      (set! address (bvadd address (bv 4 (type-of address))))))\n\n  (when (equal? (bit 15 registers) (bv 1 1))\n    (load-write-pc cpu (core:memmgr-load mm address (bv 0 32) (bv 4 32))))\n\n  (cond\n    [(&& wback (equal? (bit 13 registers) (bv 0 1)))\n      (cpu-gpr-set! cpu n\n        (bvadd (cpu-gpr-ref cpu n)\n               (bvmul (bv 4 32) (zero-extend (bit-count registers) (bitvector 32)))))]\n    [(&& wback (equal? (bit 13 registers) (bv 1 1)))\n      (define-symbolic* UNKNOWN (bitvector 32))\n      (cpu-gpr-set! cpu n UNKNOWN)]\n    [else (void)]))\n\n(define-insn (W Rn register_list)\n  #:encode (lambda (P U op L) (list (bv #b100 3) (bv P 1) (bv U 1) (bv op 1) W (bv L 1) Rn register_list))\n  [(#b1 #b0 #b0 #b0) stmdb interpret-stmdb]\n  [(#b0 #b1 #b0 #b1) ldmia interpret-ldmia])\n```\n"}]} 
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Give me the Rosette semantics for the ARM B (branch immediate) instruction with sign-extended offsets."},{"role":"assistant","content":"<think>\nInstruction group: branch immediate (B) from branch-immediate.rkt. Decoder style: imm24 concatenated with \"00\" and sign-extended to 32 bits, then PC-relative addition. Symbolic regs/flags/memory: branch-write-pc targets cpu-pc via r15 read (pc+8) plus imm32; mem not touched. Constraints and solver queries: only ensures correct PC update and direction flag 'DIR via literal symbol.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  b)\n\n\n(define (decode imm24)\n  (define imm32 (sign-extend (concat imm24 (bv #b00 2)) (bitvector 32)))\n  (values imm32))\n\n(define (interpret-b cpu imm24)\n  (define-values (imm32) (decode imm24))\n  (branch-write-pc cpu (bvadd (cpu-gpr-ref cpu (integer->gpr 15)) imm32) 'DIR))\n\n\n(define-insn (imm24)\n  #:encode (lambda (H) (list (bv #b101 3) (bv H 1) imm24))\n  [(#b0) b interpret-b])\n```\n"}]} 
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Share the Rosette semantics for the ARM extend-and-add instructions (SXT*/UXT* with optional rotate)."},{"role":"assistant","content":"<think>\nInstruction group: extend-and-add family (sxtb16/sxtb/sxth/uxtb16/uxtb/uxth) from extend-and-add.rkt. Decoder style: Rd/rotate/Rm operands with zero-extended rotate fields produce rotation amount; decode guards against PC usage. Symbolic regs/flags/memory: cpu-gpr-ref/set! used on registers, bvror for rotation, concat of sign/zero-extends for halfword packing. Constraints and solver queries: unpredictable when Rd or Rm is r15, rotation is encoded as rotate<<3.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  sxtb16 sxtb sxth\n  uxtb16 uxtb uxth)\n\n\n(define (decode Rd rotate Rm)\n  (define d Rd)\n  (define m Rm)\n  (define rotation (zero-extend (concat rotate (bv #b000 3)) (bitvector 32)))\n  (when (|| (r15? d) (r15? m))\n    (unpredictable))\n  (values d m rotation))\n\n(define (interpret-sxtb16 cpu Rd rotate Rm)\n  (define-values (d m rotation) (decode Rd rotate Rm))\n  (define rotated (bvror (cpu-gpr-ref cpu m) rotation))\n  (cpu-gpr-set! cpu d\n    (concat (sign-extend (extract 23 16 rotated) (bitvector 16))\n            (sign-extend (extract 7 0 rotated) (bitvector 16)))))\n\n(define (interpret-sxtb cpu Rd rotate Rm)\n  (define-values (d m rotation) (decode Rd rotate Rm))\n  (define rotated (bvror (cpu-gpr-ref cpu m) rotation))\n  (cpu-gpr-set! cpu d (sign-extend (extract 7 0 rotated) (bitvector 32))))\n\n(define (interpret-sxth cpu Rd rotate Rm)\n  (define-values (d m rotation) (decode Rd rotate Rm))\n  (define rotated (bvror (cpu-gpr-ref cpu m) rotation))\n  (cpu-gpr-set! cpu d (sign-extend (extract 15 0 rotated) (bitvector 32))))\n\n(define (interpret-uxtb16 cpu Rd rotate Rm)\n  (define-values (d m rotation) (decode Rd rotate Rm))\n  (define rotated (bvror (cpu-gpr-ref cpu m) rotation))\n  (cpu-gpr-set! cpu d\n    (concat (zero-extend (extract 23 16 rotated) (bitvector 16))\n            (zero-extend (extract 7 0 rotated) (bitvector 16)))))\n\n(define (interpret-uxtb cpu Rd rotate Rm)\n  (define-values (d m rotation) (decode Rd rotate Rm))\n  (define rotated (bvror (cpu-gpr-ref cpu m) rotation))\n  (cpu-gpr-set! cpu d (zero-extend (extract 7 0 rotated) (bitvector 32))))\n\n(define (interpret-uxth cpu Rd rotate Rm)\n  (define-values (d m rotation) (decode Rd rotate Rm))\n  (define rotated (bvror (cpu-gpr-ref cpu m) rotation))\n  (cpu-gpr-set! cpu d (zero-extend (extract 15 0 rotated) (bitvector 32))))\n\n(define-insn (Rd rotate Rm)\n  #:encode (lambda (U op) (list (bv #b01101 5) (bv U 1) (bv op 2) (bv #b1111 4) Rd rotate (bv #b00 2) (bv #b0111 4) Rm))\n  [(#b0 #b00) sxtb16 interpret-sxtb16]\n  [(#b0 #b10) sxtb   interpret-sxtb]\n  [(#b0 #b11) sxth   interpret-sxth]\n  [(#b1 #b00) uxtb16 interpret-uxtb16]\n  [(#b1 #b10) uxtb   interpret-uxtb]\n  [(#b1 #b11) uxth   interpret-uxth])\n```\n"}]} 
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"I need the Rosette semantics for the REV and REV16 byte/halfword reverse instructions."},{"role":"assistant","content":"<think>\nInstruction group: reverse operations (rev/rev16) from reverse.rkt. Decoder style: Rd/Rm arguments with unpredictable when either is r15. Symbolic regs/flags/memory: cpu-gpr-ref/set! plus concat/extract reorder bytes/halfwords; memory untouched. Constraints and solver queries: ensures operand orderings and bit slicing for solver by explicit concat.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  rev\n  rev16)\n\n\n(define (decode Rd Rm)\n  (define d Rd)\n  (define m Rm)\n  (when (|| (r15? d) (r15? m))\n    (unpredictable))\n  (values d m))\n\n(define (interpret-rev cpu Rd Rm)\n  (define-values (d m) (decode Rd Rm))\n  (define x (cpu-gpr-ref cpu m))\n  (define result (concat (extract 7 0 x) (extract 15 8 x) (extract 23 16 x) (extract 31 24 x)))\n  (cpu-gpr-set! cpu d result))\n\n(define (interpret-rev16 cpu Rd Rm)\n  (define-values (d m) (decode Rd Rm))\n  (define x (cpu-gpr-ref cpu m))\n  (define result (concat (extract 23 16 x) (extract 31 24 x) (extract 7 0 x) (extract 15 8 x)))\n  (cpu-gpr-set! cpu d result))\n\n\n(define-insn (Rd Rm)\n  #:encode (lambda (o1 o2) (list (bv #b01101 5) (bv o1 1) (bv #b11 2) (bv #b1111 4) Rd (bv #b1111 4) (bv o2 1) (bv #b011 3) Rm))\n  [(#b0 #b0) rev interpret-rev]\n  [(#b0 #b1) rev16 interpret-rev16])\n```\n"}]} 
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Please provide the Rosette semantics for SDIV and UDIV, including divide-by-zero behavior."},{"role":"assistant","content":"<think>\nInstruction group: signed/unsigned divide from signed-multiply-divide.rkt. Decoder style: Rd/Rm/Rn with unpredictable when any operand is r15. Symbolic regs/flags/memory: cpu-gpr-ref/set! fetch operands, result computed by core:bvsdiv-proc/core:bvudiv-proc; divide-by-zero returns zero. Constraints and solver queries: guard unpredictable cases, branch on bvzero? for divisor before solver query invocation.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  sdiv\n  udiv)\n\n\n(define (decode Rd Rm Rn)\n  (define d Rd)\n  (define n Rn)\n  (define m Rm)\n  (when (|| (r15? d) (r15? n) (r15? m))\n    (unpredictable))\n  (values d n m))\n\n(define (interpret-sdiv/udiv proc cpu Rd Rm Rn)\n  (define-values (d n m) (decode Rd Rm Rn))\n  (define operand1 (cpu-gpr-ref cpu n))\n  (define operand2 (cpu-gpr-ref cpu m))\n  (define result (if (bvzero? operand2) (bv 0 32) ((proc) operand1 operand2)))\n  (cpu-gpr-set! cpu d result))\n\n(define interpret-sdiv\n  (curry interpret-sdiv/udiv core:bvsdiv-proc))\n\n(define interpret-udiv\n  (curry interpret-sdiv/udiv core:bvudiv-proc))\n\n\n(define-insn (Rd Rm Rn)\n  #:encode (lambda (op1 Ra op2) (list (bv #b01110 5) (bv op1 3) Rd (bv Ra 4) Rm (bv op2 3) (bv #b1 1) Rn))\n  [(#b001 #b1111 #b000) sdiv interpret-sdiv]\n  [(#b011 #b1111 #b000) udiv interpret-udiv])\n```\n"}]} 
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Show me the Rosette semantics for MUL/MULS, MLS, and UMULL/UMULLS in the ARM multiply-and-accumulate unit."},{"role":"assistant","content":"<think>\nInstruction group: multiply and accumulate (mul/muls/mls/umull/umulls) from multiply-and-accumulate.rkt. Decoder style: opcode bits select operation; inputs include RdHi/RdLo for 64-bit cases and optional Ra for MLS. Symbolic regs/flags/memory: cpu-gpr-ref/set! supply operands, core:bvmul-proc and core:bvmulhu-proc produce 32- and 64-bit products, flags updated only when S bit set. Constraints and solver queries: unpredictable when any operand register is r15 or when RdLo==RdHi in long multiplies.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  mul muls\n  mls\n  umull umulls)\n\n\n(define (decode-mul/muls S Rd Rm Rn)\n  (define d Rd)\n  (define n Rn)\n  (define m Rm)\n  (define setflags (bveq S (bv #b1 1)))\n  (when (|| (r15? d) (r15? n) (r15? m))\n    (unpredictable))\n  (values d n m setflags))\n\n(define (interpret-mul/muls cpu S Rd dummy Rm Rn)\n  (define-values (d n m setflags) (decode-mul/muls S Rd Rm Rn))\n  (define operand1 (cpu-gpr-ref cpu n))\n  (define operand2 (cpu-gpr-ref cpu m))\n  (define result ((core:bvmul-proc) operand1 operand2))\n  (cpu-gpr-set! cpu d result)\n  (when setflags\n    (cpu-pstate.n-set! cpu (bit 31 result))\n    (cpu-pstate.z-set! cpu (is-zero-bit result))\n    ; PSTATE.C, PSTATE.V unchanged\n  ))\n\n\n(define (decode-mls Rd Ra Rm Rn)\n  (define d Rd)\n  (define n Rn)\n  (define m Rm)\n  (define a Ra)\n  (when (|| (r15? d) (r15? n) (r15? m) (r15? a))\n    (unpredictable))\n  (values d n m a))\n\n(define (interpret-mls cpu S Rd Ra Rm Rn)\n  (define-values (d n m a) (decode-mls Rd Ra Rm Rn))\n  (define operand1 (cpu-gpr-ref cpu n))\n  (define operand2 (cpu-gpr-ref cpu m))\n  (define addend (cpu-gpr-ref cpu a))\n  (define result (bvsub addend ((core:bvmul-proc) operand1 operand2)))\n  (cpu-gpr-set! cpu d result))\n\n\n(define (decode-umull/umulls S RdHi RdLo Rm Rn)\n  (define dLo RdLo)\n  (define dHi RdHi)\n  (define n Rn)\n  (define m Rm)\n  (define setflags (bveq S (bv #b1 1)))\n  (when (|| (r15? dLo) (r15? dHi) (r15? n) (r15? m))\n    (unpredictable))\n  (when (equal? dLo dHi)\n    (unpredictable))\n  (values dLo dHi n m setflags))\n\n(define (interpret-umull/umulls cpu S RdHi RdLo Rm Rn)\n  (define-values (dLo dHi n m setflags) (decode-umull/umulls S RdHi RdLo Rm Rn))\n  (define operand1 (cpu-gpr-ref cpu n))\n  (define operand2 (cpu-gpr-ref cpu m))\n  (define lower ((core:bvmul-proc) operand1 operand2))\n  (define upper ((core:bvmulhu-proc) operand1 operand2))\n  (define result (concat upper lower))\n  (cpu-gpr-set! cpu dHi upper)\n  (cpu-gpr-set! cpu dLo lower)\n  (when setflags\n    (cpu-pstate.n-set! cpu (bit 63 result))\n    (cpu-pstate.z-set! cpu (is-zero-bit result))\n    ; PSTATE.C, PSTATE.V unchanged\n  ))\n\n\n(define-insn (S RdHi RdLo Rm Rn)\n  #:encode (lambda (opc) (list (bv #b0000 4) (bv opc 3) S RdHi RdLo Rm (bv #b1001 4) Rn))\n  [(#b000) mul/muls     interpret-mul/muls]\n  [(#b011) @mls         interpret-mls]\n  [(#b100) umull/umulls interpret-umull/umulls])\n\n(define (mul Rd Rm Rn)\n  (curry mul/muls (bv #b0 1) Rd (integer->gpr 0) Rm Rn))\n\n(define (muls Rd Rm Rn)\n  (curry mul/muls (bv #b1 1) Rd (integer->gpr 0) Rm Rn))\n\n(define mls\n  (curry @mls (bv #b0 1)))\n\n(define umull\n  (curry umull/umulls (bv #b0 1)))\n\n(define umulls\n  (curry umull/umulls (bv #b1 1)))\n```\n"}]} 
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in ISA semantics and solver-aided verification."},{"role":"user","content":"Show me how the top-level ARM interpreter module wires in all instruction group interpreters."},{"role":"assistant","content":"<think>\nInstruction group: module aggregation from interp.rkt. Decoder style: not applicable; file requires each instruction submodule and re-exports their bindings. Symbolic regs/flags/memory: handled in imported modules; this file ensures they are all visible to the interpreter. Constraints and solver queries: ensures solver sees consistent namespace by re-exporting semantics.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"interp/branch-immediate.rkt\"\n  \"interp/extend-and-add.rkt\"\n  \"interp/integer-data-processing-immediate.rkt\"\n  \"interp/integer-data-processing-register.rkt\"\n  \"interp/integer-test-and-compare-immediate.rkt\"\n  \"interp/integer-test-and-compare-register.rkt\"\n  \"interp/load-store-dual-half-signed-byte-immediate.rkt\"\n  \"interp/load-store-multiple.rkt\"\n  \"interp/load-store-word-unsigned-byte-immediate.rkt\"\n  \"interp/logical-arithmetic-immediate.rkt\"\n  \"interp/logical-arithmetic-register.rkt\"\n  \"interp/logical-arithmetic-register-shifted-register.rkt\"\n  \"interp/miscellaneous.rkt\"\n  \"interp/move-halfword-immediate.rkt\"\n  \"interp/multiply-and-accumulate.rkt\"\n  \"interp/reverse.rkt\"\n  \"interp/signed-multiply-divide.rkt\")\n\n(provide (all-from-out\n  \"interp/branch-immediate.rkt\"\n  \"interp/extend-and-add.rkt\"\n  \"interp/integer-data-processing-immediate.rkt\"\n  \"interp/integer-data-processing-register.rkt\"\n  \"interp/integer-test-and-compare-immediate.rkt\"\n  \"interp/integer-test-and-compare-register.rkt\"\n  \"interp/load-store-dual-half-signed-byte-immediate.rkt\"\n  \"interp/load-store-multiple.rkt\"\n  \"interp/load-store-word-unsigned-byte-immediate.rkt\"\n  \"interp/logical-arithmetic-immediate.rkt\"\n  \"interp/logical-arithmetic-register.rkt\"\n  \"interp/logical-arithmetic-register-shifted-register.rkt\"\n  \"interp/miscellaneous.rkt\"\n  \"interp/move-halfword-immediate.rkt\"\n  \"interp/multiply-and-accumulate.rkt\"\n  \"interp/reverse.rkt\"\n  \"interp/signed-multiply-divide.rkt\"))\n```\n"}]} 
