{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Model a minimal OpenCL context in SynthCL so I can allocate global memory and ensure only real contexts can be installed as the current context."},{"role":"assistant","content":"<think>\nWe need the SynthCL context model with the current-context parameter guard and the clCreateContext constructor. The model uses a context struct and a parameter validator with match, ensuring only context? values are accepted. There are no symbolic variables or solver queries here, but this context object will scope later symbolic buffers and kernel executions.\n</think>\n\n```racket\n#lang rosette\n\n(require \"memory.rkt\" rosette/lib/match)\n\n(provide clCreateContext context? \n         context-global-memory current-context)\n        \n(define current-context \n  (make-parameter \n   #f\n   (lambda (p)\n     (match p\n       [(? context? p) p]\n       [p (raise-argument-error 'current-context \"context\" p)]))))\n\n; Models the OpenCL context for a device.  Contexts are \n; used by the OpenCL runtime for managing objects such as \n; command-queues, memory, program and kernel objects and for \n; executing kernels on one or more devices specified in the context.\n; See Ch. 4.4 of opencl-1.2 specification.\n;\n; In this simplified model of contexts, devices are \n; left unspecified, and work items all share a single global memory.\n; Local memory is not supported.\n(struct context (global-memory))\n\n; Creates an OpenCL context. Contexts are used by the OpenCL \n; runtime for managing objects such as command-queues, memory, \n; program and kernel objects and for executing kernels on one or \n; more devices.  Our model leaves the devices unspecified.   \n; For the full interface, see Ch. 4.4 of opencl-1.2 specification.\n(define (clCreateContext)\n  (context (memory)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Provide the SynthCL memory model: allocation, pointer access, and conflict checking for work-items, so I can reason about shared global memory updates."},{"role":"assistant","content":"<think>\nThis memory model defines the heap-backed memory struct, raw pointers, allocation, and read/write operations with conflict checks keyed by current-global-id. The DSL relies on pointer generics and type coercions, with vector-type handling for packed types. There are no direct solver queries, but symbolic contents flow through pointer-ref/set! and conflict assertions constrain feasible executions.\n</think>\n\n```racket\n#lang rosette\n\n(require \"errors.rkt\" \"work.rkt\" \"type.rkt\" \"reals.rkt\" \n         (only-in \"pointers.rkt\" gen:pointer)           \n         racket/generic rosette/lib/match)\n\n(provide (rename-out [make-memory memory]) memory? memory-empty?\n         memory-synchronize! memory-allocate! memset memory-owns? raw-pointer? NULL)\n\n; Creates a fresh, empty memory with the given capacity \n; or 64 if no capacity is given.\n(define (make-memory [capacity 512])\n  (assert (and (integer? capacity) (positive? capacity))\n          (format \"memory: contract violation\\n  expected: positive capacity\\n  given: ~a\" capacity))\n  (memory 0 (make-vector capacity)))\n\n; Represents a memory structure that contains zero or more allocated\n; regions in its heap vector.  The address field indicates the next \n; free address in the memory.  The addressing is two dimensional:  the \n; address of a memory cell pointed to by a pointer p is (m, n), where \n; m is the base address of p in memory and n is the index of the cell \n; within p's contents. \n;\n; Our model of pointers (and memory) is simplified in that we assume \n; all scalar datatypes have the same size (in bytes).  We also check that \n; all accesses to memory by entities with different current-global-id's are \n; non-conflicting.  \n(struct memory ([address #:mutable] [heap #:mutable]) \n  #:methods gen:custom-write\n  [(define (write-proc self port mode) \n     (fprintf \n      port \n      \"#memory~a\" (memory-heap self)))])\n\n; Returns true if the given memory is empty.\n(define (memory-empty? m)\n  (= 0 (memory-address m)))\n\n; Returns a new pointer to a region with the given \n; number of cells, allocated from the given memory. \n; The optional scalar type argument, if given, specifies\n; the type of the data stored in a single cell of the \n; allocated region. Default is #f (any scalar type).\n(define (memory-allocate! mem size [type #f])\n  (when type (assert (scalar-type? type)))\n  (define address (memory-address mem))\n  (define heap (memory-heap mem))\n  (when (>= address (vector-length heap))\n    (define heapX2 (make-vector (* 2 (vector-length heap))))\n    (vector-copy! heapX2 0 heap)\n    (set-memory-heap! mem heapX2)\n    (set! heap heapX2))\n  (define contents (make-vector size))\n  (define writes (make-vector size #f))\n  (define ptr (raw-pointer address contents writes type))\n  (vector-set! heap address ptr)\n  (set-memory-address! mem (add1 address))\n  ptr)\n\n; Ensures that all reads and writes to cells in the given \n; memory are performed before this procedure returns.\n(define (memory-synchronize! mem)\n  (define heap (memory-heap mem))\n  (for ([address (in-range 0 (memory-address mem))])\n    (vector-map! (const #f) \n                 (raw-pointer-writes (vector-ref heap address)))))\n\n; Returns true iff the given raw pointer points to an allocated \n; region in the given memory.\n(define (memory-owns? mem ptr)\n  (match* (mem ptr)\n    [((? memory?) (== NULL)) #t]\n    [((memory maddr heap) (raw-pointer paddr contents _ _))\n     (and (< paddr maddr) \n          (raw-pointer-contents (vector-ref heap paddr)) contents)]\n    [(_ _) #f]))\n\n; Sets the first num locations pointed to by the given pointer to the \n; given value.  The pointer's type is assumed (but not checked) to be void*.\n(define (memset ptr val num)\n  (match ptr\n    [(raw-pointer address contents writes _)\n     (check-conflicts 'memset address writes 0 num)\n     (vector-copy! writes   0 (make-vector num (current-global-id)))\n     (vector-copy! contents 0 (make-vector num val))\n     ptr]))\n  \n; Returns a view of the given pointer that treats its contents \n; as having the specified type T.  In particular, \n; pointer-ref and pointer-set! operations on the returned pointer \n; will produce and consume only values of type T. For example,\n; (pointer-set! p i v) to a pointer p that has been cast to the \n; int3 type will implicitly convert t to int3 before performing \n; the update.  Similarly, (pointer-ref p i) will return a value of \n; type int3.\n(define (raw-pointer-cast ptr type)\n  (match ptr\n    [(raw-pointer address contents writes _)\n     (raw-pointer address contents writes type)]\n    [_ (raise-pointer-cast-error ptr type)]))\n\n; Returns a list view of the storage region for the given pointer.\n(define (raw-pointer->list ptr)\n  (match ptr\n    [(raw-pointer _ contents _ _) (vector->list contents)]\n    [_ (raise-argument-error 'pointer->list \"pointer\" ptr)]))\n\n; Returns the length of the region pointed to by the given pointer.\n(define (raw-pointer-size ptr)\n  (vector-length (raw-pointer-contents ptr)))\n \n; Checks that there are no access conflicts on the memory cell (address, idx).\n(define (check-conflicts caller address writes idx len)\n  (when writes \n    (for ([i len] [w (take (drop (vector->list writes) idx) len)])\n      (assert (or (false? w) (equal? w (current-global-id)))\n              (format \"~a: access conflict detected on memory address #x~x[~a]\" caller  \n                      address (+ idx i))))))\n    \n; Returns the value stored at the given offset from the \n; base address of the given pointer (i.e., ptr[idx]).\n(define (raw-pointer-ref ptr idx)\n  (match ptr\n    [(raw-pointer address contents writes type)\n     (match type\n       [(and (? vector-type?) (app real-type-length len))\n        (define offset (* idx len))\n        (check-conflicts 'pointer-ref address writes offset len)\n        (define base (type-base type))       \n        (apply type (map (base) (take (drop (vector->list contents) offset) len)))]\n        ;(apply type (for/list ([i len]) ((base) (vector-ref contents (+ offset i)))))]\n       [_\n        (check-conflicts 'pointer-ref address writes idx 1)\n        (let ([val (vector-ref contents idx)])\n          (if type ((type) val) val))])]\n    [_ (raise-argument-error 'pointer-ref \"pointer\" ptr)]))\n\n; Sets the memory cell at the given offset from the \n; base address of the given pointer to the given value \n; (i.e., ptr[idx] := val).\n(define (raw-pointer-set! ptr idx val)\n  (match ptr\n    [(raw-pointer address contents writes type)\n     (match type\n       [(and (? vector-type?) (app real-type-length len))\n        (define offset (* idx len))\n        (check-conflicts 'pointer-set! address writes offset len)\n        (vector-copy! writes offset (make-vector len (current-global-id)))\n        (vector-copy! contents offset ((type) val))]\n        ;(define v ((type) val))\n        ;(for ([i len])\n        ;  (vector-set! writes (+ offset i) (current-global-id))\n        ;  (vector-set! contents (+ offset i) (vector-ref v i)))]\n       [_\n        (check-conflicts 'pointer-set! address writes idx 1)\n        (vector-set! writes idx (current-global-id))\n        (vector-set! contents idx (if type ((type) val) val))])] \n    [_ (raise-argument-error 'pointer-set! \"pointer\" ptr)]))\n\n; Each pointer keeps track of the global identifiers of \n; work items that write to each location in the pointer's array.  \n; A pointer can also have an optional type field, which \n; specifies the type of the elements it contains.  This field, \n; if not #f, determines the behavior of ptr-ref and \n; ptr-set! operations. \n(struct raw-pointer (address contents writes type)\n  #:methods gen:custom-write\n  [(define (write-proc self port mode)\n     (fprintf port \"#x~x\" (raw-pointer-address self))\n     (case mode\n       [(#t) (write (raw-pointer-contents self) port)]\n       [(#f) (display (raw-pointer-contents self) port)]\n       [else (fprintf port \"~a\" (raw-pointer-contents self))]))]\n  #:methods gen:pointer\n  [(define (pointer-address self) (raw-pointer-address self))\n   (define pointer-size raw-pointer-size)\n   (define pointer-cast raw-pointer-cast)\n   (define pointer-ref raw-pointer-ref)\n   (define pointer-set! raw-pointer-set!)\n   (define pointer->list raw-pointer->list)])\n\n; The null pointer.\n(define NULL (raw-pointer 0 (vector) (vector) #f))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Expose the SynthCL pointer type system so I can cast OpenCL buffers to vector and scalar pointer types safely in the model."},{"role":"assistant","content":"<think>\nWe need the generic pointer interface plus pointer-type constructors that wrap base types. The model uses generics for pointer operations and provides pointer-type values like int4* and float16* to enforce type-aware pointer-ref/set!. No solver queries here, but these types guide symbolic coercions when reading or writing symbolic memory.\n</think>\n\n```racket\n#lang rosette\n\n(require \"type.rkt\" \"reals.rkt\" \"errors.rkt\" \n         (for-syntax (only-in racket/syntax format-id)))\n\n(provide pointer-type? \n         gen:pointer pointer? pointer-address pointer-size \n         pointer-cast pointer->list pointer-ref pointer-set!\n         void* bool* int* float*\n         int2* int3* int4* int8* int16* \n         float2* float3* float4* float8* float16*)\n\n; A pointer object points to a storage region, which is a\n; a one-dimensional array of elements.  The elements \n; of this collection can be primitive scalars or vectors.\n; Our model of pointers (and memory) is simplified in that \n; we assume all datatypes have the same size (in bytes).\n(define-generics pointer  \n  \n  ; Returns the base address of the given pointer in memory.\n  [pointer-address pointer]\n  \n  ; Returns the length of the region pointed to by the given pointer.\n  [pointer-size pointer]\n  \n  ; Returns a view of the given pointer that treats its contents \n  ; as having the specified type T.  In particular, \n  ; pointer-ref and pointer-set! operations on the returned pointer \n  ; will produce and consume only values of type T. For example,\n  ; (pointer-set! p i v) to a pointer p that has been cast to the \n  ; int3 type will implicitly convert t to int3 before performing \n  ; the update.  Similarly, (pointer-ref p i) will return a value of \n  ; type int3.\n  [pointer-cast pointer type]\n  \n  ; Returns the value stored at the given offset from the \n  ; base address of the given pointer (i.e., ptr[idx]).\n  [pointer-ref pointer idx]\n  \n  ; Sets the memory cell at the given offset from the \n  ; base address of the given pointer to the given value \n  ; (i.e., ptr[idx] := val).\n  [pointer-set! pointer idx val]\n  \n  ; Returns a list view of the storage region for the given pointer.\n  [pointer->list pointer])\n\n; A simple model of OpenCL pointer types. \n; A pointer type is the type of an OpenCL pointer.\n; It consists of a name and a primitive type, which \n; which is the type of the elements in a pointer instance.\n; \n; Each pointer type T is also procedure that takes no \n; arguments and produces another procedure.  The returned \n; procedure, when applied to a pointer value  \n; casts it to a value of type T.  This is an unchecked cast.\n(struct pointer-type (base procedure)\n  #:property prop:procedure\n  [struct-field-index procedure]\n  #:methods gen:custom-write\n  [(define (write-proc self port mode) \n     (fprintf port \"~a\" (object-name self)))]\n  #:methods gen:type\n  [(define (type-name self) (object-name self))\n   (define (type-base self) (pointer-type-base self))])\n\n\n(define void*\n  (pointer-type \n   void \n   (let* ([cast-void* (lambda (b) \n                        (assert (pointer? b) (format \"pointer-cast: cannot cast ~a to ~a*\" b void))\n                        b)]\n          [void* (thunk cast-void*)])\n     void*)))\n                                         \n\n(define-syntax (define-pointer-type stx)\n  (syntax-case stx ()\n    [(_ base)\n     (with-syntax ([id (format-id #'base \"~a*\" #'base #:source #'base)])\n       (syntax/loc stx\n         (define id\n           (pointer-type\n            base\n            (let* ([convert (curryr pointer-cast base)]\n                   [id (thunk convert)])\n              id)))))]\n    [(_ base ...)\n     (syntax/loc stx\n       (begin\n         (define-pointer-type base) ...))]))\n\n(define-pointer-type\n  bool int float\n  int2 int3 int4 int8 int16 \n  float2 float3 float4 float8 float16)\n\n\n\n\n#|           \n(global-memory (memory))\n(define b (memory-allocate! (global-memory) CL_MEM_READ_WRITE 10))\n(define bb* ((bool*) b))\n(pointer-ref bb* 5)\n(pointer-set! bb* 5 #t)\n(pointer-set! bb* 6 10)\n(pointer-ref bb* 5)|#\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Model OpenCL buffers in SynthCL, including access flags and read/write checks inside kernels."},{"role":"assistant","content":"<think>\nThis buffer model wraps a pointer and access flags, mediating pointer operations based on CL_MEM_* permissions and kernel context. It integrates with the pointer generics, and in-kernel access checks ensure sound constraints on reads and writes. No solver queries are issued directly, but symbolic values flow through pointer-ref/set! and flag checks gate legal accesses.\n</think>\n\n```racket\n#lang rosette\n\n(require \"flags.rkt\" \"type.rkt\" \"pointers.rkt\" \"memory.rkt\" \"context.rkt\" \"work.rkt\"\n         rosette/lib/match)\n\n(provide clCreateBuffer buffer? buffer-context buffer-copy!)\n\n; Creates a new buffer object using the given context flags and size.  \n; Note that this is a simplified interface to the opencl-1.2 \n; specification (Ch. 5.2.1) and only limited functionality is exposed.\n(define (clCreateBuffer context flags size)\n  (or (equal? flags CL_MEM_READ_WRITE) \n      (equal? flags CL_MEM_READ_ONLY) \n      (equal? flags CL_MEM_WRITE_ONLY)\n      (raise-argument-error 'buffer \"a valid kernel access flag\" flags))\n  (buffer context (memory-allocate! (context-global-memory context) size) flags))\n\n; Allocates a buffer in the given memory that has the same size, \n; access control flags, and data as the given buffer.\n(define (buffer-copy! mem buff)\n  (match buff\n    [(buffer context ptr flags)\n     (buffer context (memory-allocate! mem (pointer-size ptr) ptr) flags)]\n    [_ \n     (raise-argument-error 'buffer-copy! \"buffer\" buff)]))\n\n(define (buffer-address self)\n  (pointer-address (buffer-pointer self)))\n\n(define (buffer-size self) \n  (pointer-size (buffer-pointer self)))\n\n(define (buffer-cast self type) \n  (buffer (buffer-context self)\n          (pointer-cast (buffer-pointer self) type) \n          (buffer-flags self)))\n\n(define (buffer->list self) \n  (pointer->list (buffer-pointer self)))\n\n(define (buffer-ref self idx)\n  (define ptr (buffer-pointer self))\n  (if (and (in-kernel?) (equal? (buffer-flags self) CL_MEM_WRITE_ONLY))\n      (error 'pointer-ref \"cannot read from a write-only memory address #x~x[~a]\" \n                           (pointer-address ptr) idx)\n      (pointer-ref ptr idx)))\n\n(define (buffer-set! self idx val) \n  (define ptr (buffer-pointer self))\n  (if (and (in-kernel?) (equal? (buffer-flags self) CL_MEM_READ_ONLY))\n      (error 'pointer-set! \"cannot write to a read-only memory address #x~x[~a]\" \n                           (pointer-address ptr) idx)\n      (pointer-set! (buffer-pointer self) idx val)))\n\n; OpenCL buffers are modeled as objects that \n; store a pointer to memory, context in which they\n; are create, and flags that determine whether a \n; given access operation (a read or a write) is permitted \n; on a particular buffer object.\n(struct buffer (context pointer flags)\n  #:methods gen:custom-write\n  [(define (write-proc self port mode)\n     (fprintf port \"~a\" (buffer-pointer self)))]\n  #:methods gen:pointer\n  [(define pointer-address buffer-address) \n   (define pointer-size buffer-size)\n   (define pointer-cast buffer-cast)\n   (define pointer-ref buffer-ref)\n   (define pointer-set! buffer-set!)\n   (define pointer->list buffer->list)])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Add a SynthCL program loader that discovers kernel definitions from an OpenCL DSL module and associates them with a context."},{"role":"assistant","content":"<think>\nThis model defines program objects tied to a context and uses a macro to load kernel identifiers from a source module. The macro reads the module syntax, filters kernel forms, and constructs a kernel name-to-procedure map. There are no direct solver calls, but these kernel procedures will later run with symbolic buffers and work sizes during synthesis or verification.\n</think>\n\n```racket\n#lang rosette\n\n(require (for-syntax (only-in rosette/lib/util/syntax read-module)\n                     (only-in racket filter-map))\n         \"context.rkt\")\n\n(provide clCreateProgramWithSource program? program-context program-kernels)\n\n; An OpenCL program consists of a set of kernels that are \n; identified as functions declared with the kernel qualifier \n; in the program source. Each program instance is associated with \n; an OpenCL context.  Once the kernels are loaded, the program is \n; implicitly compiled and built in our model.  The kernels field of \n; each program instance holds a list of pairs, where the first element \n; of each pair is the name of the kernel (given as a string), and the \n; second element is the kernel procedure with that name.\n(struct program (context kernels)\n  #:guard (lambda (context kernels name)\n            (unless (context? context)\n              (raise-argument-error 'clCreateProgramWithSource \"context\" context))\n            (values context kernels))\n  #:methods gen:custom-write\n  [(define (write-proc self port mode) \n     (fprintf port \"#<program:~a>\" (map car (program-kernels self))))])\n\n; Creates a program object for the context, and loads the kernels\n; from the file identified by the provided string literal.  The source \n; code specified by the file must be a module in the OpenCL DSL.  For \n; the full interface, see Ch. 5.6.1 of opencl-1.2 specification.\n(define-syntax (clCreateProgramWithSource stx)\n  (syntax-case stx ()\n    [(_ context filename)\n     (with-syntax ([(id ...) (parse-kernel-identifiers #'filename #'filename)])\n       (quasisyntax/loc stx\n         (program\n          context\n          (let ()\n            (local-require filename)          \n            (list (cons (~a (quote id)) id) ...)))))]))\n\n(define-for-syntax (parse-kernel-identifiers stx path)\n  (define-values (base name must-be-dir?) (split-path (syntax-source path)))\n  (define absolute-path (build-path base (syntax->datum path)))\n  (define source (read-module absolute-path))\n  (syntax-case source ()\n    [(mod id lang (mod-begin forms ...))\n     (filter-map (lambda (form)\n                   (syntax-case form ()\n                     [(kernel _ (id _ ...) _ ...) \n                      (and (identifier? #'kernel) (eq? 'kernel (syntax->datum #'kernel))) \n                      (datum->syntax stx (syntax->datum #'id))]\n                     [_ #f]))\n                 (syntax->list #'(forms ...)))]\n    [_ (raise-syntax-error #f \"expected a full path to a kernel module\" path)]))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Implement SynthCL kernel objects that capture a context and support clSetKernelArg with buffer and scalar validation."},{"role":"assistant","content":"<think>\nThis kernel model stores a context, argument vector, and procedure, and uses prop:procedure so kernels are callable. clCreateKernel links a program's kernel procedure to a kernel object, and clSetKernelArg enforces context consistency for buffers and type checks for scalar data. Solver interactions happen when the kernel runs with symbolic buffers; these constructors set up that execution.\n</think>\n\n```racket\n#lang rosette\n\n(require (only-in racket/syntax format-symbol) \"context.rkt\" \"buffer.rkt\" \"program.rkt\" \"errors.rkt\")\n\n(provide clCreateKernel clSetKernelArg kernel? kernel-context)\n\n; Models a kernel procedure as an applicable \n; struct instance with a context and a vector of arguments.\n; A kernel instance accepts no arguments.  When \n; invoked, it applies kernel-procedure to kernel-args.\n(struct kernel (context args procedure)\n  #:property prop:procedure\n  [struct-field-index procedure]\n  #:methods gen:custom-write\n  [(define (write-proc self port mode) \n     (fprintf port \"~a\" (cons (object-name self) \n                              (vector->list (kernel-args self))))])\n\n; Creates and returns a kernel for the given procedure from the \n; specified program. See Ch. 5.7 of opencl-1.2 specification for \n; the full interface.\n(define (clCreateKernel program kernel-name)\n  (define proc (cdr (or (assoc kernel-name (program-kernels program))\n                        (raise-argument-error 'clCreateKernel \"valid kernel name\" kernel-name))))\n  (define arity (procedure-arity proc))\n  (unless (integer? arity)\n    (raise-argument-error \n     'kernel \n     \"procedure that accepts an exact number of arguments\" proc))\n  (define args (make-vector arity (void)))\n  (kernel (program-context program) \n          args (procedure-rename\n                (thunk (apply proc (vector->list args)))\n                (format-symbol \"kernel:~a\" (object-name proc)))))\n\n; Sets the kernel argument at the given index to the given value.\n; Valid values are memory objects and primitive values.  If a memory \n; object is provided, its data is copied and the val pointer can be \n; reused by the host after clSetKernelArg returns.  This is a simplified \n; model of the interface in which the size of the value argument need \n; not be provided (since local memory is not modeled).\n; See Ch. 5.7.2 of opencl-1.2 specification.\n(define (clSetKernelArg kernel idx val)\n  (match val\n    [(? buffer? buff)\n     (if (eq? (buffer-context buff) (kernel-context kernel))\n         (vector-set! (kernel-args kernel) idx buff)\n         (raise-context-error 'clSetKernelArg kernel \"buffer\" buff))]\n    [datum \n     (if (type-of datum)\n         (vector-set! (kernel-args kernel) idx datum)\n         (raise-argument-error 'clSetKernelArg \"memory object or real value\" datum))]))\n \n  \n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Add SynthCL command queues with enqueue operations for buffer reads/writes and NDRange kernel execution."},{"role":"assistant","content":"<think>\nThis module models command queues and enqueues buffer read/write operations plus NDRange kernel execution. It validates context consistency, uses current-memory and current-work-size to parameterize kernel runs, and synchronizes memory afterward. Solver behavior arises when kernels access symbolic buffers under current-global-id, but this layer just sequences tasks.\n</think>\n\n```racket\n#lang rosette\n\n(require \"context.rkt\" \"buffer.rkt\" \"kernel.rkt\" \n         \"work.rkt\" \"runtime.rkt\" \"memory.rkt\"\n         \"pointers.rkt\" \"errors.rkt\" \n         rosette/lib/match)\n\n(provide clCreateCommandQueue clEnqueueReadBuffer clEnqueueWriteBuffer clEnqueueNDRangeKernel command-queue?)\n\n; Models the OpenCL command queue for a given context.\n(struct command-queue (context [tasks #:auto #:mutable])\n  #:auto-value '()\n  #:methods gen:custom-write\n  [(define (write-proc self port mode) \n     (fprintf port \"#<command-queue:~a>\" (eq-hash-code self)))])\n\n; Creates a command queue in the given context and returns it.\n; Our model does not support out of order execution. See Ch. 5.2.2 \n; of opencl-1.2 specification for the full interface.\n(define (clCreateCommandQueue context)\n  (unless (context? context)\n    (raise-argument-error 'clCreateCommandQueue \"context\" context))\n  (command-queue context))\n\n; Enqueues a command to read from a buffer object to host memory.  All \n; reads are implicitly blocking.  The command queue and the buffer must \n; have the same context. See Ch. 5.2.2 of opencl-1.2 specification \n; for the full interface.\n(define (clEnqueueReadBuffer cq buff offset size ptr)\n  (define context (command-queue-context cq))\n  (unless (eq? context (buffer-context buff))\n    (raise-context-error 'clEnqueueReadBuffer cq \"buffer\" buff))\n  (assert (memory-owns? (current-memory) ptr)\n          (thunk (raise-argument-error 'clEnqueueReadBuffer \"valid pointer to host memory\" ptr)))\n  (define global-memory (context-global-memory context))\n  (for ([i (in-range offset (+ offset size))])\n    (pointer-set! ptr i (pointer-ref buff i)))\n  (void))\n\n; Enqueues a command to write from host memory to a buffer object.  All \n; reads are implicitly blocking.  The command queue and the buffer must \n; have the same context.  See Ch. 5.2.2 of opencl-1.2 specification \n; for the full interface.\n(define (clEnqueueWriteBuffer cq buff offset size ptr)\n  (define context (command-queue-context cq))\n  (unless (eq? context  (buffer-context buff))\n    (raise-context-error 'clEnqueueWriteBuffer cq \"buffer\" buff))\n  (assert (memory-owns? (current-memory) ptr)\n          (thunk (raise-argument-error 'clEnqueueWriteBuffer \"valid pointer to host memory\" ptr)))\n  (define global-memory (context-global-memory context))\n  (for ([i (in-range offset (+ offset size))])\n    (pointer-set! buff i (pointer-ref ptr i)))\n  (memory-synchronize! global-memory)\n  (void))\n\n; Enqueus a command to  execute a kernel on a device.  The command queue \n; and the kernel must have the same context.  See Ch. 5.8 of opencl-1.2 \n; specification for the full interface.\n(define (clEnqueueNDRangeKernel cq kernel work-dim global-work-offset global-work-size local-work-size)\n  (define context (command-queue-context cq))\n  (unless (eq? (command-queue-context cq) (kernel-context kernel))\n    (raise-context-error 'clEnqueueNDRangeKernel cq \"kernel\" kernel))\n  (unless (> work-dim 0)\n    (raise-argument-error 'clEnqueueNDRangeKernel \"positive work dimension\" work-dim))\n  (define global-memory (context-global-memory context))\n  (define gws (pointer->list global-work-size))\n  (define work-items (apply * gws))\n  (parameterize ([current-work-size (list (pointer->list global-work-offset) gws (pointer->list local-work-size))]\n                 [current-memory global-memory])\n    (for ([id (apply * gws)])\n      (parameterize ([current-global-id id])\n        (kernel))))\n  (memory-synchronize! global-memory)\n  (void))\n\n        \n\n\n    \n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Implement SynthCL work-item semantics, including current-work-size validation and global/local ID queries."},{"role":"assistant","content":"<think>\nThis module defines current-work-size and current-global-id parameters plus OpenCL query functions like get_global_id and get_local_size. The parameter validators encode structural constraints on work sizes and IDs, and these constraints guide solver reasoning when kernels use symbolic work sizes or IDs. There are no explicit solver queries, but the checks induce assertions during symbolic execution.\n</think>\n\n```racket\n#lang rosette\n\n\n(provide current-work-size current-global-id \n         in-host? in-kernel?\n         get_work_dim get_global_offset \n         get_global_size get_local_size get_num_groups\n         get_global_id get_local_id get_group_id)\n\n; A valid work size specification consists of three lists of size k,\n; where 1 <= k <= 3.  The first list represents the global work offset, \n; the second is the global work size, and the third is the local work \n; size.  The offset list must contain only integers, and the work size \n; lists must be positive integers.  Additionally, the ith element of the \n; global work size list must be evenly divisible by the ith element of the \n; local work size list.  See p. 171 of opencl-1.2 specification.\n; \n; The global offset and work size may be left empty when initializing the \n; current-work-size parameter.  If the offset is empty, the zero offset is \n; used.  If the local work size is empty, a work size is picked by the \n; implementation.\n(define current-work-size\n  (make-parameter '(()()())\n   (lambda (ws)\n     (match ws  \n       [(list (? list? off) (and (? list? gws) (app length n)) (? list? lws))\n        (unless (and (<= 1 n) (<= n 3) (andmap positive-integer? gws))\n          (raise-argument-error \n           'current-work-size \n           \"a valid global work size specification\" gws))\n        (let* ([off (cond [(null? off) (make-list n 0)]\n                          [(= (length off) n) off]\n                          [else (raise-argument-error \n                                 'current-work-size \n                                 \"a valid global work offset specification\" off)])]\n               [lws (cond [(null? lws) (make-list n 1)]\n                          [(and (= (length lws) n) \n                                (andmap positive-integer? lws) \n                                (andmap (compose1 zero? remainder) gws lws)) lws]\n                          [else (raise-argument-error \n                                 'current-work-size \n                                 \"a valid local work size specification\" ws)])])\n          (list off gws lws))]       \n       [_ (raise-argument-error \n           'current-work-size \n           \"a valid work size specification\" ws)]))))\n\n        \n; The unique global ID that is in use by the currently running kernel, \n; including the offset. The ID is a list of k integers, where k is \n; (get_work_dim) and the ith integer is between (get_global_offset i), \n; inclusive, and (get_global_offset i) + (get_global_size i), exclusive.\n; If the currently running code is the host rather than a kernel, then \n; the global_id is the empty list.\n;\n; The current-global-id parameter can be initialized either with a list \n; of k integers representing a valid ID, or with an integer between 0,\n; inclusive, and n, exclusive, where n = (get_global_size 0) * ... *\n; (get_global_size (- 1 (get-work-dim))).  This integer is converted to \n; the list representation.\n(define current-global-id\n  (make-parameter '()\n   (lambda (id)\n     (define ws (current-work-size))\n     (define off (offset ws))\n     (define gws (global ws))\n     (define d (length gws))\n     (define n (apply * gws))\n     (cond [(and (list? id) (= (length id) d) \n                 (andmap integer? id) \n                 (andmap <= off id)\n                 (andmap < id (map + off gws)))\n            id]\n           [(and (integer? id) (<= 0 id) (< id n))\n            (map + off\n                 (let loop ([gws gws][n n][r id])\n                   (if (null? gws)\n                       '()\n                       (let* ([n (quotient n (car gws))])\n                         (cons (quotient r n)\n                               (loop (cdr gws) n (remainder r n)))))))]\n           [else (raise-argument-error \n                   'current-global-id \n                   \"valid global ID for current work_size\" id)]))))\n\n; Returns true iff x is a positive integer.\n(define (positive-integer? x)\n  (and (integer? x) (positive? x)))\n\n(define-values (offset global local) (values first second third))\n\n; Returns true iff the currently running code is being executed \n; by the host.\n(define (in-host?) (null? (current-global-id)))\n\n; Returns true iff the currently running code is being executed \n; by a kernel host.\n(define (in-kernel?) (not (null? (current-global-id))))\n\n; Returns the offset or number of global or local work-items\n; specified for dimension identified by dimindx. This value is \n; given by the global_work_offset, global_work_size or \n; local_work_size argument to clEnqueueNDRangeKernel. Valid \n; values of dim are 0  to get_work_dim() – 1. For other values \n; of dim, get_work_size() returns the provided default value. \n(define (get_work_size which dim default)\n  (let ([ws (which (current-work-size))])\n    (if (and (<= 0 dim) (< dim (length ws)))\n        (list-ref ws dim)\n        default)))\n\n; Returns the number of dimensions in use. This is the \n; value given to the work_dim argument specified in \n; clEnqueueNDRangeKernel. \n; See Ch. 6.12.1 of opencl-1.2 specification.\n(define (get_work_dim) \n  (length (offset (current-work-size))))\n\n; Returns the offset values specified in global_work_offset argument \n; to clEnqueueNDRangeKernel. Valid values of\n; dim are 0 to get_work_dim() – 1. For other values,\n; get_global_offset() returns 0.\n; See Ch. 6.12.1 of opencl_1.2 specification.\n(define (get_global_offset dim) \n  (get_work_size offset dim 0))\n\n; Returns the number of global work-items specified \n; for dimension identified by dim. This value is \n; given by the global_work_size argument to \n; clEnqueueNDRangeKernel. Valid values of dimindx are 0 \n; to get_work_dim() – 1. For other values of dim, \n; get_global_size() returns 1. \n; See Ch. 6.12.1 of opencl-1.2 specification.\n(define (get_global_size dim) \n  (get_work_size global dim 1))\n\n; Returns the number of local work-items specified in dimension\n; identified by dim. This value is given by the local_work_size\n; argument to clEnqueueNDRangeKernel. Valid values\n; of dim are 0 to get_work_dim() – 1. For other values of dim,\n; get_local_size() returns 1.\n; See Ch. 6.12.1 of opencl-1.2 specification.\n(define (get_local_size dim) \n  (get_work_size local dim 1))\n\n; Returns the number of work-groups that will execute a kernel for\n; dimension identified by dim. Valid values of dim are 0 to\n; get_work_dim() – 1. For other values of dimindx, get_num_groups ()\n; returns 1.\n; See Ch. 6.12.1 of opencl-1.2 specification.\n(define (get_num_groups dim)\n  (/ (get_global_size dim) (get_local_size dim)))\n\n; Returns the unique global work-item ID value for dimension \n; identified by dim. The global work-item ID specifies the \n; work-item ID based on the number of global work-items specified to \n; execute the kernel. Valid values of dim are 0 to \n; get_work_dim() – 1. For other values of dim, get_global_id() \n; returns 0.\n; See Ch. 6.12.1 of opencl-1.2 specification.\n(define (get_global_id dim)\n  (let ([gid (current-global-id)])\n    (if (and (<= 0 dim) (< dim (length gid))) \n        (list-ref gid dim)\n        0)))\n\n; Returns the unique local work-item ID i.e. a work-item within a\n; specific work-group for dimension identified by dim. Valid values\n; of dim are 0 to get_work_dim() – 1. For other values of dim,\n; get_local_id() returns 0.\n; See Ch. 6.12.1 of opencl-1.2 specification.\n(define (get_local_id dim)\n  (let ([gid (get_global_id dim)]\n        [lws (get_local_size dim)]\n        [off (get_global_offset dim)])\n    (remainder (max 0 (- gid off)) lws)))\n\n; Returns the work-group ID which is a number from 0 ..\n; get_num_groups(dim) – 1. Valid values of dim are 0 to\n; get_work_dim() – 1. For other values, get_group_id() returns 0.\n; See Ch. 6.12.1 of opencl-1.2 specification.\n(define (get_group_id dim)\n  (let ([gid (get_global_id dim)]\n        [lws (get_local_size dim)]\n        [off (get_global_offset dim)])\n    (quotient (- gid off) lws)))\n```"}]}
