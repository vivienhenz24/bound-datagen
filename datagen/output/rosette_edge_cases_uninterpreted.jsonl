{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I have a symbolic uninterpreted boolean operator and mix concrete and symbolic booleans. Can you show me a minimal Rosette example that constrains its behavior and then checks it matches builtin &&?"},{"role":"assistant","content":"<think>\nThis case uses an uninterpreted function of type (~> boolean? boolean? boolean?) with symbolic booleans a and b. The constraints force the UF to agree with truth-table behavior on mixed symbolic/concrete inputs, including a nested && and !, so the solver must pick a consistent interpretation. The tricky part is that the UF is unconstrained outside asserted combinations, and equivalence is checked by synthesizing inputs via function-domain and then verifying (equal? (apply impl inputs) (apply spec inputs)). The query uses solve with explicit asserts, then check-equivalent compares the solver-provided interpretation against &&. Expected outcome is sat with a model consistent with logical conjunction across those constraints.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui rosette/lib/roseunit\n         rosette/base/core/term rosette/base/core/function)\n\n\n(define (check-equivalent impl spec)\n  (define inputs (for/list ([t (function-domain (get-type impl))])\n                   (define-symbolic* in t)\n                   t))\n  (verify (assert (equal? (apply impl inputs) (apply spec inputs)))))\n\n(define (test-equivalent impl io-pairs)\n  (for ([p io-pairs])\n    (check = (apply impl (car p)) (cdr p))))\n\n(define (check-not)\n  (define-symbolic ¬ (~> boolean? boolean?))\n  (define sol\n    (solve (begin\n             (assert (equal? (¬ #t) #f))\n             (assert (equal? (¬ #f) #t)))))\n  (check-equivalent (sol ¬) !))\n\n(define (check-and)\n  (define-symbolic ∧ (~> boolean? boolean? boolean?))\n  (define sol\n    (solve\n     (begin\n       (assert (equal? (∧ #t #t) #t))\n       (assert (equal? (∧ #t #f) #f))\n       (assert (equal? (∧ #f #t) #f))\n       (assert (equal? (∧ #f #f) #f)))))\n  (check-equivalent (sol ∧) &&))\n\n(define (check-boolean-mixed)\n  (define-symbolic ∧ (~> boolean? boolean? boolean?))\n  (define-symbolic a b boolean?)\n  (define sol\n    (solve\n     (begin\n       (assert (equal? a #t))\n       (assert (equal? b #f))\n       (assert (equal? (∧ a a) a))\n       (assert (equal? (∧ a b) b))\n       (assert (equal? (∧ b a) b))\n       (assert (equal? (∧ b (&& (! a) b)) b)))))\n  (check-equivalent (sol ∧) &&))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I'm seeing weird interactions between 1-bit bitvectors and booleans when I use an uninterpreted function. Can you provide a Rosette test that exercises both directions and shows the type error when I pass the wrong bitvector width?"},{"role":"assistant","content":"<think>\nThis edge case targets solvers that conflate booleans and 1-bit bitvectors. The code defines UFs even and f with bitvector and boolean domains/ranges, constrains them with concrete input/output pairs, and then evaluates the model. It explicitly checks that evaluate yields consistent values for bitvectors of width 2, and then triggers a type error by applying the evaluated function to a 1-bit bitvector, which should violate the boolean? contract. The solver is expected to be sat for the constraints, but Rosette should reject the ill-typed application at runtime.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui rosette/lib/roseunit\n         rosette/base/core/term rosette/base/core/function)\n```\n\n```racket\n; Basic tests for booleans and 1-bit bitvectors (some solvers conflate them)\n(define (check-bitvector-booleans)\n  (define-symbolic even (~> (bitvector 2) boolean?))\n  (define sol\n    (solve (for ([i (in-range -2 2)])\n             (assert (equal? (even (bv i 2)) (even? i))))))\n  (check-sat sol)\n  (check-equal? (evaluate (even (bv -2 2)) sol) #t)\n  \n  (define-symbolic f (~> boolean? (bitvector 2)))\n  (define solf\n    (solve (assert (and (equal? (f #t) (bv 0 2))\n                        (equal? (f #f) (bv -2 2))))))\n  (check-sat solf)\n  (check-equal? (evaluate (f #t) solf) (bv 0 2))\n  (check-equal? (evaluate (f #f) solf) (bv -2 2))\n  (check-exn #px"boolean\\?" (thunk ((evaluate f solf) (bv 0 1)))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I have a UF returning real values, but I'm running with a finite bitwidth. Can you show me a Rosette test that demonstrates the finitization error?"},{"role":"assistant","content":"<think>\nThis case demonstrates that Rosette disallows finitization when an uninterpreted function ranges over reals under a finite bitwidth. The code sets current-bitwidth to 5 and defines f as (~> boolean? real?). The solver call attempts to assert a concrete real result, which requires finitization, and check-exn ensures Rosette raises a finitize error. The expected outcome is an exception, not a solver result, because reals are not finitized under a finite bitwidth.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui rosette/lib/roseunit\n         rosette/base/core/term rosette/base/core/function)\n```\n\n```racket\n(define (check-finitization-disallowed)\n  (current-bitwidth 5)\n  (define-symbolic f (~> boolean? real?))\n  (check-exn #px"finitize.*" (thunk (solve (assert (= (f #f) .5))))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I need a Rosette example that shows how uninterpreted functions handle lifted applications and type casts when arguments are symbolic and may not match the domain type."},{"role":"assistant","content":"<think>\nThis edge case uses uninterpreted functions f, g, and h with boolean?, integer?, and real? domains, then applies them to ill-typed and symbolic expressions. The code expects specific exceptions for direct type mismatches and then checks lifted applications via expression @app, including type-cast, real->integer, and integer->real. The tricky part is how Rosette injects assertions or casts when the argument might satisfy the domain at runtime, and how lifted applications are represented in the VC. The solver is not the focus here; instead, the expected behavior is precise type errors or VC state transformations.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui rosette/lib/roseunit\n         rosette/base/core/term rosette/base/core/function)\n```\n\n```racket\n(define-syntax-rule (check-state actual expected)\n  (let ([re (with-vc expected)]\n        [ra (with-vc actual)])\n    (check-equal? (result-value ra) (result-value re))\n    (check-equal? (result-state ra) (result-state re))))\n\n(define (check-types)\n  (define-symbolic a boolean?)\n  (define-symbolic b integer?)\n  (define-symbolic c real?)\n  (define-symbolic f (~> boolean? boolean?))\n  (define-symbolic g (~> integer? integer?))\n  (define-symbolic h (~> real? real?))\n  (check-exn #px"boolean\\?" (thunk (f 3)))\n  (clear-vc!)\n  (check-exn #px"boolean\\?" (thunk (f b)))\n  (clear-vc!)\n  (check-exn #px"boolean\\?" (thunk (f (if a b c))))\n  (clear-vc!)\n  (check-exn #px"integer\\?" (thunk (g a)))\n  (clear-vc!)\n  (check-exn #px"integer\\?" (thunk (g (if a 'b 'c))))\n  (clear-vc!)\n  (check-exn #px"real\\?" (thunk (h a)))\n  (clear-vc!)\n  (check-exn #px"real\\?" (thunk (h (if a 'b 'c))))\n  (clear-vc!)\n  (check-exn #px"arity" (thunk (f)))\n  (clear-vc!)\n  (check-state (g b) (expression @app g b))\n  (check-state (g (if a b 'b)) (begin (assert a) (expression @app g b)))\n  (check-state (g (if a b c)) (expression @app g (type-cast integer? (if a b c))))  \n  (check-state (g c) (begin (assert (int? c)) (expression @app g (real->integer c))))\n  (check-state (h c) (expression @app h c))\n  (check-state (h b) (expression @app h (integer->real b)))\n  (check-state (h (if a b 'b)) (begin (assert a) (expression @app h (integer->real b))))\n  (check-state (h (if a b c)) (expression @app h (type-cast real? (if a b c)))))\n```"}]}
