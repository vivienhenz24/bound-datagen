{"messages": [{"role": "system", "content": "You are the Rosette Maintainer AI, an expert in solver-aided memory modeling."}, {"role": "user", "content": "Show how to model a byte array block with path conversion and safe memset constraints in Serval's Rosette memory model."}, {"role": "assistant", "content": "<think>\nArray blocks reinterpret offsets as (index, inner offset) pairs so symbolic pointers land on element boundaries. mblock-inbounds? guards the array size relation, and the two-case marray-memset! enforces alignment invariants when writing either a single element or a full stripe. mblock-memset! is the solver touchpoint that pushes those predicates into the UF-backed elements.\n</think>\n\n```racket\n#lang rosette\n\n(require \"../debug.rkt\" \"../bvarith.rkt\" \"manager.rkt\")\n\n(define target-pointer-bitwidth (make-parameter 64))\n\n(define (bvpointer?)\n  (bitvector (target-pointer-bitwidth)))\n\n(define (bvpointer x)\n  (bv x (target-pointer-bitwidth)))\n\n(define (mblock-inbounds? mblock offset size)\n  (define block-size (bvpointer (mblock-size mblock)))\n  (&& (bvule size block-size)\n      (bvule offset (bvsub block-size size))))\n\n; marray\n\n(define (marray-size mblock)\n  (* (marray-length mblock) (mblock-size (marray-elements mblock))))\n\n(define (marray-init! mblock name [domain null])\n  (mblock-init! (marray-elements mblock)\n                name\n                (cons (bvpointer?) domain)))\n\n(define (marray-fini! mblock)\n  (mblock-fini! (marray-elements mblock)))\n\n(define (marray-path mblock offset size)\n  (bug-on (! (mblock-inbounds? mblock offset size))\n    #:msg (format \"marray-path: offset ~e not in bounds ~e\" offset size))\n  (define element-size (bvpointer (mblock-size (marray-elements mblock))))\n  (define element-index (bvudiv offset element-size))\n  (define element-offset (bvurem offset element-size))\n  (cons element-index\n        (mblock-path (marray-elements mblock) element-offset size)))\n\n(define (marray-resolve mblock path [indices null])\n  (mblock-resolve (marray-elements mblock)\n                (cdr path)\n                (cons (car path) indices)))\n\n; For simplicity, this supports two cases only:\n; - memset within one element\n; - memset over multiple (full) elements\n; It doesn't allow memset over partial elements.\n(define (marray-memset! mblock c offset size [preds null])\n  (bug-on (! (mblock-inbounds? mblock offset size))\n    #:msg \"marray-memset!: [offset, offset + size) not in bounds\")\n  (define element-size (bvpointer (mblock-size (marray-elements mblock))))\n  (define element-index (bvudiv offset element-size))\n  (define element-offset (bvurem offset element-size))\n  (if (bvule size element-size)\n      ; memset within one element\n      (begin\n        ; No need to check offset <= element-size - size here;\n        ; if offset is too large, the next level will fail.\n\n        ; predicate: idx == element-index\n        (define pred (lambda (idx) (equal? idx element-index)))\n        (mblock-memset! (marray-elements mblock) c element-offset size\n                        (cons pred preds)))\n      ; memset across multiple full elements\n      (begin\n        ; alignment checks for offset and size\n        (bug-on (! (bvzero? element-offset))\n                #:msg \"marray-memset!: offset not aligned\")\n        (bug-on (! (bvzero? (bvurem size element-size)))\n                #:msg \"marray-memset!: size not aligned\")\n        ; predicate: element-index <= idx < element-index + size / element-size\n        (define pred (lambda (idx)\n                         (&& (bvule element-index idx)\n                             (bvult idx (bvadd element-index (bvudiv size element-size))))))\n        (mblock-memset! (marray-elements mblock) c (bvpointer 0) element-size\n                        (cons pred preds)))))\n\n(define (marray-copy mblock)\n  (struct-copy marray mblock\n    [elements (mblock-copy (marray-elements mblock))]))\n\n(struct marray (length elements) #:transparent\n  #:methods gen:mblock\n  [(define mblock-size marray-size)\n   (define mblock-init! marray-init!)\n   (define mblock-fini! marray-fini!)\n   (define mblock-path marray-path)\n   (define mblock-resolve marray-resolve)\n   ; mblock-load\n   ; mblock-store!\n   (define mblock-memset! marray-memset!)\n   (define mblock-copy marray-copy)])\n```"}]}
{"messages": [{"role": "system", "content": "You are the Rosette Maintainer AI, an expert in solver-aided memory modeling."}, {"role": "user", "content": "I need a struct-backed symbolic object where fields sit at fixed offsets but callers may use symbolic pointer arithmetic. How do I reuse Serval's struct crunching to stay solver-friendly?"}, {"role": "assistant", "content": "<think>\nStruct blocks rewrite symbolic offsets with crunch-struct-offset so Z3 never enumerates symbolic bvurem chains. The field lookup invariant is that each offset resolves to exactly one mfield, after which mblock-path recurses on the child element. Full-struct memset funnels zero writes into each field, while partial memset reuses the computed field offset. The solver only sees the UF updates exposed through mblock-memset!.\n</think>\n\n```racket\n#lang rosette\n\n(require \"../debug.rkt\" \"../bvarith.rkt\" \"manager.rkt\")\n\n(define target-pointer-bitwidth (make-parameter 64))\n\n(define (bvpointer?)\n  (bitvector (target-pointer-bitwidth)))\n\n(define (bvpointer x)\n  (bv x (target-pointer-bitwidth)))\n\n(define enable-struct-crunch (make-parameter (if (getenv \"DISABLE_STRUCT_CRUNCH\") #f #t)))\n\n(struct mfield (name offset element) #:transparent)\n\n(define (mstruct-init! mblock name [domain null])\n   (for-each (lambda (f)\n               (mblock-init! (mfield-element f) (append name (list (mfield-name f))) domain))\n             (mstruct-fields mblock)))\n\n(define (mstruct-fini! mblock)\n   (for-each (lambda (f) (mblock-fini! (mfield-element f)))\n             (mstruct-fields mblock)))\n\n; Symbolic offsets inside structs will kill Z3 in @findf.\n; Instead, we do this ugly hack to patch the symbolic offset\n; in the form (urem (add x (mul y z)) y) into just x.\n(define (crunch-struct-offset offset)\n  (define (kill-bvmul expr const)\n    (match expr\n      [(expression (== bvadd) x y)\n       (let ([subexpr (kill-bvmul y const)])\n         (if subexpr (bvadd x subexpr) #f))]\n\n      [(expression (== bvmul) x y) #:when (and (! (term? x)) (bveq const x))\n        (bv 0 (target-pointer-bitwidth))]\n\n      [(expression (== bvshl) x y) #:when (and (! (term? y)) (bveq const (bvshl (bv 1 (target-pointer-bitwidth)) y)))\n        (bv 0 (target-pointer-bitwidth))]\n\n      [_ #f]))\n\n  (if (enable-struct-crunch)\n    (match offset\n      [(expression (== bvurem) x y) #:when (! (term? y))\n        (let ([subexpr (kill-bvmul x y)])\n          (if subexpr subexpr offset))]\n      [any any])\n    offset))\n\n(define (mstruct-field-by-name mblock name)\n  (findf (lambda (x) (equal? (mfield-name x) name)) (mstruct-fields mblock)))\n\n(define (mstruct-field-by-offset mblock offset)\n  (define fields (map (lambda (x) (mfield (mfield-name x) (bvpointer (mfield-offset x)) (mfield-element x)))\n                      (reverse (mstruct-fields mblock))))\n  (findf (lambda (x) (bvuge offset (mfield-offset x))) fields))\n\n(define (mstruct-path mblock offset size)\n  (define offset2 (crunch-struct-offset offset))\n  (bug-on (not (bveq offset offset2)) #:msg \"mstruct-path: rewriting failed\")\n\n  (bug-on (not (mblock-inbounds? mblock offset2 size))\n    #:msg \"mstruct-path: offset not in bounds\")\n\n  (define f (mstruct-field-by-offset mblock offset2))\n  (cons (mfield-name f)\n        (mblock-path (mfield-element f) (bvsub offset2 (mfield-offset f)) size)))\n\n(define (mstruct-resolve mblock path [indices null])\n  (define f (mstruct-field-by-name mblock (car path)))\n  (mblock-resolve (mfield-element f) (cdr path) indices))\n\n; For simplicity, this supports two cases only:\n; - memset within a single field\n; - memset over the entire struct\n; It doesn't allow memset over partial fields.\n(define (mstruct-memset! mblock c offset size [preds null])\n  (define offset2 (crunch-struct-offset offset))\n  (bug-on (! (bveq offset offset2)) #:msg \"mstruct-memset!: rewriting failed\")\n\n  (bug-on (! (mblock-inbounds? mblock offset2 size))\n    #:msg \"mstruct-memset!: [offset, offset + size) not in bounds\")\n\n  (define block-size (bvpointer (mblock-size mblock)))\n\n  (if (equal? size block-size)\n      ; memset over the entire struct\n      (begin\n        ; offset must be zero given the earlier bounds check\n        ; recusrive memset over each element\n        (define (recur f)\n          (define element (mfield-element f))\n          (mblock-memset! element c (bvpointer 0) (bvpointer (mblock-size element))\n                          preds))\n        (for-each recur (mstruct-fields mblock)))\n      ; memset within one element\n      (begin\n        ; no need to check size: the next level will check\n        (define f (mstruct-field-by-offset mblock offset2))\n        (mblock-memset! (mfield-element f) c (bvsub offset2 (mfield-offset f)) size\n                          preds))))\n\n(define (mstruct-copy mblock)\n  (define (copy-field f)\n    (struct-copy mfield f [element (mblock-copy (mfield-element f))]))\n  (struct-copy mstruct mblock\n    [fields (map copy-field (mstruct-fields mblock))]))\n\n(struct mstruct (size fields) #:transparent\n  #:methods gen:mblock\n  [(define (mblock-size mblock) (mstruct-size mblock))\n   (define mblock-init! mstruct-init!)\n   (define mblock-fini! mstruct-fini!)\n   (define mblock-path mstruct-path)\n   (define mblock-resolve mstruct-resolve)\n   ; mblock-load\n   ; mblock-store!\n   (define mblock-memset! mstruct-memset!)\n   (define mblock-copy mstruct-copy)])\n```"}]}
{"messages": [{"role": "system", "content": "You are the Rosette Maintainer AI, an expert in solver-aided memory modeling."}, {"role": "user", "content": "Show me a Rosette leaf cell that enforces offset/size divisibility and updates an uninterpreted function on store."}, {"role": "assistant", "content": "<think>\nCells treat each leaf as an uninterpreted bitvector function over indices. mcell-path enforces that block sizes and offsets are multiples of the access size, and the free flag prevents use-after-free loads and stores. Stores and memset rewrite the UF so the solver only considers updated indices while leaving all other evaluations abstract.\n</think>\n\n```racket\n#lang rosette\n\n(require \"../debug.rkt\" \"../bvarith.rkt\" \"manager.rkt\")\n\n(define target-pointer-bitwidth (make-parameter 64))\n\n(define (bvpointer?)\n  (bitvector (target-pointer-bitwidth)))\n\n(define (bvpointer x)\n  (bv x (target-pointer-bitwidth)))\n\n(define (mcell-init! mblock name [domain null])\n  ; name should be unique, though we use define-symbolc*\n  ; to make a unique name just to be safe\n  (define-symbolic* mcell boolean?)\n  (define sid (append name (list mcell)))\n  ; convert from bytes to bits\n  (define range (bitvector (* 8 (mcell-size mblock))))\n  (define f (if (empty? domain)\n                (lambda () (constant sid range))\n                (constant sid (apply ~> (append domain (list range))))))\n  (set-mcell-func! mblock f))\n\n(define (mcell-fini! mblock)\n  (set-mcell-free! mblock #t))\n\n; returns a pair (offset, size) in the end for load/store to\n; extract a smaller value\n(define (mcell-path mblock offset size)\n  (define block-size (bvpointer (mblock-size mblock)))\n  ; block size must be a multiple of size - this check should be constant\n  (bug-on (! (bvzero? (bvurem block-size size)))\n          #:msg (format \"mcell-path: block size ~a must be a multiple of size ~a\n\" block-size size))\n  ; offset must be a multiple of size\n  (bug-on (! (bvzero? (bvurem offset size)))\n          #:msg (format \"mcell-path: offset ~a must be a multiple of size ~a\n\" offset size))\n  ; offset must be smaller than block size\n  (bug-on (! (bvult offset block-size))\n          #:msg (format \"mcell-path: offset ~a must be smaller than block size ~a\n\" offset block-size))\n  (cons offset size))\n\n(define (mcell-resolve mblock path [indices null])\n  (if (empty? path)\n      ; old-style path - insert extra offset and size\n      (list mblock (bvpointer 0) (bvpointer (mblock-size mblock)) indices)\n      ; new-style path - (offset, size) is the last element\n      (list mblock (car path) (cdr path) indices)))\n\n(define (mcell-load mblock offset size indices)\n  (bug-on (mcell-free mblock) #:msg \"mcell-load: use after free\n\")\n  (define f (mcell-func mblock))\n  (apply f indices))\n\n(define (mcell-store! mblock value offset indices)\n  (bug-on (mcell-free mblock) #:msg \"mcell-store!: use after free\n\")\n  (define oldf (mcell-func mblock))\n  (define newf (lambda args\n                 (if (andmap equal? args indices) value (apply oldf args))))\n  (set-mcell-func! mblock newf))\n\n(define (mcell-memset! mblock c offset size [preds null])\n  (bug-on (! (bvzero? offset))\n          #:msg \"mcell-memset!: offset non-zero\")\n  (bug-on (! (equal? (bv-size c) 8))\n          #:msg \"mcell-memset!: not (bitvector 8)\")\n  ; not required: just leave it here for sanity checks\n  (bug-on (! (bvzero? c))\n          #:msg \"mcell-memset!: must be 0\")\n  (unless (bvzero? size)\n    (bug-on (! (equal? size (bvpointer (mcell-size mblock))))\n            #:msg \"mcell-memset!: size incorrect\")\n    (define value (apply concat (make-list (mcell-size mblock) c)))\n    (define oldf (mcell-func mblock))\n    (define newf (lambda args\n                   (if (andmap (lambda (f x) (f x)) preds args)\n                       value\n                       (apply oldf args))))\n    (set-mcell-func! mblock newf)))\n\n(define (mcell-copy mblock)\n  (define c (mcell (mcell-size mblock)))\n  (set-mcell-func! c (mcell-func mblock))\n  (set-mcell-free! c (mcell-free mblock))\n  c)\n\n; free is used only by stack memory; it is set to #t when the lifetime ends.\n(struct mcell (size [func #:auto #:mutable] [free #:auto #:mutable]) #:transparent\n  #:methods gen:mblock\n  [(define (mblock-size mblock) (mcell-size mblock))\n   (define mblock-init! mcell-init!)\n   (define mblock-fini! mcell-fini!)\n   (define mblock-path mcell-path)\n   (define mblock-resolve mcell-resolve)\n   (define mblock-load mcell-load)\n   (define mblock-store! mcell-store!)\n   (define mblock-memset! mcell-memset!)\n   (define mblock-copy mcell-copy)])\n```"}]}
{"messages": [{"role": "system", "content": "You are the Rosette Maintainer AI, an expert in solver-aided memory modeling."}, {"role": "user", "content": "Given ELF symbols, how do I allocate mregions and resolve symbolic pointers back to their region?"}, {"role": "assistant", "content": "<think>\nRegions connect concrete base/end pairs to typed blocks. create-mregions initializes block instances for allowed symbol kinds and checks that globals fit. guess-mregion-from-addr peels symbolic bvadd trees to associate a pointer with a region, and mregion-inbounds? ensures [addr, addr+size) stay inside start/end. The solver hits these guards before any block-level constraint fires.\n</think>\n\n```racket\n#lang rosette\n\n(require \"mblock.rkt\" \"../debug.rkt\" \"manager.rkt\")\n\n; An mregion is an mblock with information about its\n; location in memory, since pointers are just integers\n(struct mregion (start end name block) #:transparent)\n\n(define (mregion-copy mr)\n  (struct-copy mregion mr\n    [block (mblock-copy (mregion-block mr))]))\n\n(define (create-mregions symbols globals)\n  (for/list ([entry symbols] #:when (member (list-ref entry 2) (list 'b 'B 'R)))\n    (match entry\n      [(list start end _ name)\n        (define block\n          (if (and (not (null? globals)) (hash-has-key? globals name))\n              ((hash-ref globals name))\n              (marray (- end start) (mcell 1))))\n        (bug-on (< end start) #:msg (format \"create-mregions: end < start: ~e\" name))\n        (bug-on (< (- end start) (mblock-size block)) #:msg \"create-mregions: not enough size for global\")\n        (mblock-init! block (list name))\n        (mregion start end name block)]\n      [_ (bug #:msg (format \"create-mregions: bad symbol format: ~e\" entry))])))\n\n; Find an symbol by its name\n(define (find-symbol-by-name ls name)\n  (findf (match-lambda [(list _ _ _ nm) (equal? nm name)]) ls))\n\n; Find an mregion by its name\n(define (find-mregion-by-name ls name)\n  (define result (findf (lambda (mr) (equal? name (mregion-name mr))) ls))\n  (bug-on (equal? result #f) #:msg (format \"find-mregion-by-name: No such mregion ~e\" name))\n  result)\n\n(define (find-block-by-name mregions name)\n  (mregion-block (find-mregion-by-name mregions name)))\n\n(define (find-mregion-by-addr ls addr)\n  (bug-on (term? addr) #:msg \"find-mregion-by-addr: symbolic addr\")\n  (findf (lambda (mr)\n    (&& (bvule (bvpointer (mregion-start mr)) addr)\n        (bvult addr (bvpointer (mregion-end mr)))))\n    ls))\n\n; Guess which mregion corressponds to a given address.\n(define (guess-mregion-from-addr ls addr off)\n  (match addr\n\n    ; If it's a constant, we don't know where it could point\n    [(constant _ _) #f]\n\n    ; If it's an expression, unpack both and see what happens\n    [(expression (== bvadd) x y)\n      (let ([xm (guess-mregion-from-addr ls x off)])\n        (if xm xm\n          (let ([ym (guess-mregion-from-addr ls y off)])\n            (if ym ym #f))))]\n\n    ; Any term not caught above (including shift)\n    [(term _ _ ) #f]\n\n    [(? bv? literal)\n      (let ([x (find-mregion-by-addr ls (bvadd (sign-extend off (bitvector (target-pointer-bitwidth))) literal))])\n        (if x x\n          (find-mregion-by-addr ls literal)))]\n\n    [_ (bug #:msg \"guess-mregion-from-addr: unknown term\")]))\n\n; check if [addr, add + size) falls in region mr\n(define (mregion-inbounds? mr addr size)\n  (&& (bvule (bvpointer (mregion-start mr)) addr)\n      (bvule addr (bvsub (bvpointer (mregion-end mr)) size))))\n\n; Find the first symbol that overlaps\n; with a previous symbol. Assume symbol names\n; are sorted by address by nm.\n(define (find-overlapping-symbol symbols)\n  (define (func symbols prevend)\n    (match symbols\n      [(cons (list start end _ name) syms)\n       (cond\n         ; ignore empty entries\n         [(equal? start end) (func syms prevend)]\n         ; overlap\n         [(< start prevend) name]\n         ; continue\n         [else (func syms end)])]\n      [_ #f]))\n\n  (func symbols 0))\n```"}]}
{"messages": [{"role": "system", "content": "You are the Rosette Maintainer AI, an expert in solver-aided memory modeling."}, {"role": "user", "content": "How can I hook Serval's typed bitvector memory manager so loads and stores walk regions and blocks correctly?"}, {"role": "assistant", "content": "<think>\nThe typed-bv manager projects a pointer plus access offset into its owning region via guess-mregion-from-addr, subtracts the concrete base to obtain a block-relative offset, and checks mregion-inbounds? before resolving the mblock path. Loads and stores then funnel through mblock-iload and mblock-istore!, which are the solver-visible heap operations.\n</think>\n\n```racket\n#lang rosette\n\n; Typed memory manager with bitvector pointers.\n; Memory is divided into a set of disjoint regions of concrete base and size.\n\n(require \"mblock.rkt\" \"mregion.rkt\" \"manager.rkt\" \"../debug.rkt\" \"../bvarith.rkt\")\n\n(define (get-block-and-path memmgr addr off size)\n  (define regions (typed-bv-memmgr-regions memmgr))\n\n  (define mr (guess-mregion-from-addr regions addr off))\n\n  (define start (mregion-start mr))\n  (define end (mregion-end mr))\n  (define name (mregion-name mr))\n  (define block (mregion-block mr))\n\n  (set! addr (bvadd addr off))\n\n  (define offset (bvsub addr (integer->bitvector start (type-of addr))))\n  (bug-on (! (mregion-inbounds? mr addr size))\n\n              #:msg (format \"get-block-and-path: address out of range:\n addr: ~e\n block: ~e\" addr name))\n\n  (define path (mblock-path block offset size))\n  (values block path offset))\n\n(define (typed-bv-memmgr-memset! memmgr addr value len)\n  (define mregion (guess-mregion-from-addr (typed-bv-memmgr-regions memmgr) addr (bv 0 12)))\n  (bug-on (eq? mregion #f) #:msg \"typed-bv-memmgr-memset!: failed to guess mregion\")\n\n  (bug-on (! (mregion-inbounds? mregion addr len))\n    #:msg \"typed-bv-memmgr-memset!: address out of range\")\n\n  (define offset (bvsub addr (integer->bitvector (mregion-start mregion) (type-of addr))))\n\n  (when (! (bvzero? len))\n    (mblock-memset! (mregion-block mregion) value offset len)))\n\n(define (typed-bv-memmgr-alloc! memmgr size alignment proc)\n  (bug #:msg \"typed-bv memory manager cannot allocate memory!\"))\n\n(define (typed-bv-memmgr-load memmgr addr off size)\n  (define-values (block path offset) (get-block-and-path memmgr addr off size))\n  (mblock-iload block path))\n\n(define (typed-bv-memmgr-store! memmgr addr off data size)\n  (define-values (block path offset) (get-block-and-path memmgr addr off size))\n  (mblock-istore! block data path))\n\n(define (make-typed-bv-memmgr symbols globals)\n  (typed-bv-memmgr (create-mregions symbols globals)))\n\n(struct typed-bv-memmgr (regions) #:transparent #:mutable\n  #:methods gen:memmgr\n  [(define memmgr-alloc! typed-bv-memmgr-alloc!)\n   (define memmgr-load typed-bv-memmgr-load)\n   (define memmgr-store! typed-bv-memmgr-store!)\n   (define memmgr-memset! typed-bv-memmgr-memset!)\n   (define (memmgr-bitwidth b) (target-pointer-bitwidth))\n   (define memmgr-invariants (lambda (mm) #t))])\n\n(provide\n  make-typed-bv-memmgr\n  (struct-out typed-bv-memmgr))\n```"}]}
{"messages": [{"role": "system", "content": "You are the Rosette Maintainer AI, an expert in solver-aided memory modeling."}, {"role": "user", "content": "I need the flat little-endian memory manager example that stores each byte via an uninterpreted function."}, {"role": "assistant", "content": "<think>\nThe flat manager keeps memory as a single UF from pointer bitvectors to bytes. check-addr-off ensures addr+off stays in the configured pointer bitwidth, flat-memmgr-store! rewrites the UF byte-by-byte with little-endian slices of the written data, and flat-memmgr-load concatenates those bytes in reverse order to rebuild the multi-byte read. The solver only sees that one UF across every load/store.\n</think>\n\n```racket\n#lang rosette\n\n; Flat memory model. Assumes Little endian.\n; Memory is a single uninterpreted function from bv -> bv8\n\n(provide make-flat-memmgr (struct-out flat-memmgr))\n\n(require \"manager.rkt\" \"../bvarith.rkt\" \"../uf.rkt\" \"../debug.rkt\")\n\n(define (check-addr-off addr off)\n  (bug-on (! (equal? (bv-size (bvadd addr off)) (target-pointer-bitwidth)))\n          #:msg \"flat memory model: addr size wrong\"))\n\n(define (flat-memmgr-store! memmgr addr off data size)\n  (define N (bitvector->natural size))\n  (check-addr-off addr off)\n  (for ([i (in-range N)])\n    (define oldf (flat-memmgr-memory memmgr))\n    (define newf (lambda (p)\n      (if (equal? p (bvadd addr off (bv i (type-of addr))))\n        (extract (- (* 8 (+ i 1)) 1) (* 8 i) data)\n        (oldf p))))\n    (set-flat-memmgr-memory! memmgr newf)))\n\n(define (flat-memmgr-load memmgr addr off size)\n  (define N (bitvector->natural size))\n  (check-addr-off addr off)\n  (define Bytes (for/list ([i (in-range N)])\n    ((flat-memmgr-memory memmgr) (bvadd addr off (bv i (type-of addr))))))\n\n  (apply concat (reverse Bytes)))\n\n(define (make-flat-memmgr #:bitwidth [bitwidth #f])\n  (when (equal? bitwidth #f)\n    (set! bitwidth (target-pointer-bitwidth)))\n\n  (define-symbolic* memory (~> (bitvector (target-pointer-bitwidth))\n                               (bitvector 8)))\n  (flat-memmgr memory bitwidth))\n\n(struct flat-memmgr (memory bitwidth) #:transparent #:mutable\n  #:methods gen:memmgr\n  [(define memmgr-load flat-memmgr-load)\n   (define memmgr-store! flat-memmgr-store!)\n   (define (memmgr-bitwidth m) (flat-memmgr-bitwidth m))\n   (define memmgr-invariants (lambda (mm) #t))])\n```"}]}
