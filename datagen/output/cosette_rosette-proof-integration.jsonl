{"messages":[{"role":"system","content":"You are the Cosette Rosette Engineer, expert in integrated proof workflows."},{"role":"user","content":"Demonstrate how to combine bounded symmetry breaking with bag equality when checking two Cosette queries."},{"role":"assistant","content":"<think>\nEquivalence goal: enforce bag equality between both query denotations using multiplicity-normalized tables. Symmetry strategy: `go-break-symmetry-bounded` seeds each query with `init-forall-eq-constraint`, iterates `big-step`, then `merge-forall-eq` to tie equivalent schemas before solving. Constraints and domain pruning: the merged `forall-eq` disjunctions bind each column ref to a symbolic representative, so the subsequent `bag-equal` can only inspect canonical tuple lists. Solver interaction: after asserting these SBP constraints, the solver either proves the bags are equal or returns a counterexample table that still respects the merged constraints.\n</think>\n\n```racket\n(define (get-multiplicity r0 table)\n  (foldl (lambda (r m) \n           (if (equal? (car r) (car r0)) (+ m (cdr r)) m))\n         0\n         table))\n\n(define (table-sum table)\n  (for/all ([table table])\n           (map (lambda (t) (cons (car t) (get-multiplicity t table))) table)))\n\n(define (element-contain t l)\n  (cond\n    [(eq? (cdr t) 0) #t]\n    [(empty? l) #f]\n    [else (or (equal? t (first l)) (element-contain t (rest l)))]))\n\n(define (contain l1 l2)\n  (cond\n    [(empty? l1) #t]\n    [else (and (element-contain (first l1) l2) (contain (rest l1) l2))]\n    ))\n\n(define (bag-equal table1 table2)\n  (let* ([l1 (table-sum table1)]\n         [l2 (table-sum table2)])\n      (and (contain l1 l2) (contain l2 l1))))\n\n(define (go-break-symmetry-bounded q1 q2)\n  (let* ([c1 (big-step (init-forall-eq-constraint q1) 20)]\n         [c2 (big-step (init-forall-eq-constraint q2) 20)]\n         [flat-constr (flatten (list c1 c2))])\n   (merge-forall-eq flat-constr)))\n\n(define (init-forall-eq-constraint query)\n  ; initialize a the constraint for symmetry breaking\n  (forall-eq query\n             (c-conj (build-list (length (extract-schema query)) \n                                 (lambda (x) (c-primitive (v-ref x) = (v-symval x)))))))\n\n(define (big-step mconstr fuel)\n  ; big-step semantics for constraint propogation,\n  ; fuel is supposed to be greater or equal than depth of the ast\n  (cond\n    [(eq? fuel 0) mconstr]\n    [(forall-eq? mconstr) (big-step (small-step-forall-eq mconstr) (- fuel 1))]\n    [(sum-eq? mconstr) (big-step (small-step-sum-eq mconstr 0) (- fuel 1))]\n    [(list? mconstr) (map (lambda (mc) (big-step mc fuel)) mconstr)]))\n\n(define (constr-flatten v)\n  ; flattening nested conjunctions into one single conjunction\n  (cond\n    [(list? v) (map (lambda (x) (constr-flatten x)) v)]\n    [(forall-eq? v) (forall-eq (forall-eq-query v) (constr-flatten (forall-eq-constr v)))]\n    [(sum-eq? v) (sum-eq (sum-eq-queries v) (constr-flatten (sum-eq-constr v)))]\n    [(c-conj? v)\n     (let ([content (map (lambda (c) (let ([x (constr-flatten c)])\n                                       (if (c-conj? x) (c-conj-preds x) x))) \n                         (c-conj-preds v))])\n       (c-conj (flatten content)))]\n    [else v]))\n\n(define (merge-forall-eq raw-constraints)\n  ; merging constraints\n  (let ([constraints (constr-flatten raw-constraints)])\n    (cond [(empty? constraints) (list)]\n          [else (let* ([q (forall-eq-query (car constraints))]\n                       [t-constrs (filter (lambda (c) (eq? q (forall-eq-query c))) constraints)]\n                       [cores (map (lambda (c) (forall-eq-constr c)) t-constrs)]\n                       [rest-constrs (filter (lambda (c) (not (eq? q (forall-eq-query c)))) \n                                             (cdr constraints))])\n                  (append (list (forall-eq q (c-disj cores)))\n                          (merge-forall-eq rest-constrs)))])))\n```"}]}
{"messages":[{"role":"system","content":"You are the Cosette Rosette Engineer, expert in integrated proof workflows."},{"role":"user","content":"I want the symmetry break to intersect both query constraints before the bag-equality verdict. Show the Rosette code involved."},{"role":"assistant","content":"<think>\nEquivalence goal: certify that both query denotations produce identical bags once tuple multiplicities are normalized. Symmetry strategy: `go-break-symmetry-bounded-intersect` runs each query through `init-forall-eq-constraint`/`big-step`, flattens the constraint trees, and hands them to `merge-forall-eq-intersect` so only shared canonical representatives remain. Constraints and domain pruning: the auto-intersection keeps just the predicates satisfied by both queries, so any tuple that reaches `bag-equal` must respect both naming/ordering invariants. Solver interaction: with the intersected SBP applied, the solver either confirms `bag-equal` or emits a counterexample that simultaneously satisfies the merged symmetry clauses.\n</think>\n\n```racket\n(define (get-multiplicity r0 table)\n  (foldl (lambda (r m) \n           (if (equal? (car r) (car r0)) (+ m (cdr r)) m))\n         0\n         table))\n\n(define (table-sum table)\n  (for/all ([table table])\n           (map (lambda (t) (cons (car t) (get-multiplicity t table))) table)))\n\n(define (element-contain t l)\n  (cond\n    [(eq? (cdr t) 0) #t]\n    [(empty? l) #f]\n    [else (or (equal? t (first l)) (element-contain t (rest l)))]))\n\n(define (contain l1 l2)\n  (cond\n    [(empty? l1) #t]\n    [else (and (element-contain (first l1) l2) (contain (rest l1) l2))]\n    ))\n\n(define (bag-equal table1 table2)\n  (let* ([l1 (table-sum table1)]\n         [l2 (table-sum table2)])\n      (and (contain l1 l2) (contain l2 l1))))\n\n(define (go-break-symmetry-bounded-intersect q1 q2)\n  ; perform an intersection to reduce \n  (let* ([c1 (big-step (init-forall-eq-constraint q1) 20)]\n         [c2 (big-step (init-forall-eq-constraint q2) 20)]\n         [flat-constr (flatten (list c1 c2))])\n   (merge-forall-eq-intersect flat-constr)))\n\n(define (init-forall-eq-constraint query)\n  ; initialize a the constraint for symmetry breaking\n  (forall-eq query\n             (c-conj (build-list (length (extract-schema query)) \n                                 (lambda (x) (c-primitive (v-ref x) = (v-symval x)))))))\n\n(define (big-step mconstr fuel)\n  ; big-step semantics for constraint propogation,\n  ; fuel is supposed to be greater or equal than depth of the ast\n  (cond\n    [(eq? fuel 0) mconstr]\n    [(forall-eq? mconstr) (big-step (small-step-forall-eq mconstr) (- fuel 1))]\n    [(sum-eq? mconstr) (big-step (small-step-sum-eq mconstr 0) (- fuel 1))]\n    [(list? mconstr) (map (lambda (mc) (big-step mc fuel)) mconstr)]))\n\n(define (constr-flatten v)\n  ; flattening nested conjunctions into one single conjunction\n  (cond\n    [(list? v) (map (lambda (x) (constr-flatten x)) v)]\n    [(forall-eq? v) (forall-eq (forall-eq-query v) (constr-flatten (forall-eq-constr v)))]\n    [(sum-eq? v) (sum-eq (sum-eq-queries v) (constr-flatten (sum-eq-constr v)))]\n    [(c-conj? v)\n     (let ([content (map (lambda (c) (let ([x (constr-flatten c)])\n                                       (if (c-conj? x) (c-conj-preds x) x))) \n                         (c-conj-preds v))])\n       (c-conj (flatten content)))]\n    [else v]))\n\n(define (merge-forall-eq-intersect raw-constraints)\n  ; merging constraints \n  (define (auto-set-intersect lists)\n    ; the helper function to do intersects among lists\n    (cond [(empty? lists) (list)]\n          [(eq? (length lists) 1) (car lists)]\n          [else (set-intersect (car lists) (auto-set-intersect (cdr lists)))]))\n  (let ([constraints (constr-flatten raw-constraints)])\n    (cond [(empty? constraints) (list)]\n          [else (let* ([q (forall-eq-query (car constraints))]\n                       [t-constrs (filter (lambda (c) (eq? q (forall-eq-query c))) constraints)]\n                       [cores (map (lambda (c) \n                                     (let ([x (forall-eq-constr c)])\n                                       (if (c-conj? x) (c-conj-preds x) (list x)))) t-constrs)]\n                       [rest-constrs (filter (lambda (c) (not (eq? q (forall-eq-query c)))) \n                                             (cdr constraints))])\n                  (append (list (forall-eq q (c-conj (auto-set-intersect cores))))\n                          (merge-forall-eq-intersect rest-constrs)))])))\n```"}]}"}
{"messages":[{"role":"system","content":"You are the Cosette Rosette Engineer, expert in integrated proof workflows."},{"role":"user","content":"Show the Rosette pieces that propagate SELECT/JOIN symmetry constraints before enforcing bag equality."},{"role":"assistant","content":"<think>\nEquivalence goal: the solver must prove both query denotations produce the same multiset, so we normalize outputs with `bag-equal`. Symmetry strategy: `small-step-forall-eq` recursively rewrites SELECT, DISTINCT, JOIN, and UNION nodes so each subquery inherits the correct constraint context, using helpers like `remove-constr-if-val`, `c-from-sql-filter`, and `subst-v-ref` to keep references in range. Constraints and domain pruning: by trimming out-of-range refs and aggregations, only canonical tuple representatives survive, narrowing the search space that `bag-equal` inspects. Solver interaction: once these refined constraints are asserted, the bag-equality check either succeeds or reports a counterexample consistent with every propagated `forall-eq`.\n</think>\n\n```racket\n(define (get-multiplicity r0 table)\n  (foldl (lambda (r m) \n           (if (equal? (car r) (car r0)) (+ m (cdr r)) m))\n         0\n         table))\n\n(define (table-sum table)\n  (for/all ([table table])\n           (map (lambda (t) (cons (car t) (get-multiplicity t table))) table)))\n\n(define (element-contain t l)\n  (cond\n    [(eq? (cdr t) 0) #t]\n    [(empty? l) #f]\n    [else (or (equal? t (first l)) (element-contain t (rest l)))]))\n\n(define (contain l1 l2)\n  (cond\n    [(empty? l1) #t]\n    [else (and (element-contain (first l1) l2) (contain (rest l1) l2))]\n    ))\n\n(define (bag-equal table1 table2)\n  (let* ([l1 (table-sum table1)]\n         [l2 (table-sum table2)])\n      (and (contain l1 l2) (contain l2 l1))))\n\n(define (small-step-forall-eq mconstr)\n  ; small step semantics for propogating forall-eq constraints\n  (let* ([query (forall-eq-query mconstr)]\n         [schema-size (length (extract-schema query))])\n    (cond \n      [(query-named? query) mconstr] ; do nothing\n      [(query-select? query)\n       (let* ([inner-q (query-select-from-query query)]\n              [sel-args (query-select-select-args query)]\n              [sel-pred (query-select-where-filter query)]\n              [inner-q-schema (extract-schema inner-q)]\n              [inner-q-schema-size (length (extract-schema inner-q))]\n              [inner-q-name-hash (list->hash inner-q-schema)]\n              [ref-map (map (lambda (v) (v-from-sql-val v inner-q-name-hash)) sel-args)])\n         (forall-eq \n           inner-q\n           (c-conj (list (subst-v-ref (forall-eq-constr mconstr) ref-map) \n                         (c-from-sql-filter sel-pred inner-q-name-hash)))))]\n      [(query-aggr-general? query)\n       (let* ([sel-args (query-aggr-general-select-args query)]\n              [where-pred (query-aggr-general-where-filter query)]\n              [having-pred (query-aggr-general-having-filter query)]\n              [gb-fields (query-aggr-general-gb-fields query)]\n              [inner-q (query-aggr-general-query query)]\n              [inner-q-schema (extract-schema inner-q)]\n              [inner-q-name-hash (list->hash inner-q-schema)]\n              [ref-map (map (lambda (v) (v-from-sql-val v inner-q-name-hash)) sel-args)]\n              [core-constr (c-conj (list (subst-v-ref (forall-eq-constr mconstr) ref-map) \n                                         (c-from-sql-filter having-pred inner-q-name-hash)\n                                         (c-from-sql-filter where-pred inner-q-name-hash)))])\n         ; loosing constraints by removing those involving aggregation functions\n         (forall-eq inner-q (remove-constr-if-val core-constr contain-aggr-uexpr)))]\n      [(query-select-distinct? query)\n       (let* ([inner-q (query-select-distinct-from-query query)]\n              [sel-args (query-select-distinct-select-args query)]\n              [sel-pred (query-select-distinct-where-filter query)]\n              [inner-q-schema (extract-schema inner-q)]\n              [inner-q-schema-size (length (extract-schema inner-q))]\n              [inner-q-name-hash (list->hash inner-q-schema)]\n              [ref-map (map (lambda (v) (v-from-sql-val v inner-q-name-hash)) sel-args)])\n         (forall-eq \n           inner-q\n           (c-conj (list (subst-v-ref (forall-eq-constr mconstr) ref-map) \n                         (c-from-sql-filter sel-pred inner-q-name-hash)))))]\n      [(query-left-outer-join? query)\n       (let* ([q1 (query-left-outer-join-query1 query)]\n              [q2 (query-left-outer-join-query2 query)]\n              [pred (query-left-outer-join-pred query)]\n              [q1-schema-size (length (extract-schema q1))]\n              [q1-ref-indexes (build-list q1-schema-size values)]\n              [q2-schema-size (length (extract-schema q2))]\n              [q2-ref-indexes (build-list q2-schema-size (lambda (x) (+ x q1-schema-size)))]\n              ; don't forget to update ref indexes for q2\n              [q2-ref-update-map (map (lambda (x) (v-ref x))\n                                      (append (build-list q1-schema-size values) \n                                              (build-list q2-schema-size values)))])\n         (list (forall-eq q1 (remove-constr-if-val\n                               (forall-eq-constr mconstr) \n                               (lambda (x) (contain-out-of-range-v-ref x q1-ref-indexes))))\n               (forall-eq q2 (subst-v-ref\n                               (remove-constr-if-val \n                                 (forall-eq-constr mconstr)\n                                 (lambda (x) (contain-out-of-range-v-ref x q2-ref-indexes)))\n                               q2-ref-update-map)))]\n      [(query-join? query)\n       (let* ([q1 (query-join-query1 query)]\n              [q2 (query-join-query2 query)]\n              [q1-schema-size (length (extract-schema q1))]\n              [q1-ref-indexes (build-list q1-schema-size values)]\n              [q2-schema-size (length (extract-schema q2))]\n              [q2-ref-indexes (build-list q2-schema-size (lambda (x) (+ x q1-schema-size)))]\n              ; don't forget to update ref indexes for q2\n              [q2-ref-update-map (map (lambda (x) (v-ref x))\n                                      (append (build-list q1-schema-size values) \n                                              (build-list q2-schema-size values)))])\n         (list (forall-eq q1 (remove-constr-if-val \n                               (forall-eq-constr mconstr) \n                               (lambda (x) (contain-out-of-range-v-ref x q1-ref-indexes))))\n               (forall-eq q2 (subst-v-ref\n                               (remove-constr-if-val \n                                 (forall-eq-constr mconstr)\n                                 (lambda (x) (contain-out-of-range-v-ref x q2-ref-indexes)))\n                               q2-ref-update-map)))]\n      [(or (query-rename-full? query) (query-rename? query))\n       (let* ([q (cond [(query-rename-full? query) (query-rename-full-query query)]\n                       [(query-rename? query) (query-rename-query query)])])\n         (forall-eq q (forall-eq-constr mconstr)))]\n      [(query-union-all? query)\n       (let* ([q1 (query-union-all-query1 query)]\n              [q2 (query-union-all-query2 query)])\n         (list\n           (forall-eq q1 (forall-eq-constr mconstr))\n           (forall-eq q2 (forall-eq-constr mconstr))))]\n      )))\n\n(define (remove-constr-if-val constr f)\n  ; substitutes primitive constraints with (c-true) if any of its value\n  ; satisfies the condition specify function f, typed (f::val->bool) \n  (cond\n    [(c-primitive? constr)\n     (if (or (f (c-primitive-left constr)) (f (c-primitive-right constr)))\n       (c-true) ; the primitive pred contains some value satisfying function f\n       constr)]\n    [(c-true? constr) constr]\n    [(c-false? constr) constr]\n    [(c-conj? constr) \n     (let ([filtered-content \n             (filter (lambda (c) (not (c-true? c))) \n                     (map (lambda (x) (remove-constr-if-val x f)) \n                          (c-conj-preds constr)))])\n       (if (empty? filtered-content) (c-true) (c-conj filtered-content)))]\n    [(c-disj? constr) \n     (let ([filtered-content \n             (filter (lambda (c) (not (c-true? c))) \n                     (map (lambda (x) (remove-constr-if-val x f)) \n                          (c-disj-preds constr)))])\n       (if (empty? filtered-content) (c-true) (c-disj filtered-content)))]\n    [(c-neg? constr) \n     (if (remove-constr-if-val (c-neg-pred constr) f)\n       (c-true)\n       constr)]))\n\n(define (contain-out-of-range-v-ref v ref-indexes)\n  ;; check if the value contain a reference that is outside \n  ;; the range provided by the list ref-indexes\n  (cond \n    [(v-uexpr? v) (contain-out-of-range-v-ref (v-uexpr-v v) ref-indexes)]\n    [(v-bexpr? v) (or (contain-out-of-range-v-ref (v-bexpr-v1 v) ref-indexes)\n                      (contain-out-of-range-v-ref (v-bexpr-v2 v) ref-indexes))]\n    [(v-ref? v) (not (index-of ref-indexes (v-ref-id v)))]\n    [else #f]))\n\n(define (contain-aggr-uexpr v)\n  ;; check whether a value contains aggregation function\n  (cond \n    [(v-uexpr? v) (is-aggr-func? (v-uexpr-op v))]\n    [(v-bexpr? v) (or (contain-aggr-uexpr (v-bexpr-v1 v))\n                      (contain-aggr-uexpr (v-bexpr-v2 v)))]\n    [else #f]))\n\n(define (v-from-sql-val v vmap) \n  ; convert sql val expr into meta v expr:\n  ; generate a meta constraint v expr from a vmap\n  ; vmap maps each column-ref primitive into a v-ref that uses the row id\n  (cond\n    [(val-const? v) (v-const (val-const-val v))]\n    [(val-column-ref? v) (v-ref (hash-ref vmap (val-column-ref-column-name v)))]\n    [(val-uexpr? v) (v-uexpr (val-uexpr-op v) (v-from-sql-val (val-uexpr-val v) vmap))]\n    [(val-bexpr? v) (v-bexpr (val-bexpr-binop v) \n                             (v-from-sql-val (val-bexpr-v1 v) vmap) \n                             (v-from-sql-val (val-bexpr-v2 v) vmap))]))\n\n(define (c-from-sql-filter f vmap)\n  ; generate a meta constraint v expr from a vmap\n  ; vmap maps each column-ref primitive into a v-ref that uses the row id\n  (cond \n    [(filter-binop? f) (c-primitive (v-from-sql-val (filter-binop-val1 f) vmap)\n                                    (filter-binop-op f) \n                                    (v-from-sql-val (filter-binop-val2 f) vmap))]\n    [(filter-conj? f) (c-conj (list (c-from-sql-filter (filter-conj-f1 f) vmap)\n                                    (c-from-sql-filter (filter-conj-f2 f) vmap)))]\n    [(filter-disj? f) (c-disj (list (c-from-sql-filter (filter-disj-f1 f) vmap)\n                                    (c-from-sql-filter (filter-disj-f2 f) vmap)))]\n    [(filter-not? f) (c-neg (c-from-sql-filter (filter-not-f1 f) vmap))]\n    [(filter-true? f) (c-true)]\n    [(filter-false? f) (c-false)] ; currently not supporting n-nary filter operation\n    ))\n\n(define (subst-v-ref v ref-map)\n  ; subst values in the constriant based on ref-map \n  (cond\n    [(forall-eq? v) (forall-eq (subst-v-ref (forall-eq-constr v) ref-map))]\n    [(sum-eq? v) (sum-eq (sum-eq-queries v) \n                         (subst-v-ref (sum-eq-constr v) ref-map))]\n    [(c-primitive? v)\n     (c-primitive (subst-v-ref (c-primitive-left v) ref-map) \n                  (c-primitive-op v) \n                  (subst-v-ref (c-primitive-right v) ref-map))]\n    [(c-true? v) v]\n    [(c-false? v) v]\n    [(c-conj? v) (c-conj (map (lambda (x) (subst-v-ref x ref-map)) (c-conj-preds v)))]\n    [(c-disj? v) (c-disj (map (lambda (x) (subst-v-ref x ref-map)) (c-disj-preds v)))]\n    [(c-neg? v) (c-neg (subst-v-ref (c-neg-pred v) ref-map))]\n    [(v-const? v) v]\n    [(v-uexpr? v) (v-uexpr (v-uexpr-op v) (subst-v-ref (v-uexpr-v v) ref-map))]\n    [(v-bexpr? v) (v-bexpr (subst-v-ref (v-bexpr-v1 v) ref-map) \n                           (v-bexpr-op v) \n                           (subst-v-ref (v-bexpr-v2 v) ref-map))]\n    [(v-ref? v) (list-ref ref-map (v-ref-id v))]\n    [(v-symval? v) v]\n    [else v]))\n```"}]}
{"messages":[{"role":"system","content":"You are the Cosette Rosette Engineer, expert in integrated proof workflows."},{"role":"user","content":"Before I call bag equality, I need to strip unused symbolic constraints from the symmetry result. Can you show that flow?"},{"role":"assistant","content":"<think>\nEquivalence goal: we still certify that both queries return the same multiset via `bag-equal`, so we have to normalize multiplicities. Symmetry strategy: after generating meta-constraints, we prune them with `extract-v-sym` and `remove-unused-constr` so the solver only keeps predicates that relate actual symbolic cells to constants. Constraints and domain pruning: by collapsing primitives that compare dead symbolic ids to constants into `c-true`, we shrink the constraint set that guards `bag-equal`, preventing spurious blockers. Solver interaction: once cleansed, the remaining constraints are asserted alongside the bag-equality assertion; if a witness exists it must satisfy the trimmed symmetry clauses, otherwise the solver proves the bags equal.\n</think>\n\n```racket\n(define (get-multiplicity r0 table)\n  (foldl (lambda (r m) \n           (if (equal? (car r) (car r0)) (+ m (cdr r)) m))\n         0\n         table))\n\n(define (table-sum table)\n  (for/all ([table table])\n           (map (lambda (t) (cons (car t) (get-multiplicity t table))) table)))\n\n(define (element-contain t l)\n  (cond\n    [(eq? (cdr t) 0) #t]\n    [(empty? l) #f]\n    [else (or (equal? t (first l)) (element-contain t (rest l)))]))\n\n(define (contain l1 l2)\n  (cond\n    [(empty? l1) #t]\n    [else (and (element-contain (first l1) l2) (contain (rest l1) l2))]\n    ))\n\n(define (bag-equal table1 table2)\n  (let* ([l1 (table-sum table1)]\n         [l2 (table-sum table2)])\n      (and (contain l1 l2) (contain l2 l1))))\n\n(define (extract-v-sym v)\n  (cond\n    [(list? v) (flatten (map (lambda (x) (extract-v-sym x)) v))]\n    [(forall-eq? v) (extract-v-sym (forall-eq-constr v))]\n    [(sum-eq? v) (extract-v-sym (sum-eq-constr v))]\n    [(c-primitive? v) (append (extract-v-sym (c-primitive-left v)) \n                              (extract-v-sym (c-primitive-right v)))]\n    [(c-true? v) (list)]\n    [(c-false? v) (list)]\n    [(c-conj? v) (flatten (map (lambda (x) (extract-v-sym x)) (c-conj-preds v)))]\n    [(c-disj? v) (flatten (map (lambda (x) (extract-v-sym x)) (c-disj-preds v)))]\n    [(c-neg? v) (extract-v-sym (c-neg-pred v))]\n    [(v-const? v) (list)]\n    [(v-uexpr? v) (extract-v-sym (v-uexpr-v v))]\n    [(v-bexpr? v) (append (extract-v-sym (v-bexpr-v1 v)) \n                          (extract-v-sym (v-bexpr-v2 v)))]\n    [(v-ref? v) (list)]\n    [(v-symval? v) (list v)]))\n\n(define (remove-unused-constr v)\n  (cond\n    [(list? v) (map (lambda (x) (remove-unused-constr x)) v)]\n    [(forall-eq? v) (forall-eq (forall-eq-query v) (remove-unused-constr (forall-eq-constr v)))]\n    [(sum-eq? v) (sum-eq (sum-eq-queries v) (remove-unused-constr (sum-eq-constr v)))]\n    [(c-primitive? v) \n     (if (or (and (v-symval? (c-primitive-left v)) (v-const? (c-primitive-right v)))\n             (and (v-symval? (c-primitive-right v)) (v-const? (c-primitive-left v))))\n         (c-true)\n         v)]\n    [(c-true? v) v]\n    [(c-false? v) v]\n    [(c-conj? v) (c-conj (map (lambda (x) (remove-unused-constr x)) (c-conj-preds v)))]\n    [(c-disj? v) (c-disj (map (lambda (x) (remove-unused-constr x)) (c-disj-preds v)))]\n    [(c-neg? v) (c-neg (remove-unused-constr (c-neg-pred v)))]\n    [(v-const? v) v]\n    [(v-uexpr? v) v]\n    [(v-bexpr? v) v]\n    [(v-ref? v) v]\n    [(v-symval? v) v]))\n```"}]}
