{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I want to trace Rosette exceptions but optionally skip user assertions or infeasible solver paths. Where should I hook that logic and how is the trace collected?"},{"role":"assistant","content":"<think>In the trace tool, `do-trace` establishes fresh trace/state and installs a custom reporter via `current-reporter`. The reporter inspects `failed` results, reads `vc-assumes`/`vc-asserts`, and checks `symbolic-trace-skip-assertion?` plus `symbolic-trace-skip-infeasible-solver?` using `query:solve` and `unsat?`. If the entry is not skipped, it builds a trace entry with continuation marks and sends it through the entry handler to accumulate `current-trace` and stats.</think>\n\n```racket\n(define-simple-macro (set+restore [var e {~optional e2}] ... #:body body ...)\n  (let ([restorer (thunk (set! var {~? e2 e}) ...)])\n    (set! var e) ...\n    (call-with-exception-handler\n     (λ (ex)\n       (restorer)\n       ex)\n     (thunk (begin0 (let () body ...) (restorer))))))\n\n(define symbolic-trace-skip-assertion? (make-parameter #f))\n(define symbolic-trace-skip-infeasible-solver? (make-parameter #f))\n\n(define current-entry-handler #f)\n\n(define stats-template '([assertion . 0] [solver . 0]))\n\n(define (do-trace proc #:entry-handler entry-handler #:post-proc post-proc)\n  (set+restore\n   [current-original-map (make-hash)]\n   [current-trace '()]\n   [current-stats (make-hash stats-template)]\n   [current-entry-handler entry-handler #f]\n   #:body\n   (parameterize ([current-reporter reporter])\n     (begin0 (proc)\n       (post-proc current-stats (reverse current-trace) current-original-map)))))\n\n;; trace -----------------------------------------------------------------------\n\n(define current-stats (make-hash stats-template))\n\n(define (collect-stats msg)\n  (hash-update! current-stats msg add1))\n\n(define current-trace '())\n\n(define reporter\n  (match-lambda*\n    [(list 'exception (failed e s))\n     (define assumes (vc-assumes s))\n     (define asserts (vc-asserts s))\n     (define skip?\n       (or (exn:fail:svm:merge? e)\n           ;; We skip exn:fail:svm:merge? because we already present data of\n           ;; leave nodes.\n           (false? assumes)\n           ;; Skip false? to make it match the old behavior. We can remove this\n           ;; or add an option to conditionally filter this later.\n           (and (and (symbolic-trace-skip-assertion?)\n                     (or (exn:fail:svm:assert:user? e)\n                         (exn:fail:svm:assume:user? e)))\n                (collect-stats 'assertion))\n           ;; TODO: need to fix the name. symbolic-trace-skip-assertion?\n           ;; doesn't make sense anymore\n           (and (and (symbolic-trace-skip-infeasible-solver?)\n                     (unsat? (query:solve (list assumes))))\n                (collect-stats 'solver))))\n     (unless skip?\n       (define entry\n         (list e\n               (continuation-mark-set-first\n                (exn-continuation-marks e)\n                'symbolic-trace:stx-key)\n               (continuation-mark-set->list\n                (exn-continuation-marks e)\n                'symbolic-trace:stack-key)\n               assumes))\n       (current-entry-handler\n        entry\n        (λ (e) (set! current-trace (cons e current-trace)))\n        current-original-map))]\n    [_ (void)]))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"How does the trace system remember original source forms so the report can blame the right syntax?"},{"role":"assistant","content":"<think>The trace tool keeps a hash of readable source locations to original syntax objects. `add-original-form!` computes a location from syntax and records the mapping in `current-original-map` so later entry formatting can recover a blaming form.</think>\n\n```racket\n(define current-original-map (make-hash))\n\n(define (add-original-form! loc-stx actual-stx)\n  (define loc (syntax->readable-location loc-stx))\n  (when (and (first loc) (second loc) (third loc))\n    (hash-set! current-original-map loc actual-stx)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I need to understand how symbolic trace instrumentation wraps applications and filters out Rosette internal procedures. Where is that logic?"},{"role":"assistant","content":"<think>The compiler instrumentation checks source paths to avoid non-exported Rosette internals and uses a heuristic for keyword-procedure applications. When a plain application qualifies, it wraps the call with continuation marks on `symbolic-trace:stack-key`, recording a certified/uncertified stack entry and then replays the application with the original arguments.</think>\n\n```racket\n(define (should-instrument-path? path)\n  (define the-path (path-string->string path))\n  (or (not the-path)\n      (not (or (string-contains? the-path "rosette/base/form/module.rkt")\n               (string-contains? the-path "rosette/base/form/control.rkt")\n               (string-contains? the-path "rosette/base/core/bool.rkt")\n               (string-contains? the-path "rosette/query/form.rkt")\n               (string-contains? the-path "rosette/query/core.rkt")))))\n\n(define original-files (mutable-set))\n(define (is-keyword-procedure-application? expr head)\n  ; Here are the rules:\n  ; - if `head` has an alias or converted args property, it must be a kw procedure application.\n  ;   return #t iff the source of that property is not in rosette/query/form.rkt.\n  ; - otherwise, it's a kw procedure application if the source of the expr is kw.rkt.\n  ;   - if `head` has a source, it must be an original file\n  ;   - if `head` has no source, assume it's a kw procedure application unless it's the\n  ;     `unpack` procedure generated by kw.rkt\n  (define source-property\n    (or (syntax-procedure-alias-property head)\n        (syntax-procedure-converted-arguments-property head)))\n  (cond\n    [source-property\n     (define src (syntax-source (if (pair? source-property) (car source-property) source-property)))\n     (should-instrument-path? src)]\n    [(and (syntax-source expr)\n          (string-contains? (path-string->string (syntax-source expr))\n                            "racket/private/kw.rkt"))\n     (if (syntax-source head)\n         (set-member? original-files (syntax-source head))\n         (let ([s (syntax->datum head)])\n           (or (not (symbol? s))\n               (not (string-prefix? (symbol->string s) "unpack")))))]\n    [else #f]))\n\n    [(#%plain-app head tail ...)\n     #:when (or (and (or (is-original? expr) (is-original? #'head))\n                     (should-instrument-path? (syntax-source #'head)))\n                (is-keyword-procedure-application? expr #'head))\n     #:with {~and stx (p-a head-2 tail-2 ...)}\n     (disarm (transform (cons #'head (attribute tail))))\n\n     (instrument-track\n      #`(let ([the-function head-2])\n          (call-with-immediate-continuation-mark\n           'symbolic-trace:stack-key\n           (λ (k)\n             (with-continuation-mark\n               'symbolic-trace:stack-key\n               (let ([entry (cons the-function '#,(syntax->readable-location #'stx))])\n                 (if k\n                     (list 'certified (#,second k) entry)\n                     (list 'uncertified entry entry)))\n               #,(datum->syntax #'stx\n                                (append (list #'p-a #'the-function)\n                                        (attribute tail-2))\n                                #'stx\n                                #'stx))))))]\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Where does the trace compiler hook into compilation, and how does it decide to instrument only rosette or rosette/safe modules?"},{"role":"assistant","content":"<think>The compile hook uses `trace-annotate` to expand modules and only instruments when `ok-lang?` says the base language is `rosette` or `rosette/safe` (unless the parameter disables the filter). `make-symbolic-trace-compile-handler` wraps the existing `current-compile` so any compilation runs through `trace-annotate`.</think>\n\n```racket\n(define (ok-lang? lang)\n  (or (not (symbolic-trace-rosette-only?))\n      (member lang '(rosette rosette/safe))))\n\n(define trace-annotate\n  (syntax-parser\n    [(mod:id _mod-id lang _module-begin)\n     #:when (and (free-identifier=? #'mod\n                                    (namespace-module-identifier)\n                                    (namespace-base-phase))\n                 (ok-lang? (syntax-e #'lang)))\n     (printf "INSTRUMENTING ~v\n" (syntax-source this-syntax))\n     (set-add! original-files (syntax-source this-syntax))\n     (define expanded-e (expand-syntax\n                         (collect-syntax\n                          (add-annotate-property this-syntax))))\n     (annotate-top expanded-e (namespace-base-phase))]\n    [_ this-syntax]))\n\n(define (make-symbolic-trace-compile-handler)\n  (define orig (current-compile))\n  (lambda (e immediate-eval?)\n    (orig (trace-annotate\n           (if (syntax? e)\n               e\n               (namespace-syntax-introduce\n                (datum->syntax #f e))))\n          immediate-eval?)))\n\n\n(define symbolic-trace-compile-handler\n  (make-symbolic-trace-compile-handler))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"How does the trace tool turn a captured exception and stack into the JSON payload for the report UI?"},{"role":"assistant","content":"<think>The trace runner normalizes source paths, converts stack frames to JSON-friendly hashes, and builds an `entry->json` record with exception message, context trace, optional blamed syntax (from `original-map`), and a summarized call stack. The helper functions keep paths stable and filter uncertified frames.</think>\n\n```racket\n(define-syntax-rule (when/null [x v] body ...)\n  (let ([x v])\n    (cond\n      [x body ...]\n      [else 'null])))\n\n(define cwd (path-string->string (current-directory)))\n\n(define (normalize-path-for-rosette p)\n  (define path (path-string->string p))\n  (if (string-prefix? path cwd)\n      (string-append "<cwd>/" (path-string->string (find-relative-path cwd path)))\n      path))\n\n(define (frame->json/tail proc path line col)\n  (hash 'name (~a (or (object-name proc) proc))\n        'srcloc (hash 'source (normalize-path-for-rosette path)\n                      'line line\n                      'column col)))\n\n(define (first-frame->json/tail stack)\n  (match stack\n    ['() '()]\n    [(cons #f stack) (first-frame->json/tail stack)]\n    [(cons (list 'certified a b) _) #:when (eq? a b) '()]\n    [(cons (list _ _ elem) _)\n     (list (apply frame->json/tail elem))]))\n\n(define (each-frame->json/tail frame)\n  (match frame\n    [#f #f]\n    [(list 'uncertified _ _) #f]\n    [(list _ elem _) (apply frame->json/tail elem)]))\n\n(define (exn-context->json xs)\n  (for/list ([x (in-list xs)] [_limit (in-range 32)])\n    (hash 'name (when/null [name (car x)] (~a name))\n          'srcloc (when/null [loc (cdr x)]\n                    (hash 'source (normalize-path-for-rosette (srcloc-source loc))\n                          'line (srcloc-line loc)\n                          'column (srcloc-column loc))))))\n\n(define (entry->json entry original-map)\n  (match-define (list exn-info stx-info stack _pc) entry)\n  (hash 'timestamp (current-seconds)\n        'exnMsg (exn-message exn-info)\n        'exnTrace (exn-context->json\n                    (continuation-mark-set->context\n                     (exn-continuation-marks exn-info)))\n        'stxInfo (when/null [stx-info stx-info]\n                    (define blaming-stx (hash-ref original-map (rest stx-info) #f))\n                    (hash 'stx (if blaming-stx\n                                   (syntax->string #`(#,blaming-stx))\n                                   (first stx-info))\n                          'srcloc (hash 'source (normalize-path-for-rosette (second stx-info))\n                                        'line (third stx-info)\n                                        'column (fourth stx-info))))\n        'callStack\n        (append (first-frame->json/tail stack)\n                (filter-map each-frame->json/tail stack))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I want to understand the streaming trace server setup and how traces/stats are queued and sent to the browser UI."},{"role":"assistant","content":"<think>The raco tool spins a worker thread that buffers trace and stats messages. A streaming server answers periodic client pulls with the queued items, then resets the queue. After the client connects, the tracer runs `do-trace`, pushing JSON entries and final stats into the worker for delivery to the UI.</think>\n\n```racket\n(define worker\n  (thread\n   (thunk\n    (define *queue* '())\n    (let loop ()\n      (match (thread-receive)\n        [`(append ,e)\n         (set! *queue* (cons (hash 'type "trace" 'data e) *queue*))\n         (loop)]\n        [`(query ,thd)\n         (thread-send thd (reverse *queue*))\n         (set! *queue* '())\n         (loop)]\n        [`(stats ,stats)\n         (set! *queue* (cons (hash 'type "stats" 'data stats) *queue*))\n         (loop)])))))\n\n(define-values (port shutdown! connected-channel)\n  (start-streaming-server\n   (thunk\n    (thread-send worker `(query ,(current-thread)))\n    (define out (thread-receive))\n    (when symbolic-trace-verbose?\n      (pretty-write out))\n    out)\n   2.0\n   (thunk (hash 'type "shutdown" 'data 'null))))\n\n(do-trace (λ () (dynamic-require mod #f))\n          #:entry-handler\n          (λ (entry _add-trace! original-map)\n            (thread-send worker `(append ,(entry->json entry original-map))))\n          #:post-proc\n          (λ (current-stats _trace _original-map)\n            (thread-send worker `(stats ,current-stats))))\n```"}]}
