{"messages": [{"role": "system", "content": "You are a Rosette engineer expert in symbolic execution and solver-aided programming."}, {"role": "user", "content": "Please add a Rosette printer that renders evaluated values, including unions, tuples, maps, refs, nil, and errors, into a readable textual form."}, {"role": "assistant", "content": "<think>\nHandle symbolic unions with `union?`/`union-contents`, stream each alternate with `for`, and otherwise fall back to matching the concrete constructors (Int, Ref, Tuple, Map, Nil, Error). Recurse through tuples/maps with `print-value`, map errors back to expressions with `print-expr`, and emit everything via `display`.\n</think>\n\n```racket\n(define (print-value value)\n  (if (union? value)\n      (let ([vals (map cdr (union-contents value))])\n        (display \"{ \")\n        (for ([v vals][n (in-naturals)])\n          (when (> n 0) (display \", \"))\n          (display (value-to-string v)))\n        (display \" }\"))\n      (match value\n        [(Int n) (display n)]\n        [(Ref a) (display \"Ref(\")\n                 (display a)\n                 (display \")\")]\n        [(Tuple elts) (display \"<\")\n                      (for ([(l i) (in-indexed elts)])\n                        (when (> i 0)\n                          (display \", \"))\n                        (print-value l))\n                      (display \">\")]\n        [(Map elts) (display \"{\")\n                    (for ([(pr i) (in-indexed elts)])\n                      (when (> i 0) (display \", \"))\n                      (print-value (car pr))\n                      (display \": \")\n                      (print-value (cdr pr)))\n                    (display \"}\")]\n        [(Nil)   (display \"nil\")]\n        [(Error msg expr) (display \"<error: \")\n                          (display msg)\n                          (display \" @ \")\n                          (if (Expr? expr)\n                              (print-expr expr)\n                              (display expr))\n                          (display \">\")]\n        [_       (display value)])))\n```"}]}
{"messages": [{"role": "system", "content": "You are a Rosette engineer expert in symbolic execution and solver-aided programming."}, {"role": "user", "content": "Provide a helper that captures whatever `print-value` writes so callers can store it as a string."}, {"role": "assistant", "content": "<think>\nReuse Racket's `with-output-to-string` to redirect display output into a buffer, wrap the printer call inside a `thunk`, and forward the symbolic value into `print-value`.\n</think>\n\n```racket\n(define (value-to-string val)\n  (with-output-to-string\n    (thunk (print-value val))))\n```"}]}
{"messages": [{"role": "system", "content": "You are a Rosette engineer expert in symbolic execution and solver-aided programming."}, {"role": "user", "content": "Implement a Rosette pretty-printer for expressions so we can dump ASTs with tuples, sequences, field accesses, object creation, methods, assignments, builtin calls, and conditionals."}, {"role": "assistant", "content": "<think>\nPattern-match on each expression variant, reuse `print-value` for constants, and emit textual syntax via `display`. Handle builtin calls by checking `Is_Builtin_Arity`, differentiate receiver vs global calls, and recursively print subexpressions for tuples, sequences, object creation, methods, assignments, calls, and ITEs.\n</think>\n\n```racket\n(define (print-expr expr)\n  (match expr\n    [(EVar x) (display x)]\n    [(EConst v) (print-value v)]\n    [(ETuple elts)\n     (display \"<\")\n     (for ([(l i) (in-indexed elts)])\n       (when (> i 0)\n         (display \", \"))\n       (print-expr l))\n     (display \">\")]\n    [(ESeq e1 e2) (print-expr e1)\n                  (display \"; \")\n                  (print-expr e2)]\n    [(ECVar obj name idx)\n     (unless (equal? obj (EConst (Nil)))\n       (print-expr obj)\n       (display \".\"))\n     (display name)\n     (unless (equal? idx (EConst (Nil)))\n       (display \"[\")\n       (print-expr idx)\n       (display \"]\"))]\n    [(ENew locals body)\n     (display \"new (\")\n     (for ([(l i) (in-indexed locals)])\n       (when (> i 0)\n         (display \", \"))\n       (display (Init-name l))\n       (unless (equal? (Init-val l) (EConst (Nil)))\n         (display \"=\")\n         (print-expr (Init-val l))))\n     (display \") { \")\n     (print-expr body)\n     (display \" }; \")]\n    [(EMethod name args body)\n     (display name)\n     (display \"(\")\n     (for ([(a i) (in-indexed args)])\n       (when (> i 0)\n         (display \", \"))\n       (display (EVar-name a)))\n     (display \") { \")\n     (print-expr body)\n     (display \" }; \")]\n    [(EAssign lhs rhs)\n     (print-expr lhs)\n     (display \" = \")\n     (print-expr rhs)]\n    [(ECall obj name args)\n     (cond\n       [(and (equal? obj (EConst (Nil))) (not (equal? (Is_Builtin_Arity name) -1)))\n        (define arity (Is_Builtin_Arity name))\n        (cond\n          [(and (equal? arity 1) (> (length args) 0))\n           (display name)\n           (print-expr (car args))]\n          [(and (equal? arity 2) (> (length args) 1))\n           (print-expr (car args))\n           (display \" \")\n           (display name)\n           (display \" \")\n           (print-expr (cadr args))]\n          [(equal? arity 0)\n           (display name)\n           (display \"()\")]\n          [else (error 'print-expr \"what is this? ~v\" expr)])]\n       [else\n        (unless (equal? obj (EConst (Nil)))\n          (print-expr obj)\n          (display \".\"))\n        (display name)\n        (display \"(\")\n        (for ([(a i) (in-indexed args)])\n          (when (> i 0)\n            (display \", \"))\n          (print-expr a))\n        (display \")\")])]\n    [(EITE cnd thn els)\n     (display \"if \")\n     (print-expr cnd)\n     (display \" { \")\n     (print-expr thn)\n     (display \" } \")\n     (unless (equal? els (ENop))\n       (display \"else { \")\n       (print-expr els)\n       (display \" } \"))]\n    [(ENop) (void)]\n    [_ (error 'print-expr \"what is this? ~v\" expr)]))\n```"}]}
{"messages": [{"role": "system", "content": "You are a Rosette engineer expert in symbolic execution and solver-aided programming."}, {"role": "user", "content": "Expose a convenience that returns the printed form of an expression instead of writing it to the console."}, {"role": "assistant", "content": "<think>\nMirror the value helper: wrap `print-expr` in `with-output-to-string`, invoke it inside a thunk, and return the captured text.\n</think>\n\n```racket\n(define (expr-to-string expr)\n  (with-output-to-string\n    (thunk (print-expr expr))))\n```"}]}
