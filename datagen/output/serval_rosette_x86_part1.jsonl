{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in x86 Rosette modeling."},{"role":"user","content":"I need the Rosette semantics for the 32-bit ADD r/m32,r32 instruction, including how flags are updated when the operands are symbolic."},{"role":"assistant","content":"<think>\n32-bit width comes from the destination register, so I keep both operands symbolic while PF/ZF/SF come from the bvadd result. CF/OF/AF rely on core:bvuadd-overflow? and core:bvsadd-overflow?, which delegate the carry/overflow reasoning to the solver. cpu-gpr-ref/set! move the symbolic architectural state for dst before add-r/m32-r32 reuses interpret-add.\n</think>\n\n```rkt\n(define (interpret-add cpu dst v2)\n  (define v1 (cpu-gpr-ref cpu dst))\n  (define result (bvadd v1 v2))\n  (cpu-gpr-set! cpu dst result)\n  (cpu-pf+zf+sf-set! cpu result)\n  (cpu-flag-set! cpu 'CF (bool->bitvector (core:bvuadd-overflow? v1 v2)))\n  (cpu-flag-set! cpu 'OF (bool->bitvector (core:bvsadd-overflow? v1 v2)))\n  (cpu-flag-set! cpu 'AF (bool->bitvector (core:bvuadd-overflow? (trunc 4 v1) (trunc 4 v2)))))\n\n(define-insn add-r/m32-r32 (dst src)\n  #:decode [((byte #x01) (/r reg r/m))\n            (list (gpr32-no-rex r/m) (gpr32-no-rex reg))]\n           [((rex/r r b) (byte #x01) (/r reg r/m))\n            (list (gpr32 b r/m) (gpr32 r reg))]\n  #:encode (list (rex/r src dst) (byte #x01) (/r src dst))\n  (lambda (cpu dst src)\n    (interpret-add cpu dst (cpu-gpr-ref cpu src))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in x86 Rosette modeling."},{"role":"user","content":"Document the Rosette behavior of the 64-bit SUB r/m64,r64 form, especially the borrow/overflow flags."},{"role":"assistant","content":"<think>\n64-bit width comes from the gpr64 accessor, so PF/ZF/SF are derived from the bvsub result while CF/OF/AF rely on core:bvusub-overflow? and core:bvssub-overflow? to ask the solver about unsigned borrows versus signed overflow. cpu-gpr-ref/cpu-gpr-set! keep the destination symbolic, and sub-r/m64-r64 simply reuses interpret-sub to subtract another symbolic register operand.\n</think>\n\n```rkt\n(define (interpret-sub cpu dst v2)\n  (define v1 (cpu-gpr-ref cpu dst))\n  (define result (bvsub v1 v2))\n  (cpu-gpr-set! cpu dst result)\n  (cpu-pf+zf+sf-set! cpu result)\n  (cpu-flag-set! cpu 'CF (bool->bitvector (core:bvusub-overflow? v1 v2)))\n  (cpu-flag-set! cpu 'OF (bool->bitvector (core:bvssub-overflow? v1 v2)))\n  (cpu-flag-set! cpu 'AF (bool->bitvector (core:bvusub-overflow? (trunc 4 v1) (trunc 4 v2)))))\n\n(define-insn sub-r/m64-r64 (dst src)\n  #:decode [((rex.w/r r b) (byte #x29) (/r reg r/m))\n            (list (gpr64 b r/m) (gpr64 r reg))]\n  #:encode (list (rex.w/r src dst) (byte #x29) (/r src dst))\n  (lambda (cpu dst src)\n    (interpret-sub cpu dst (cpu-gpr-ref cpu src))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in x86 Rosette modeling."},{"role":"user","content":"Show me how ADC r/m64,r64 is modeled in Rosette, including how the incoming carry flag is consumed."},{"role":"assistant","content":"<think>\nOperand width n = core:bv-size v2 guarantees the bool->bitvector carry-in matches the destination width, and PF/ZF/SF follow the bvadd result. CF/OF/AF call core:bvuadd-overflow? and core:bvsadd-overflow? with the carry argument, so the solver reasons about symbolic carries. cpu-flag-ref pulls the symbolic 'CF and cpu-gpr-ref/set! update the architectural registers when adc-r/m64-r64 invokes interpret-adc.\n</think>\n\n```rkt\n(define (interpret-adc cpu dst v2)\n  (define n (core:bv-size v2))\n  (define v1 (cpu-gpr-ref cpu dst))\n  (define carry (bitvector->bool (cpu-flag-ref cpu 'CF)))\n  (define result (bvadd v1 v2 (bool->bitvector carry n)))\n  (cpu-gpr-set! cpu dst result)\n  (cpu-pf+zf+sf-set! cpu result)\n  (cpu-flag-set! cpu 'CF (bool->bitvector (core:bvuadd-overflow? v1 v2 carry)))\n  (cpu-flag-set! cpu 'OF (bool->bitvector (core:bvsadd-overflow? v1 v2 carry)))\n  (cpu-flag-set! cpu 'AF (bool->bitvector (core:bvuadd-overflow? (trunc 4 v1) (trunc 4 v2) carry))))\n\n(define-insn adc-r/m64-r64 (dst src)\n  #:decode [((rex.w/r r b) (byte #x11) (/r reg r/m))\n            (list (gpr64 b r/m) (gpr64 r reg))]\n  #:encode (list (rex.w/r src dst) (byte #x11) (/r src dst))\n  (lambda (cpu dst src)\n    (interpret-adc cpu dst (cpu-gpr-ref cpu src))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in x86 Rosette modeling."},{"role":"user","content":"Explain the Rosette semantics for SBB r/m32,r32 when the borrow bit is symbolic."},{"role":"assistant","content":"<think>\n32-bit width is fixed by the gpr32 destination, so PF/ZF/SF follow the bvsub result while CF/OF/AF use core:bvusub-overflow? and core:bvssub-overflow? with the carry-as-borrow parameter, forcing the solver to reason about the incoming CF. cpu-flag-ref fetches the symbolic 'CF, and cpu-gpr-ref/set! keep the registers symbolic when sbb-r/m32-r32 calls interpret-sbb.\n</think>\n\n```rkt\n(define (interpret-sbb cpu dst v2)\n  (define n (core:bv-size v2))\n  (define v1 (cpu-gpr-ref cpu dst))\n  (define carry (bitvector->bool (cpu-flag-ref cpu 'CF)))\n  (define result (bvsub v1 v2 (bool->bitvector carry n)))\n  (cpu-gpr-set! cpu dst result)\n  (cpu-pf+zf+sf-set! cpu result)\n  (cpu-flag-set! cpu 'CF (bool->bitvector (core:bvusub-overflow? v1 v2 carry)))\n  (cpu-flag-set! cpu 'OF (bool->bitvector (core:bvssub-overflow? v1 v2 carry)))\n  (cpu-flag-set! cpu 'AF (bool->bitvector (core:bvusub-overflow? (trunc 4 v1) (trunc 4 v2) carry))))\n\n(define-insn sbb-r/m32-r32 (dst src)\n  #:decode [((byte #x19) (/r reg r/m))\n            (list (gpr32-no-rex r/m) (gpr32-no-rex reg))]\n           [((rex/r r b) (byte #x19) (/r reg r/m))\n            (list (gpr32 b r/m) (gpr32 r reg))]\n  #:encode (list (rex/r src dst) (byte #x19) (/r src dst))\n  (lambda (cpu dst src)\n    (interpret-sbb cpu dst (cpu-gpr-ref cpu src))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in x86 Rosette modeling."},{"role":"user","content":"I need the AND r/m64,imm32 semantics, emphasizing how the immediate is sized and how the logical flags are reset."},{"role":"assistant","content":"<think>\nSign-extending the imm32 into a 64-bit bitvector makes both operands share the destination width before bvand executes, so PF/ZF/SF are computed directly from that symbolic result. cpu-flag-clear! zeroes CF/OF/AF for logical ops while the parity helper still forces the solver to reason about every low-byte bit. cpu-gpr-ref/set! keep the destination symbolic when and-r/m64-imm32 calls interpret-and.\n</think>\n\n```rkt\n(define (interpret-and cpu dst v2)\n  (define v1 (cpu-gpr-ref cpu dst))\n  (define result (bvand v1 v2))\n  (cpu-gpr-set! cpu dst result)\n  (cpu-pf+zf+sf-set! cpu result)\n  (cpu-flag-clear! cpu 'CF 'OF 'AF))\n\n(define-insn and-r/m64-imm32 (dst imm32)\n  #:decode [((rex.w/r b) (byte #x81) (/4 r/m) i0 i1 i2 i3)\n            (list (gpr64 b r/m) (decode-imm i0 i1 i2 i3))]\n  #:encode (list (rex.w/r dst) (byte #x81) (/4 dst) (encode-imm imm32))\n  (lambda (cpu dst imm32)\n    (interpret-and cpu dst (sign-extend imm32 (bitvector 64)))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in x86 Rosette modeling."},{"role":"user","content":"Show the Rosette snippet for OR r/m32,r32, especially how the 32-bit truncation is handled."},{"role":"assistant","content":"<think>\nThe gpr32 operands keep everything at 32 bits, and the source register is explicitly truncated with (trunc 32 ...) before bvor, so the solver must respect that constraint. PF/ZF/SF come from the symbolic result via cpu-pf+zf+sf-set!, and cpu-flag-clear! zeros CF/OF/AF. cpu-gpr-ref/set! manage the symbolic register state when or-r/m32-r32 reuses interpret-or.\n</think>\n\n```rkt\n(define (interpret-or cpu dst v2)\n  (define v1 (cpu-gpr-ref cpu dst))\n  (define result (bvor v1 v2))\n  (cpu-gpr-set! cpu dst result)\n  (cpu-pf+zf+sf-set! cpu result)\n  (cpu-flag-clear! cpu 'CF 'OF 'AF))\n\n(define-insn or-r/m32-r32 (dst src)\n  #:decode [((byte #x09) (/r reg r/m))\n            (list (gpr32-no-rex r/m) (gpr32-no-rex reg))]\n           [((rex/r r b) (byte #x09) (/r reg r/m))\n            (list (gpr32 b r/m) (gpr32 r reg))]\n  #:encode (list (rex/r src dst) (byte #x09) (/r src dst))\n  (lambda (cpu dst src)\n    (interpret-or cpu dst (trunc 32 (cpu-gpr-ref cpu src)))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in x86 Rosette modeling."},{"role":"user","content":"Give me the Rosette implementation of XOR r64,r/m64 along with its flag updates."},{"role":"assistant","content":"<think>\nThe REX.W form keeps both operands at 64 bits via gpr64, so bvxor operates on full-width symbolic registers before PF/ZF/SF are recomputed. cpu-flag-clear! resets CF/OF/AF for XOR, and the parity helper still constrains the low byte. cpu-gpr-ref retrieves the symbolic src whether it was a register or memory-backed operand, and xor-r64-r/m64 feeds it into interpret-xor.\n</think>\n\n```rkt\n(define (interpret-xor cpu dst v2)\n  (define v1 (cpu-gpr-ref cpu dst))\n  (define result (bvxor v1 v2))\n  (cpu-gpr-set! cpu dst result)\n  (cpu-pf+zf+sf-set! cpu result)\n  (cpu-flag-clear! cpu 'CF 'OF 'AF))\n\n(define-insn xor-r64-r/m64 (dst src)\n  #:decode [((rex.w/r r b) (byte #x33) (/r reg r/m))\n            (list (gpr64 r reg) (gpr64 b r/m))]\n  #:encode (list (rex.w/r dst src) (byte #x33) (/r dst src))\n  (lambda (cpu dst src)\n    (interpret-xor cpu dst (cpu-gpr-ref cpu src))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in x86 Rosette modeling."},{"role":"user","content":"How does CMP r/m64,r64 update the flags in Rosette without storing the result?"},{"role":"assistant","content":"<think>\nCMP just reuses the subtraction result to touch PF/ZF/SF and computes CF/OF/AF via core:bvusub-overflow? and core:bvssub-overflow?, so the solver reasons about both unsigned borrows and signed overflow while leaving the destination untouched. cpu-gpr-ref fetches the symbolic src1/src2 operands, and interpret-cmp never calls cpu-gpr-set!, so only the flags change when cmp-r/m64-r64 runs.\n</think>\n\n```rkt\n(define (interpret-cmp cpu src1 v2)\n  (define v1 (cpu-gpr-ref cpu src1))\n  (define result (bvsub v1 v2))\n  (cpu-pf+zf+sf-set! cpu result)\n  (cpu-flag-set! cpu 'CF (bool->bitvector (core:bvusub-overflow? v1 v2)))\n  (cpu-flag-set! cpu 'OF (bool->bitvector (core:bvssub-overflow? v1 v2)))\n  (cpu-flag-set! cpu 'AF (bool->bitvector (core:bvusub-overflow? (trunc 4 v1) (trunc 4 v2)))))\n\n(define-insn cmp-r/m64-r64 (src1 src2)\n  #:decode [((rex.w/r r b) (byte #x39) (/r reg r/m))\n            (list (gpr64 b r/m) (gpr64 r reg))]\n  #:encode (list (rex.w/r src2 src1) (byte #x39) (/r src2 src1))\n  (lambda (cpu src1 src2)\n    (interpret-cmp cpu src1 (cpu-gpr-ref cpu src2))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in x86 Rosette modeling."},{"role":"user","content":"Clarify the Rosette semantics for TEST r/m32,r32, including its flag effects on symbolic data."},{"role":"assistant","content":"<think>\ninterpret-test sizes the operation with n = core:bv-size of the second operand, truncates the first source to that width, and bvand's them so PF/ZF/SF reflect the masked symbolic result. cpu-flag-clear! drops CF/OF while cpu-flag-havoc! makes AF unconstrained, which tells the solver it can take any value. cpu-gpr-ref supplies the symbolic registers before test-r/m32-r32 reuses interpret-test with a truncated source register.\n</think>\n\n```rkt\n(define (interpret-test cpu src1 v2)\n  (define n (core:bv-size v2))\n  (define v1 (trunc n (cpu-gpr-ref cpu src1)))\n  (define result (bvand v1 v2))\n  (cpu-pf+zf+sf-set! cpu result)\n  (cpu-flag-clear! cpu 'CF 'OF)\n  (cpu-flag-havoc! cpu 'AF))\n\n(define-insn test-r/m32-r32 (src1 src2)\n  #:decode [((byte #x85) (/r reg r/m))\n            (list (gpr32-no-rex r/m) (gpr32-no-rex reg))]\n           [((rex/r r b) (byte #x85) (/r reg r/m))\n            (list (gpr32 b r/m) (gpr32 r reg))]\n  #:encode (list (rex/r src2 src1) (byte #x85) (/r src2 src1))\n  (lambda (cpu src1 src2)\n    (interpret-test cpu src1 (trunc 32 (cpu-gpr-ref cpu src2)))))\n```"}]}
