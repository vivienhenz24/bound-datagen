{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in verification specs."}, {"role":"user","content":"Could you show how to define a Rosette helper that proves an implementation refines a specification by preserving the abstraction relation and representation invariant through a step?"}, {"role":"assistant","content":"<think>\nProperty: prove that after running spec and impl transitions, the implementation still satisfies the rep-invariant and matches the spec state via the abstraction function. Symbolic state: `impl-state` and `spec-state` flow through `rep-invariant` and `abs-function`, with assumptions ensuring the initial correspondence. Solver goal: `verify` shows the assertions (`ri1`, `post`) cannot fail, so no counterexample exists.\n</think>\n\n```racket\n(define\n  (verify-refinement\n    #:implstate impl-state\n    #:impl impl-func\n    #:specstate spec-state\n    #:spec spec-func\n    #:abs abs-function\n    #:ri rep-invariant\n    [args null]\n    [ce-handler (lambda (sol) (void))])\n\n  (define ri0 (rep-invariant impl-state))\n\n  (define pre (check-vc (equal? spec-state (abs-function impl-state))))\n\n  (assume ri0)\n  (assume pre)\n\n  ; spec state transition\n  (apply spec-func spec-state args)\n\n  ; impl state transition\n  (apply impl-func impl-state args)\n\n  (define ri1 (rep-invariant impl-state))\n  (assert ri1)\n\n  (define post (equal? spec-state (abs-function impl-state)))\n  (assert post))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in verification specs."}, {"role":"user","content":"I need a Rosette specification that captures reference-count invariants using bijective permission maps and count bounds for each owner and object."}, {"role":"assistant","content":"<think>\nProperty: ensure the `perm`/`perm-inv` maps form a bijection over valid owners and objects, the distinguished owner entry stays at index 0, and each owner count stays under `max-refs`. Symbolic vars: quantified `owner`, `object`, and `idx` range over 64-bit bitvectors; predicates `owner-valid?`, `object-valid?`, and `owned-by?` constrain the domain. Solver goal: the conjunction feeds higher-level proofs so that any candidate refcount state violating these invariants is ruled out.\n</think>\n\n```racket\n(define (refcnt-invariants refcnt owner-valid? object-valid? max-refs owned-by?)\n  (define cnt (refcnt-cnt refcnt))\n  (define perm (refcnt-perm refcnt))\n  (define perm-inv (refcnt-perm-inv refcnt))\n\n  (define-symbolic owner object idx (bitvector 64))\n\n  (&&\n    (forall (list owner object)\n      (=> (&& (owner-valid? owner) (object-valid? object))\n        (bvult (perm-inv owner object) max-refs)))\n    (forall (list owner object idx)\n      (=> (&& (owner-valid? owner) (object-valid? object) (bvult idx max-refs))\n        (&& (bveq idx (perm-inv owner (perm owner idx)))\n            (bveq (perm owner (perm-inv owner object)) object))))\n\n    ; The owner is always the first page to allocate and the last one to go\n    (forall (list owner)\n      (=> (&& (owner-valid? owner) (owned-by? owner owner))\n        (&& (bveq (perm-inv owner owner) (bv 0 64))\n            (bveq (perm owner (bv 0 64)) owner))))\n\n    (forall (list owner object)\n      (=> (&& (owner-valid? owner) (object-valid? object))\n        (<=> (owned-by? owner object)\n             (bvult (perm-inv owner object) (cnt owner)))))\n\n    (forall (list owner)\n      (=> (owner-valid? owner)\n        (bvule (cnt owner) max-refs)))\n  ))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in verification specs."}, {"role":"user","content":"Provide a Rosette noninterference helper that checks local respect when a domain has no permitted flow to an observer."}, {"role":"assistant","content":"<think>\nProperty: for every domain produced by `dom` and observer `u`, if the invariant holds and `flowsto` says the domain cannot affect `u`, then the unwinding relation between the old and new states must hold. Symbolic enumeration: `for*/all` exhaustively ranges `doma` and `u`, while states `s` and `old-s` capture pre and post snapshots. Solver expectation: `verify` establishes that `pre -> post` is valid, so any violating trace would yield a counterexample.\n</think>\n\n```racket\n(define\n  (check-local-respect\n    #:state-init init-state\n    #:state-copy state-copy\n    #:invariants inv\n    #:dom dom\n    #:u u\n    #:unwinding unwinding\n    #:flowsto flowsto\n    action\n    spec\n    [args null])\n\n  (define s (init-state))\n  (define old-s (state-copy s))\n\n  (apply spec s args)\n\n  (for*/all ([doma (dom action old-s) #:exhaustive]\n             [u u #:exhaustive])\n    (begin\n      (define pre (&& (inv old-s)\n                      (! (flowsto doma u))))\n\n      (define post (check-vc (unwinding u old-s s)))\n\n      (check-unsat? (verify (assert (=> pre post)))))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in verification specs."}, {"role":"user","content":"Share a Rosette template for proving step consistency so that two synchronized spec executions remain related by unwinding."}, {"role":"assistant","content":"<think>\nProperty: show that if two initial states satisfy `unwinding`, then after applying the same spec step they remain related. Symbolic state: fresh states `s` and `t` plus preserved copies `old-s` and `old-t`. Constraints: no extra quantifiers, just establish `pre` from old snapshots and `post` over the mutated states. Solver goal: `verify` discharges `pre -> post`, so any divergence would appear as a model.\n</think>\n\n```racket\n(define\n  (check-step-consistency\n    #:state-init init-state\n    #:state-copy state-copy\n    #:unwinding unwinding\n    spec\n    [args null])\n  (define s (init-state))\n  (define t (init-state))\n  (define old-s (state-copy s))\n  (define old-t (state-copy t))\n\n  (apply spec s args)\n  (apply spec t args)\n\n  (define pre (unwinding old-s old-t))\n  (define post (unwinding s t))\n\n  (check-unsat? (verify (assert (=> pre post)))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in verification specs."}, {"role":"user","content":"Show me how to encode weak step consistency in Rosette when observers are restricted by flow relations."}, {"role":"assistant","content":"<think>\nProperty: extend step consistency so observers `u` and domains `doma` satisfy invariants, unwinding, and a `flowsto` guard before the step, ensuring `unwinding u s t` holds afterward. Symbolic variables: `for*/all` ranges `u` and `doma`, while states `s`, `t`, `old-s`, and `old-t` store snapshots governed by `inv`, `unwinding`, and `flowsto`. Solver outcome: `verify` must prove the implication, so any violation would produce a counterexample assignment.\n</think>\n\n```racket\n(define\n  (check-weak-step-consistency\n    #:state-init init-state\n    #:state-copy state-copy\n    #:invariants inv\n    #:dom dom\n    #:u u\n    #:unwinding unwinding\n    #:flowsto flowsto\n    action\n    spec\n    [args null])\n\n  (define s (init-state))\n  (define t (init-state))\n  (define old-s (state-copy s))\n  (define old-t (state-copy t))\n\n  (apply spec s args)\n  (apply spec t args)\n\n  (for*/all ([u u #:exhaustive]\n             [doma (dom action old-s) #:exhaustive])\n    (begin\n\n      (define pre (&& (inv old-s)\n                      (inv old-t)\n                      (unwinding u old-s old-t)\n                      (flowsto doma u)\n                      (unwinding doma old-s old-t)\n      ))\n\n      (define post (check-vc (unwinding u s t)))\n\n      (check-unsat? (verify (assert (=> pre post)))))))\n```"}]}
