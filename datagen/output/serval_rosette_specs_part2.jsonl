{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in verification specs."},{"role":"user","content":"Please encode the UBSan signed addition handler so we can ask Rosette to report any lhs + rhs pair that cannot be represented in the target integer type."},{"role":"assistant","content":"<think>\nProperty: `handle-integer-overflow` raises `core:bug` whenever the sum of symbolic bitvectors `lhs` and `rhs` overflows the descriptor `type`.\nVariables: `lst` packages metadata, `type` dictates signedness, `lhs` and `rhs` stay symbolic so the solver can witness an overflowed addition.\nConstraints: solver explores cases where additions exceed the width returned by `type-bit-width`, and `define-evaluate` converts satisfying assignments into messages.\nExpected outcome: bug query stays satisfiable only on overflowing sums and prints whether the context is signed or unsigned.\n</think>\n\n```racket\n(define (handle-integer-overflow lst lhs rhs op)\n  (define data (make-overflow-data lst))\n  (define type (overflow-data-type data))\n  (define-evaluate (msg lhs rhs)\n    (define lhs-str (val->string type lhs))\n    (define rhs-str (val->string type rhs))\n    (format \"~a integer overflow: ~a ~a ~a cannot be represented in type ~a\"\n            (if (type-is-signed? type) \"signed\" \"unsigned\")\n            lhs-str op rhs-str\n            (type-descriptor-name type)))\n  (core:bug #:msg (lambda (sol) (format \"~v ~v ~v\" \"ubsan\" (overflow-data-location data) (msg sol)))))\n\n(define __ubsan_handle_add_overflow (curryr handle-integer-overflow \"+\"))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in verification specs."},{"role":"user","content":"Set up the UBSan div/rem overflow handler so Rosette can show that division either flags a zero denominator or the signed MIN/-1 overflow case."},{"role":"assistant","content":"<think>\nProperty: `__ubsan_handle_divrem_overflow` feeds metadata `lst`, symbolic dividend `lhs`, and divisor `rhs` into a `core:bug` query that distinguishes two failure modes.\nVariables: `type` is reconstructed from `lst`, `lhs` and `rhs` stay unconstrained bitvectors, and the solver branches over whether `rhs` reduces to zero.\nConstraints: one branch asserts `(bvzero? rhs)` and emits \"division by zero\", the other assumes `rhs = -1` and uses `overflow-data-type` to name the type for the INT_MIN/-1 overflow.\nExpected outcome: satisfiable models exist for each failing scenario, ensuring UBSan covers both error strings.\n</think>\n\n```racket\n(define (__ubsan_handle_divrem_overflow lst lhs rhs)\n  (define data (make-overflow-data lst))\n  (define type (overflow-data-type data))\n  (define-evaluate (msg lhs rhs)\n    (cond\n      [(bvzero? rhs)\n       \"division by zero\"]\n      [else\n       (format \"division of ~a by -1 cannot be represented in type ~a\"\n               (bitvector->integer lhs)\n               (type-descriptor-name type))]))\n  (core:bug #:msg (lambda (sol) (format \"~v ~v ~v\" \"ubsan\" (overflow-data-location data) (msg sol)))))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in verification specs."},{"role":"user","content":"I need the Rosette spec for the UBSan shift-out-of-bounds handler so the solver can find every invalid combination of lhs and rhs shift operands."},{"role":"assistant","content":"<think>\nProperty: `__ubsan_handle_shift_out_of_bounds` enumerates the four illegal shift situations (negative exponent, exponent too large, negative lhs, representability failure) before raising `core:bug`.\nVariables: symbolic structures in `lst` yield `lhs-type` and `rhs-type`, while bitvectors `lhs` and `rhs` remain unconstrained so the solver can hit each branch.\nConstraints: the message logic dispatches on `val-is-negative? rhs`, width comparison via `type-bit-width`, and `val-is-negative? lhs` prior to the catch-all overflow case.\nExpected outcome: Rosette can produce concrete models for each clause, ensuring every invalid shift reports a dedicated diagnostic string tied to its source location.\n</think>\n\n```racket\n(define (__ubsan_handle_shift_out_of_bounds lst lhs rhs)\n  (define data (make-shift-out-of-bounds-data lst))\n  (define lhs-type (shift-out-of-bounds-data-lhs-type data))\n  (define rhs-type (shift-out-of-bounds-data-rhs-type data))\n  (define-evaluate (msg lhs rhs)\n    (define lhs-str (val->string lhs-type lhs))\n    (define rhs-str (val->string rhs-type rhs))\n    (cond\n      [(val-is-negative? rhs-type rhs)\n       (format \"shift exponent ~a is negative\" rhs-str)]\n      [(>= (get-unsigned-val rhs-type rhs) (type-bit-width lhs-type))\n       (format \"shift exponent ~a is too large for ~a-bit type ~a\"\n               rhs-str (type-bit-width lhs-type) (type-descriptor-name lhs-type))]\n      [(val-is-negative? lhs-type lhs)\n       (format \"left shift of negative value ~a\" lhs-str)]\n      [else\n       (format \"left shift of ~a by ~a places cannot be represented in type ~a\"\n               lhs-str rhs-str (type-descriptor-name lhs-type))]))\n  (core:bug #:msg (lambda (sol) (format \"~v ~v ~v\" \"ubsan\" (shift-out-of-bounds-data-location data) (msg sol)))))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in verification specs."},{"role":"user","content":"Show me the SHA-256 rotate-right helper so I can prove in Rosette that its shr/shl decomposition matches a true 32-bit rotation for symbolic words."},{"role":"assistant","content":"<think>\nProperty: `rotate-right` must implement `(x >>> n) | (x << (w - n))` where `w` equals the width of the shift amount, guaranteeing a wrap-around rotate.\nVariables: `x` is a symbolic 32-bit word, `n` is a symbolic shift distance interpreted via `bv-size`, and `w` is derived once so that underflow when computing `w - n` is handled in bitvector arithmetic.\nConstraints: solver can assert `(equal? (rotate-right x n) (ror x n))` after inlining this helper, and the body must use `bvor`, `bvlshr`, and `bvshl` exactly as shown.\nExpected outcome: verification succeeds because the helper faithfully reassembles the rotated bits, even when `n = 0` or `n = w`.\n</think>\n\n```racket\n(define (rotate-right x n)\n  (define w (bv-size n))\n  (bvor (bvlshr x n) (bvshl x (bvsub (bv w w) n))))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in verification specs."},{"role":"user","content":"Extract the SHA-256 final block padding routine so I can prove Rosette always appends the 0x80 byte, zero pad, and 64-bit big-endian length as required."},{"role":"assistant","content":"<think>\nProperty: `sha256-update-last` computes the total bit length from the chunk counter and current tail, then appends the `0x80` marker, zero padding up to the last 64 bits, and the big-endian length field.\nVariables: symbolic byte list `data`, the running context `ctx` with `sha256-count`, and derived values `len`, `total`, and `last-data`.\nConstraints: solver can check that `last-data` equals `data ++ 0x80 ++ zeros ++ len64`, where `len64` matches `zero-extend (bvshl total (bv 3 32))` converted to 8 bytes.\nExpected outcome: verification confirms every message tail is padded to a multiple of 512 bits before the recursive `sha256-update-multi` call.\n</think>\n\n```racket\n(define (sha256-update-last ctx data)\n  (define len (length data))\n  (define total (bvadd (bvmul (bv 64 32) (sha256-count ctx)) (bv len 32)))\n  (define last-data\n    (append data\n            (list (bv #x80 8))\n            (make-list (- (if (< len 56) 55 (+ 63 56)) len) (bv 0 8))\n            (bitvector->list/be (zero-extend (bvshl total (bv 3 32)) (bitvector 64)))))\n  (sha256-update-multi ctx last-data))\n```\n"}]}
