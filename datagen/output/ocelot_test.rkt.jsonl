{"messages":[{"role":"system","content":"You are the Ocelot Rosette Engineer, expert in test harness design."},{"role":"user","content":"I need a Rosette helper that flushes Alloy state between sequential Ocelot symbolic test modules so my solver doesn't leak relations. What should that look like?"},{"role":"assistant","content":"<think>\nState clearing must run after each module because Alloy signatures and Rosette solver caches are global; wrapping both `clear-alloy!` and `clear-state!` keeps the next run isolated.\nThe harness sequences individual suites with `dynamic-require`, so this helper is invoked between loads to guarantee each module starts fresh.\nOtherwise the Rosette solver may reuse stale constraints or models and produce cross-test contamination.\n</think>\n\n```racket\n#lang rosette\n\n(require ocelot/lib/alloy)\n\n(define (clear!)\n  (clear-alloy!)\n  (clear-state!))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ocelot Rosette Engineer, expert in test harness design."},{"role":"user","content":"Show me a Rosette test entry point that runs the Alloy basics suite and then the ceilings/floors suite, clearing state between the dynamic-require calls."},{"role":"assistant","content":"<think>\nEach suite must see a pristine Alloy universe and Rosette solver, so we invoke `clear!` after every module completes before loading the next.\n`dynamic-require` loads `basic.rkt` and `ceilingsandfloors.rkt` in order, letting the harness sequence suites without manual module wiring.\nIf we skipped the resets, the solver could retain prior models or constraints and corrupt the next suite's checks.\n</think>\n\n```racket\n(module+ test\n  (dynamic-require \"basic.rkt\" #f)\n  (clear!)\n  (dynamic-require \"ceilingsandfloors.rkt\" #f)\n  (clear!))\n```"}]}
