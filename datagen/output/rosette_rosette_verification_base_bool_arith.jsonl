{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Please help me confirm that Rosette's lifted boolean negation reduces constants and cancels double negation."},{"role":"assistant","content":"<think>\n`a` is declared symbolic via `define-symbolic`, so the negation cases cover both constants and symbolic inputs. `check-rewrite` evaluates each expression, rebuilds the original AST with `unsimplified`, and calls `solve` on the negated `<=>` to ensure no model makes the rewritten result differ. Unsat responses therefore certify constant folding for `!` and the involutive law `!(!a)`.\n</think>\n\n```racket\n(define-symbolic a b c d @boolean?)\n\n\n(define-syntax (unsimplified stx)\n  (syntax-case stx ()\n    [(_ (op arg ...)) #'(expression op (unsimplified arg) ...)]\n    [(_ v)            #'v]))\n\n\n(define-syntax-rule (check-rewrite (op arg ...) expected)\n  (let ([actual (op arg ...)])\n    (check-equal? actual expected)\n    (check-unsat (solve (expression ! (expression <=> actual (unsimplified (op arg ...))))))))\n\n\n(define (check-not)\n  (check-rewrite (! #t) #f)\n  (check-rewrite (! #f) #t)\n  (check-rewrite (! (! a)) a))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Can you show a Rosette regression that proves iff (<=>) obeys its truth table, symmetry, and stays symbolic on unknowns?"},{"role":"assistant","content":"<think>\n`a` and `b` are symbolic booleans, so the rewrites must hold for unknowns. Each `check-rewrite` matches one entry of the `<=>` truth table or reflexive/complementary case and then relies on the unsat check inside `check-rewrite` to guarantee no model contradicts the expected literal. The symmetry clause enforces commutativity, and `check-false (boolean? (<=> a b))` makes sure the solver keeps the equivalence symbolic when neither side is concrete.\n</think>\n\n```racket\n(define-symbolic a b c d @boolean?)\n\n\n(define-syntax (unsimplified stx)\n  (syntax-case stx ()\n    [(_ (op arg ...)) #'(expression op (unsimplified arg) ...)]\n    [(_ v)            #'v]))\n\n\n(define-syntax-rule (check-rewrite (op arg ...) expected)\n  (let ([actual (op arg ...)])\n    (check-equal? actual expected)\n    (check-unsat (solve (expression ! (expression <=> actual (unsimplified (op arg ...))))))))\n\n\n(define (check-iff)\n  (check-rewrite (<=> #t #t) #t)\n  (check-rewrite (<=> #f #f) #t)\n  (check-rewrite (<=> #t #f) #f)\n  (check-rewrite (<=> #f #t) #f)\n   \n  (check-rewrite (<=> a a) #t)\n  (check-rewrite (<=> a (! a)) #f)\n  (check-rewrite (<=> (! a) a) #f)\n  (check-rewrite (<=> a #t) a)\n  (check-rewrite (<=> #t a) a)\n  (check-rewrite (<=> a #f) (! a))\n  (check-rewrite (<=> #f a) (! a))\n  (check-rewrite (<=> a b) (<=> b a))\n  (check-false (boolean? (<=> a b))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I need a regression that proves implication (=>) simplifies identities, distributes through ors/ands, and rewrites to (!a) \\ c."},{"role":"assistant","content":"<think>\nSymbols `a`, `b`, `c`, and `d` are boolean, and implication is validated by enumerating each tautology and simplification case. Every `check-rewrite` triggers the solver-backed unsat proof that the canonical result (for example `=> a c` becoming `|| (! a) c`) matches the original formula constructed through `unsimplified`, so the simplifier can rely on these rewrites.\n</think>\n\n```racket\n(define-symbolic a b c d @boolean?)\n\n\n(define-syntax (unsimplified stx)\n  (syntax-case stx ()\n    [(_ (op arg ...)) #'(expression op (unsimplified arg) ...)]\n    [(_ v)            #'v]))\n\n\n(define-syntax-rule (check-rewrite (op arg ...) expected)\n  (let ([actual (op arg ...)])\n    (check-equal? actual expected)\n    (check-unsat (solve (expression ! (expression <=> actual (unsimplified (op arg ...))))))))\n\n\n(define (check-if)\n  (check-rewrite (=> #f #f) #t)\n  (check-rewrite (=> #f #t) #t)\n  (check-rewrite (=> #t #f) #f)\n  (check-rewrite (=> #t #t) #t)\n  \n  (check-rewrite (=> a a) #t)\n  (check-rewrite (=> #f a) #t)\n  (check-rewrite (=> a #t) #t)\n  (check-rewrite (=> #t a) a)\n  (check-rewrite (=> a #f) (! a))\n  (check-rewrite (=> (! a) a) a)\n  (check-rewrite (=> a (! a)) (! a))\n\n  (check-rewrite (=> a (|| a b c)) #t)\n  (check-rewrite (=> a (|| (! a) b)) (=> a b))\n  (check-rewrite (=> d (|| b (! d))) (=> d b))\n  (check-rewrite (=> a (&& a b)) (=> a b))\n  (check-rewrite (=> d (&& b d)) (=> d b))\n  (check-rewrite (=> a (&& (|| a c) b)) (=> a b))\n  (check-rewrite (=> a (&& b (|| a c))) (=> a b))\n  (check-rewrite (=> a (<=> a b)) (=> a b))\n  (check-rewrite (=> d (<=> b d)) (=> d b))\n  (check-rewrite (=> a c) (|| (! a) c)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Could you capture how @integer? should behave on reals, merges, and plain booleans?"},{"role":"assistant","content":"<think>\nThe symbolic integers `xi/yi/zi` and reals `xr/yr/zr` let us cover concrete numbers, symbolic reals guarded by `@int?`, and union values built with `merge`. Each `check-equal?` pins down the boolean result that `@integer?` must return, e.g., passing along guard `a` for `merge a xi '()` or requiring both `a` and `@int? xr` when a real branch is active. The solver therefore has to implement `@integer?` as the predicate described by these constraints.\n</think>\n\n```racket\n(define-symbolic a b c d e f g @boolean?)\n(define-symbolic xi yi zi @integer?)\n(define-symbolic xr yr zr @real?)\n\n(define (check-integer?)\n  (check-equal? (@integer? 1) #t)\n  (check-equal? (@integer? -1) #t)\n  (check-equal? (@integer? -1.0001) #f)\n  (check-equal? (@integer? xi) #t)\n  (check-equal? (@integer? xr) (@int? xr))\n  (check-equal? (@integer? (@real->integer xr)) #t)\n  (check-equal? (@integer? (merge a xi '())) a)\n  (check-equal? (@integer? (merge a xr '())) (&& a (@int? xr)))\n  (check-equal? (@integer? (merge a xr xi)) (|| (! a) (&& a (@int? xr))))\n  (check-equal? (@integer? a) #f)\n  (check-equal? (@integer? (merge a b '())) #f))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Please document the integer type-cast rules Rosette enforces when converting symbolic values with type-cast."},{"role":"assistant","content":"<think>\n`check-cast` runs `type-cast` under `with-vc`, so we can inspect both the returned value and the acceptance condition stored in the VC. Each test states which guard must be asserted (`accepted?`) and what normalized value (`out`) should be produced: integers pass through, reals succeed only when `@int?` holds (and then emit `@real->integer xr`), and mixed unions rewrite into `merge*` trees guarded by the appropriate booleans. Failing casts preserve the original union with `#f` obligations.\n</think>\n\n```racket\n(define-symbolic a b c d e f g @boolean?)\n(define-symbolic xi yi zi @integer?)\n(define-symbolic xr yr zr @real?)\n\n(define-syntax-rule (check-cast (type val) (accepted? out))\n    (match (with-vc (type-cast type val))\n      [(and r (or (normal v sp) (failed v sp)))\n       (when (normal? r) (check-equal? v out))\n       (check-equal? (vc-assumes sp) #t)\n       (check-equal? (vc-asserts sp) accepted?)]))\n\n(define (check-integer-cast)\n  (check-cast (@integer? 1) (#t 1))\n  (check-cast (@integer? -1.0001) (#f -1.0001))\n  (check-cast (@integer? xi) (#t xi))\n  (check-cast (@integer? xr) ((@int? xr) (@real->integer xr)))\n  (check-cast (@integer? (merge a xi '())) (a xi))\n  (check-cast (@integer? (merge a xr '())) ((&& a (@int? xr)) (@real->integer xr)))\n  (check-cast (@integer? (merge a xi xr)) \n              ((|| a (&& (! a) (@int? xr)))\n               (merge* (cons a xi) (cons (&& (! a) (@int? xr)) (@real->integer xr)))))\n  (check-cast (@integer? (merge* (cons a xi) (cons b xr) (cons c '()))) \n              ((|| a (&& b (@int? xr))) \n               (merge* (cons a xi) (cons (&& b (@int? xr)) (@real->integer xr)))))\n  (check-cast (@integer? (merge a b '())) (#f (merge a b '()))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Give me a Rosette spec that proves the equality simplifier reasons about nested ite expressions over numbers."},{"role":"assistant","content":"<think>\n`check-valid?` snapshots the current VC, clears it, and then asks the solver to find a counterexample to `(@= ... expected)`; unsat means the rewrite is sound. These obligations show how `@=` collapses `ite` trees: matching branches yield booleans like `b`, mismatched ranges collapse to `#f`, and combinations of guards reduce to conjunctions such as `&& a b`. The solver must therefore agree with each expected boolean result.\n</think>\n\n```racket\n(define-symbolic a b c d e f g @boolean?)\n(define-symbolic xi yi zi @integer?)\n(define-symbolic xr yr zr @real?)\n\n(define-syntax check-valid?\n  (syntax-rules ()\n    [(_ (op e ...) expected)\n     (check-valid? (op e ...) expected [unsat?])]\n    [(_ (op e ...) expected [pred? ...])\n     (let ([actual (op e ...)])\n      (check-equal? actual expected) \n      (define preconditions (&& (vc-assumes (vc)) (vc-asserts (vc))))\n      (clear-vc!)\n      (define pred (lambda (x) (or (pred? x) ...)))\n      (check-pred pred (solve (! (@equal? (expression op e ...) expected)) preconditions)))]))\n\n(define (check-=-simplifications)\n  (check-valid? (@= 2 2.0) #t)\n  (check-valid? (@= 2.1 2.0) #f)\n  (check-valid? (@= (ite b 2 0) 2) b)\n  (check-valid? (@= (ite b 2 0) 0) (! b))\n  (check-valid? (@= (ite b 2 0) 1) #f)\n  (check-valid? (@= 2 (ite b 2 0)) b)\n  (check-valid? (@= 0 (ite b 2 0)) (! b))\n  (check-valid? (@= 1 (ite b 2 0)) #f)\n  (check-valid? (@= (ite a 2 2) (ite b 2 2)) #t)\n  (check-valid? (@= (ite a 2 3) (ite b 4 5)) #f)\n  (check-valid? (@= (ite a 2 3) (ite b 2 5)) (&& a b))\n  (check-valid? (@= (ite a 2 3) (ite b 5 2)) (&& a (! b)))\n  (check-valid? (@= (ite a 2 3) (ite b 3 5)) (&& (! a) b))\n  (check-valid? (@= (ite a 2 3) (ite b 5 3)) (&& (! a) (! b))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Show how Rosette normalizes symbolic additions so they cancel opposites and collect constants."},{"role":"assistant","content":"<think>\nThe addition rewriter first proves via `check-nary` that `@+` treats `0` as the neutral element, then each `check-valid?` call proves that constants commute, additive inverses cancel, and scalar multiples collapse. The solver checks the negation of each equality, so identities like `(@+ (@* 3 x) x) = (@* 4 x)` and `(@+ x 0.0) = x` become trusted simplifications.\n</think>\n\n```racket\n(define-symbolic a b c d e f g @boolean?)\n(define-symbolic xi yi zi @integer?)\n(define-symbolic xr yr zr @real?)\n\n(define-syntax check-valid?\n  (syntax-rules ()\n    [(_ (op e ...) expected)\n     (check-valid? (op e ...) expected [unsat?])]\n    [(_ (op e ...) expected [pred? ...])\n     (let ([actual (op e ...)])\n      (check-equal? actual expected) \n      (define preconditions (&& (vc-assumes (vc)) (vc-asserts (vc))))\n      (clear-vc!)\n      (define pred (lambda (x) (or (pred? x) ...)))\n      (check-pred pred (solve (! (@equal? (expression op e ...) expected)) preconditions)))]))\n\n(define (check-+-simplifications x y z)\n  (check-nary @+ 0 x y z)\n  (check-valid? (@+ x 0.0) x)\n  (check-valid? (@+ x 1) (@+ 1 x))\n  (check-valid? (@+ (@- x) x) 0)\n  (check-valid? (@+ (@- (@+ x z)) x) (@- z))\n  (check-valid? (@+ (@+ (@+ (@- x) z)) x) z)\n  (check-valid? (@+ (@+ y 1) 1) (@+ y 2))\n  (check-valid? (@+ (ite a 1 2) 3) (ite a 4 5))\n  (check-valid? (@+ (@* 3 x) x) (@* 4 x))\n  (check-valid? (@+ (@* 3 x) (@* -2 x)) x)\n  (check-valid? (@+ (@+ x y) (@- x)) y)\n  (check-valid? (@+ (@+ x y) (@- y)) x)\n  (check-valid? (@+ (@+ -1 x y) (@+ 1 (@- x) (@- y))) 0)\n  (check-valid? (@+ (@+ -1 (@- x) y) (@+ 1 x (@- y))) 0)\n  (check-valid? (@+ (@+ -1 x y) (@+ 1 (@- x) (@- y) z)) z)\n  (check-valid? (@+ (@+ x y) (@+ 1 (@- x) (@- y))) 1)\n  (check-valid? (@+ (@+ -1 (@* 2 x) y) (@+ 1 (@* -2 x) (@- y) z)) z))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Capture the algebraic facts Rosette's division simplifier must respect, including zero/one rules, sign flips, and distributing through ite merges."},{"role":"assistant","content":"<think>\nThis parametric test treats `div` as the division operator under scrutiny. Every `check-valid?` call proves that constants fold away (`div 0 x = 0`, `div x 1 = x`), negations introduce `@-`, and self-division yields Â±1 even under guarded branches. The solver-based negated equality ensures that even the `ite`-guarded numerators/denominators rewrite to expressions like `(ite a (div (+ 4 epsilon) 2) ...)` without changing satisfiable models.\n</think>\n\n```racket\n(define-symbolic a b c d e f g @boolean?)\n(define-symbolic xi yi zi @integer?)\n(define-symbolic xr yr zr @real?)\n\n(define-syntax check-valid?\n  (syntax-rules ()\n    [(_ (op e ...) expected)\n     (check-valid? (op e ...) expected [unsat?])]\n    [(_ (op e ...) expected [pred? ...])\n     (let ([actual (op e ...)])\n      (check-equal? actual expected) \n      (define preconditions (&& (vc-assumes (vc)) (vc-asserts (vc))))\n      (clear-vc!)\n      (define pred (lambda (x) (or (pred? x) ...)))\n      (check-pred pred (solve (! (@equal? (expression op e ...) expected)) preconditions)))]))\n\n(define (check-division-simplifications div x y z [epsilon 0])\n  (check-valid? (div 0 x) 0)\n  (check-valid? (div x 1) x)\n  (check-valid? (div x -1) (@- x))\n  (check-valid? (div 0.0 x) 0)\n  (check-valid? (div x 1.0) x)\n  (check-valid? (div x -1.0) (@- x))\n  (check-valid? (div x x) 1)\n  (check-valid? (div x (@- x)) -1)\n  (check-valid? (div (@- x) x) -1)\n  (check-valid? (div (ite a (+ 4 epsilon) (+ 6 epsilon)) 2) \n                (ite a (div (+ 4 epsilon) 2) (div (+ 6 epsilon) 2)))\n  (check-valid? (div 12 (ite a (+ 4 epsilon) (+ 6 epsilon))) \n                (ite a (div 12 (+ 4 epsilon)) (div 12 (+ 6 epsilon))))\n  (check-valid? (div (div x 4) 2) (div x 8))\n  (check-valid? (div (@* x y z) y) (@* x z))\n  (check-valid? (div (@* 2 x y z) y) (@* 2 x z))\n  (check-valid? (div (@* x y z) (@* y x)) z))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I want to assert that the polymorphic =? predicate dispatches correctly across integers and booleans."},{"role":"assistant","content":"<think>\n`x`, `y`, and `z` are symbolic integers while `a` and `b` are booleans, so `=?` must reconcile mixed sorts. These checks pin it down: numeric-vs-numeric cases reduce to `@=` constraints, boolean-vs-boolean to `<=>`, mismatched sorts to `#f`, and structured expressions like `(@+ x y)` trivially compare equal to themselves. The solver therefore has to implement the predicate exactly as specified.\n</think>\n\n```racket\n(define-symbolic x y z @integer?)\n\n(define-symbolic a b c d @boolean?)\n\n(define (primitive-equality-tests =?)\n  (check-equal? (=? x x) #t)\n  (check-equal? (=? a a) #t)\n  (check-equal? (=? x y) (@= x y))\n  (check-equal? (=? a b) (<=> a b))\n  (check-equal? (=? x a) #f)\n  (check-equal? (=? x 1) (@= x 1))\n  (check-equal? (=? a #t) a)\n  (check-equal? (=? a #f) (! a))\n  (check-equal? (=? 1 1) #t)\n  (check-equal? (=? 1 0) #f)\n  (check-equal? (=? #t #t) #t)\n  (check-equal? (=? #f #f) #t)\n  (check-equal? (=? #t #f) #f)\n  (check-equal? (=? (@+ x y) (@+ x y)) #t))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Please encode the structural equality obligations for transparent immutable pairs when their fields are symbolic."},{"role":"assistant","content":"<think>\nThe generic `pair` constructor stands in for transparent immutable structs, so these checks show how `=?` must decompose: identical literals return `#t`, swapping arguments yields guard conjunctions like `&& (@= x y) a`, and nested pairs compare recursively. Because each obligation reduces to conjunctions of `@=` or `@equal?`, the solver must enforce field-wise equality to satisfy the tests.\n</think>\n\n```racket\n(define-symbolic x y z @integer?)\n\n(define-symbolic a b c d @boolean?)\n\n(define (transparent-immutable-tests pair =?)\n  (check-equal? (=? (pair 1 4) (pair 1 4)) #t)\n  (check-equal? (=? (pair 1 x) (pair 1 x)) #t)\n  (check-equal? (=? (pair x 1) (pair x 1)) #t)\n  (check-equal? (=? (pair y z) (pair y z))  #t)\n  \n  (check-equal? (=? (pair x y) (pair y x)) (@= x y))\n  (check-equal? (=? (pair x a) (pair y #t)) (&& (@= x y) a))\n  (check-equal? (=? (pair x y) (pair 2 3)) (&& (@= x 2) (@= y 3)))\n  (check-equal? (=? (pair x 3) (pair 2 y)) (&& (@= x 2) (@= y 3)))\n  (check-equal? (=? (pair a b) (pair b a)) (@equal? a b))\n  (check-equal? (=? (pair (pair x y) z) (pair (pair 2 3) 5)) \n                (&& (&& (@= x 2) (@= y 3)) (@= z 5))))\n```"}]}
