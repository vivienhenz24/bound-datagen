{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I need to maximize a simple integer objective under linear constraints. Can you show how to encode it and what the optimizer should return?"},{"role":"assistant","content":"<think>\nThis case uses Rosette's optimize with #:maximize over an integer sum and linear constraints. The tricky bit is ensuring the objective and constraints are expressed with optimize rather than solve, and that the model matches the optimal integer assignment. The expected result is a satisfiable model with x=1 and y=1 given the bounds and the inequality on y-x. Solver interaction should return sat with that model.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui rosette/lib/roseunit)\n\n(define (minimize obj . asserts)\n  (optimize #:minimize (list obj)\n            #:guarantee (for ([a asserts]) (assert a))))\n\n(define (maximize obj . asserts)\n  (optimize #:maximize (list obj)\n            #:guarantee (for ([a asserts]) (assert a))))\n\n(define (check-solution actual expected [test =])\n  (check-sat actual)\n  (define ma (model actual))\n  (define me (model expected))\n  (check-equal? (dict-keys ma) (dict-keys me))\n  (for ([(k v) ma])\n    (check test v (dict-ref me k))))\n\n(define basic-tests\n  (test-suite+ \n   \"Basic optimize tests with no finitization.\"\n   #:features '(qf_lia optimize)\n   (current-bitwidth #f)\n   (define-symbolic x y integer?)\n   (check-solution (maximize (+ x y) (< x 2) (< (- y x) 1))\n                   (sat (hash x 1 y 1)))\n   (check-unsat (maximize (+ x y) (< x 2) (< y 2) (> (+ x y) 4)))\n   (check-unsat (minimize (+ x y) (< x 2) (< y 2) (> (+ x y) 4)))\n   (check-solution (minimize (+ x y) (< x 4) (< (- y x) 1) (> y 1))\n                   (sat (hash x 2 y 2)))\n   (define-symbolic r q real?)\n   (check-solution (maximize (+ r q) (< r 4) (< q 5))\n                   (sat (hash r 3.0 q 4.0)) >=)\n   ))\n\n(module+ test\n  (time (run-tests basic-tests)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Show me an optimization query that should be unsatisfiable even when maximizing, so I can confirm the solver reports unsat."},{"role":"assistant","content":"<think>\nThis edge case checks that optimize correctly reports unsat when hard constraints contradict any possible objective value. It uses #:maximize over (+ x y) but asserts x<2, y<2, and (+ x y)>4, which is impossible. The solver should return unsat and not try to fabricate an optimal model.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui rosette/lib/roseunit)\n\n(define (minimize obj . asserts)\n  (optimize #:minimize (list obj)\n            #:guarantee (for ([a asserts]) (assert a))))\n\n(define (maximize obj . asserts)\n  (optimize #:maximize (list obj)\n            #:guarantee (for ([a asserts]) (assert a))))\n\n(define (check-solution actual expected [test =])\n  (check-sat actual)\n  (define ma (model actual))\n  (define me (model expected))\n  (check-equal? (dict-keys ma) (dict-keys me))\n  (for ([(k v) ma])\n    (check test v (dict-ref me k))))\n\n(define basic-tests\n  (test-suite+ \n   \"Basic optimize tests with no finitization.\"\n   #:features '(qf_lia optimize)\n   (current-bitwidth #f)\n   (define-symbolic x y integer?)\n   (check-solution (maximize (+ x y) (< x 2) (< (- y x) 1))\n                   (sat (hash x 1 y 1)))\n   (check-unsat (maximize (+ x y) (< x 2) (< y 2) (> (+ x y) 4)))\n   (check-unsat (minimize (+ x y) (< x 2) (< y 2) (> (+ x y) 4)))\n   (check-solution (minimize (+ x y) (< x 4) (< (- y x) 1) (> y 1))\n                   (sat (hash x 2 y 2)))\n   (define-symbolic r q real?)\n   (check-solution (maximize (+ r q) (< r 4) (< q 5))\n                   (sat (hash r 3.0 q 4.0)) >=)\n   ))\n\n(module+ test\n  (time (run-tests basic-tests)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Can you give me a minimization example where the constraints force a non-trivial optimum, and show the expected model?"},{"role":"assistant","content":"<think>\nThis optimization edge case uses #:minimize on an integer sum with constraints that force y>1 and y-x<1. The optimum is non-trivial because it requires balancing the objective with tight constraints; the expected model is x=2, y=2. It tests that optimize respects the strict inequality on y and the derived bound on x.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui rosette/lib/roseunit)\n\n(define (minimize obj . asserts)\n  (optimize #:minimize (list obj)\n            #:guarantee (for ([a asserts]) (assert a))))\n\n(define (maximize obj . asserts)\n  (optimize #:maximize (list obj)\n            #:guarantee (for ([a asserts]) (assert a))))\n\n(define (check-solution actual expected [test =])\n  (check-sat actual)\n  (define ma (model actual))\n  (define me (model expected))\n  (check-equal? (dict-keys ma) (dict-keys me))\n  (for ([(k v) ma])\n    (check test v (dict-ref me k))))\n\n(define basic-tests\n  (test-suite+ \n   \"Basic optimize tests with no finitization.\"\n   #:features '(qf_lia optimize)\n   (current-bitwidth #f)\n   (define-symbolic x y integer?)\n   (check-solution (maximize (+ x y) (< x 2) (< (- y x) 1))\n                   (sat (hash x 1 y 1)))\n   (check-unsat (maximize (+ x y) (< x 2) (< y 2) (> (+ x y) 4)))\n   (check-unsat (minimize (+ x y) (< x 2) (< y 2) (> (+ x y) 4)))\n   (check-solution (minimize (+ x y) (< x 4) (< (- y x) 1) (> y 1))\n                   (sat (hash x 2 y 2)))\n   (define-symbolic r q real?)\n   (check-solution (maximize (+ r q) (< r 4) (< q 5))\n                   (sat (hash r 3.0 q 4.0)) >=)\n   ))\n\n(module+ test\n  (time (run-tests basic-tests)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I want to enumerate models and make sure the generator shuts down cleanly and doesn't pollute the term cache. Can you show a solve+ scenario that covers that?"},{"role":"assistant","content":"<think>\nThis case uses solve+ to generate multiple satisfiable models before returning unsat, then explicitly shuts down the generator. The tricky parts are the generator lifecycle and ensuring that shutdown forbids further calls while the term cache remains clean after finitization. The constraints include arithmetic, bitvector->integer conversions, and division guards, all of which stress solver interaction across successive calls.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui  \n         rosette/lib/roseunit)\n\n(define-symbolic a b c boolean?)\n(define-symbolic xi yi zi integer?)\n(define-symbolic xr yr zr real?)\n(define-symbolic xb yb zb (bitvector 4))\n\n(define consts (set a b c xi yi zi xr yr zr xb yb zb))\n\n(define (check-solve+ . bools)\n  (define gen (solve+))\n  (define-values (head tail) (split-at bools (sub1 (length bools))))\n  ; Check that all solutions prior to last are sat.\n  (for ([h head])\n    (check-sat (gen h)))\n  ; Check that the last solution is unsat\n  (check-unsat (gen (car tail)))\n  ; Check that next-to-last solution is still sat\n  (check-sat (gen 1))\n  ; Check that nothing can be called after shutdown\n  (gen 'shutdown)\n  (check-exn exn:fail? (thunk (gen #t)))\n  (check-exn exn:fail? (thunk (gen 1)))\n  (check-exn exn:fail? (thunk (gen 'shutdown)))\n  ; Check that term cache is not polluted with finitizaton values -- no\n  ; fresh constants should be left in the term cache\n  (check subset? (apply set (symbolics (terms))) consts))\n\n(define basic-tests\n  (test-suite+ \"Solve+ tests with no (effective) finitization.\"\n    (current-bitwidth #f)\n\n    (check-solve+ #t #f)\n    (check-solve+ #f)\n    (check-solve+ (> xi (+ xi yr)) (= yr 2.5))\n    (check-solve+ (< xi (+ xi yr)) (= yr 2.5) (> 0 yr))\n    (check-solve+ (> xi (+ xi (bitvector->integer yb))) (bveq yb (bv 1 4)))    \n    (check-solve+ (< xi (+ xi (bitvector->integer yb))) (bveq yb (bv 1 4)) (= xi 0) (< xi 0))\n    (check-solve+ (! (= yr 0)) (= (/ xr yr) zr) (= zr 1.5) (! (= xr (* yr 1.5)))) \n    (check-solve+ (= (* xr yr) zr) (= zr 20000) (= zr 0))\n    \n    (current-bitwidth 4)\n    (check-solve+ #t #f)\n    (check-solve+ #f)\n    (check-solve+ (bveq xb yb) (bveq xb (bv 3 4)) (! (bveq yb (bv 3 4))))\n    (check-solve+ (bveq xb yb) (bveq xb (bv 0 4)) (bveq yb (bv 1 4)))\n    ))\n\n(define finitized-tests\n  (test-suite+ \"Solve+ tests with finitization.\"\n    (current-bitwidth 5)\n    \n    (check-solve+ (! (= yr 0)) (= (/ xr yr) zr) (= zr 2) (= xr 5) (! (= yr 2)))\n    (check-solve+ (= xr (bitvector->integer yb)) (bveq yb (bv 2 4)) (! (= xr 2)))\n    \n    (check-solve+ (! (= yr 0)) (= (/ xr yr) zr) (= zr 1.5) (! (= zr 1)))\n    (check-solve+ (= (* xr yr) zr) (= zr 20000) (! (= zr 0)))\n    \n    (current-bitwidth 3)\n    (check-solve+ (= xr (bitvector->integer yb)) (bveq yb (bv -8 4)) (! (= xr 0)))\n )) \n\n(module+ test             \n  (time (run-tests basic-tests))\n  (time (run-tests finitized-tests)))\n```"}]}
