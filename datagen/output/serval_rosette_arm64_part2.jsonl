{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Could you restate the Rosette STR/LDR register-offset semantics, including extend-reg behavior and SP alignment guards?"},{"role":"assistant","content":"<think>\nLoad/store register family: decode() consumes size/Rm/option/S/Rn/Rt, rejects invalid extend selector bits, and records regsize/datasize so symbolic truncation aligns with the hardware form. interpret-store-register and interpret-load-register both call extend-reg on Rm, resolve SP vs general base with check-sp-alignment, and then emit core:memmgr-store!/load transactions before zero-extending into Rt. The CPU state is purely symbolic (pc, SP, xn, memmgr), so solvers can explore offset/extend combinations under undefined traps; no standalone solve is issued here beyond the effects of mem primitives.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  strb strh str32 str64\n  ldrb ldrh ldr32 ldr64)\n\n\n(define (decode size Rm option S Rn Rt)\n  (define scale (bitvector->natural size))\n\n  (when (bveq (bit 1 option) (bv #b0 1))\n    (undefined))\n\n  (define extend_type (decode-reg-extend option))\n  (define shift (if (bveq S (bv #b1 1)) scale 0))\n\n  (define n Rn)\n  (define t Rt)\n  (define m Rm)\n\n  (define regsize (if (bveq size (bv #b11 2)) 64 32))\n  (define datasize (arithmetic-shift 8 scale))\n\n  (values extend_type shift n t m regsize datasize))\n\n\n(define (interpret-store-register cpu size Rm option S Rn Rt)\n  (define-values (extend_type shift n t m regsize datasize) (decode size Rm option S Rn Rt))\n  (define offset (extend-reg 64 cpu m extend_type shift))\n\n  (define address\n    (if (equal? n (integer->gpr 31))\n        (begin\n          (check-sp-alignment cpu)\n          (cpu-sp-ref cpu))\n        (cpu-gpr-ref cpu n)))\n\n  (define data (trunc datasize (cpu-gpr-ref cpu t)))\n  (core:memmgr-store! (cpu-memmgr cpu) address offset data (bv (quotient datasize 8) 64)))\n\n\n(define (interpret-load-register cpu size Rm option S Rn Rt)\n  (define-values (extend_type shift n t m regsize datasize) (decode size Rm option S Rn Rt))\n  (define offset (extend-reg 64 cpu m extend_type shift))\n\n  (define address\n    (if (equal? n (integer->gpr 31))\n        (begin\n          (check-sp-alignment cpu)\n          (cpu-sp-ref cpu))\n        (cpu-gpr-ref cpu n)))\n\n  (define data (core:memmgr-load (cpu-memmgr cpu) address offset (bv (quotient datasize 8) 64)))\n  (cpu-gpr-set! cpu t (zero-extend data (bitvector regsize))))\n\n\n(define-insn (size Rm option S Rn Rt)\n  #:encode (lambda (opc) (list size (bv #b111 3) (bv #b0 1) (bv #b00 2) (bv opc 2) (bv #b1 1) Rm option S (bv #b10 2) Rn Rt))\n  [(#b00) store-register interpret-store-register]\n  [(#b01) load-register interpret-load-register])\n\n(define (strb Rm option S Rn Rt)\n  (store-register (bv #b00 2) Rm option S Rn Rt))\n\n(define (strh Rm option S Rn Rt)\n  (store-register (bv #b01 2) Rm option S Rn Rt))\n\n(define (str32 Rm option S Rn Rt)\n  (store-register (bv #b10 2) Rm option S Rn Rt))\n\n(define (str64 Rm option S Rn Rt)\n  (store-register (bv #b11 2) Rm option S Rn Rt))\n\n(define (ldrb Rm option S Rn Rt)\n  (load-register (bv #b00 2) Rm option S Rn Rt))\n\n(define (ldrh Rm option S Rn Rt)\n  (load-register (bv #b01 2) Rm option S Rn Rt))\n\n(define (ldr32 Rm option S Rn Rt)\n  (load-register (bv #b10 2) Rm option S Rn Rt))\n\n(define (ldr64 Rm option S Rn Rt)\n  (load-register (bv #b11 2) Rm option S Rn Rt))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"I need the Rosette semantics for paired STP/ LDP with writeback and pre/post-indexing—can you quote the source?"},{"role":"assistant","content":"<think>\nRegister-pair load/store decoding keys off opc to pick the datasize (2 or 3 bit shifts) and sign-extends imm7<<scale, while guarding undefined overlaps when writeback aliases Xn. interpret-stp/ldp fetch symbolic addresses from SP (with check-sp-alignment) or general registers, emit paired core:memmgr-store!/load transactions separated by dbytes, and conditionally update SP/Xn after postindexing. Signed flag from opc<0> in decode-ldp determines whether results are sign- or zero-extended into Rt/Rt2. The CPU state (xn vector, memmgr) remains symbolic so solvers observe the guard conditions and memory effects without extra solve calls.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  stp-preindex\n  ldp-postindex)\n\n(define (decode-stp opc imm7 Rt2 Rn Rt)\n  (define n Rn)\n  (define t Rt)\n  (define t2 Rt2)\n  (define scale\n    (cond\n      [(equal? opc (bv #b00 2)) (bv 2 64)]\n      [(equal? opc (bv #b10 2)) (bv 3 64)]\n      [else (undefined)]))\n  (define datasize (bvshl (bv 8 64) scale))\n  (define offset (bvshl (sign-extend imm7 (bitvector 64)) scale))\n  (values n t t2 scale datasize offset))\n\n(define ((interpret-stp wback postindex) cpu opc imm7 Rt2 Rn Rt)\n  (define-values (n t t2 scale datasize offset) (decode-stp opc imm7 Rt2 Rn Rt))\n  (define mm (cpu-memmgr cpu))\n\n  (define dbytes (bvudiv datasize (bv 8 64)))\n\n  (when (and wback (or (equal? t n) (equal? t2 n)) (not (equal? n (integer->gpr 31))))\n    (undefined))\n\n  (define address #f)\n  (cond\n    [(equal? n (integer->gpr 31))\n      (check-sp-alignment cpu)\n      (set! address (cpu-sp-ref cpu))]\n    [else\n      (set! address (cpu-gpr-ref cpu n))])\n\n  (when (! postindex)\n    (set! address (bvadd address offset)))\n
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"What does the Rosette B.cond interpreter look like? I need the exact conditional branch encoding."},{"role":"assistant","content":"<think>\nConditional branch immediate (B.cond) sign-extends imm19 concatenated with two zero bits inside decode, matching ARM's 4-byte alignment. interpret-b.cond computes the offset, invokes condition-holds on the symbolic NZCV flags, then calls branch-to to redirect the PC when the predicate holds, returning #f so interpret-insn skips the default pc+4. Solvers see bitvector constraints over imm19 and the condition register without additional solve queries beyond the guards.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  b.cond)\n\n\n(define (decode imm19)\n  (sign-extend (concat imm19 (bv #b00 2)) (bitvector 64)))\n\n(define (interpret-b.cond cpu imm19 cond)\n  (define offset (decode imm19))\n  (when (condition-holds cpu cond)\n    (branch-to cpu (bvadd (cpu-pc-ref cpu) offset))))\n\n\n(define-insn (imm19 cond)\n  #:encode (lambda (o1 o0) (list (bv #b0101010 7) (bv o1 1) imm19 (bv o0 1) cond))\n  [(#b0 #b0) b.cond interpret-b.cond])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Show me the Rosette implementation of B and BL (unconditional branch immediates)."},{"role":"assistant","content":"<think>\nUnconditional branch immediates use decode to sign-extend imm26 with two low zeros for 4-byte alignment, then interpret-b simply jumps pc+offset via branch-to while interpret-bl additionally writes the architectural link register X30 with pc+4 before branching. Both rely on symbolic pc and memmgr state; no memory access occurs, so solver reasoning stays within the arithmetic on imm26 offsets.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  b bl)\n\n\n(define (decode imm26)\n  (sign-extend (concat imm26 (bv #b00 2)) (bitvector 64)))\n\n(define (interpret-b cpu imm26)\n  (define offset (decode imm26))\n  (branch-to cpu (bvadd (cpu-pc-ref cpu) offset)))\n\n(define (interpret-bl cpu imm26)\n  (define offset (decode imm26))\n  (cpu-gpr-set! cpu (integer->gpr 30) (bvadd (cpu-pc-ref cpu) (bv 4 64)))\n  (branch-to cpu (bvadd (cpu-pc-ref cpu) offset)))\n\n\n(define-insn (imm26)\n  #:encode (lambda (op) (list (bv op 1) (bv #b00101 5) imm26))\n  [(#b0) b  interpret-b]\n  [(#b1) bl interpret-bl])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Can you cite the Rosette implementation for BR/BLR/RET (register-indirect branches)?"},{"role":"assistant","content":"<think>\nRegister-indirect control flow is captured by interpret-br, which simply reads the symbolic target from cpu-gpr-ref Rn and passes it to branch-to, and interpret-blr, which also writes pc+4 into X30 before the jump; RET uses the same interpret-br because its encoding only differs in opcode fields. The define-insn table ties specific opc/op2/op3/op4 patterns to these interpreters, so solvers see the equalities on the concatenated opcode fields alongside the indirect branch effects on the PC and LR.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  ret br blr)\n\n\n(define (interpret-br cpu Rn)\n  (define target (cpu-gpr-ref cpu Rn))\n  (branch-to cpu target))\n\n(define (interpret-blr cpu Rn)\n  (define target (cpu-gpr-ref cpu Rn))\n  (define pc (cpu-pc-ref cpu))\n  (cpu-gpr-set! cpu (integer->gpr 30) (bvadd pc (bv 4 (type-of pc))))\n  (branch-to cpu target))\n\n\n(define-insn (Rn)\n  #:encode (lambda (opc op2 op3 op4) (list (bv #b1101011 7) (bv opc 4) (bv op2 5) (bv op3 6) Rn (bv op4 5)))\n  [(#b0010 #b11111 #b000000 #b00000) ret interpret-br]\n  [(#b0000 #b11111 #b000000 #b00000) br  interpret-br]\n  [(#b0001 #b11111 #b000000 #b00000) blr interpret-blr])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Please provide the Rosette source for variable shift instructions (LSLV/LSRV/ASRV/RORV)."},{"role":"assistant","content":"<think>\nShift-register family interprets the shared operand decode via interpret-shift-variable: sf selects datasize (32/64), op2 feeds decode-shift to pick LSL/LSR/ASR/ROR, and the second register is truncated and masked with (datasize-1) before invoking shift-reg. Symbolic cpu-gpr-ref values are truncated to datasize, shifted, and written back via cpu-gpr-set!, giving the solver the exact bitvector relationships underlying shift amounts and results.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  lslv lsrv asrv rorv)\n\n\n(define (interpret-shift-variable cpu sf Rm op2 Rn Rd)\n  (define d Rd)\n  (define n Rn)\n  (define m Rm)\n  (define datasize (if (bveq sf (bv #b1 1)) 64 32))\n  (define shift_type (decode-shift op2))\n\n  (define operand1 (trunc datasize (cpu-gpr-ref cpu n)))\n  (define operand2 (trunc datasize (cpu-gpr-ref cpu m)))\n\n  ; The ARM manual uses (operand2 MOD datasize); use bit masking instead.\n  (define mask (bv (sub1 datasize) datasize))\n  (define result (shift-reg cpu n shift_type (bvand operand2 mask)))\n  (cpu-gpr-set! cpu d result))\n\n\n(define-insn (sf Rm op2 Rn Rd)\n  #:encode (lambda () (list sf (bv #b0 1) (bv #b0 1) (bv #b11010110 8) Rm (bv #b0010 4) op2 Rn Rd))\n  [() shift-variable interpret-shift-variable])\n\n(define (lslv sf Rm Rn Rd)\n  (shift-variable sf Rm (bv #b00 2) Rn Rd))\n\n(define (lsrv sf Rm Rn Rd)\n  (shift-variable sf Rm (bv #b01 2) Rn Rd))\n\n(define (asrv sf Rm Rn Rd)\n  (shift-variable sf Rm (bv #b10 2) Rn Rd))\n\n(define (rorv sf Rm Rn Rd)\n  (shift-variable sf Rm (bv #b11 2) Rn Rd))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Quote the Rosette semantics for MOVN/MOVZ/MOVK so I can reuse the immediate update helpers."},{"role":"assistant","content":"<think>\nMove-wide immediates share decode() to pick datasize from sf, reject illegal sf=0 with hw<1>=1, and compute the left-shifted position as concat(hw,#x0). update/32 and update/64 splice the 16-bit constant into the proper halfword without resorting to host integers, then interpret-movn inverts, interpret-movz writes zeroed result, and interpret-movk merges with the existing register value truncated to datasize. The helper ensures symbolic handling of pos via pattern matching so solvers see exact concat/extract relationships.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  movn movz movk)\n\n\n; Helpers for updating bits<pos+15:pos>.\n;\n; We don't want to convert pos to integers, thus explicitly unrolling cases.\n; Another approach is to use bit masking, but the code would be harder to read.\n\n(define (update/32 v pos imm16)\n  (cond\n    [(bveq pos (bv 0 6))\n     (concat (extract 31 16 v) imm16)]\n    [(bveq pos (bv 16 6))\n     (concat imm16 (extract 15 0 v))]\n    [else\n     (assert #f)]))\n\n(define (update/64 v pos imm16)\n  (cond\n    [(bveq pos (bv 0 6))\n     (concat (extract 63 16 v) imm16)]\n    [(bveq pos (bv 16 6))\n     (concat (extract 63 32 v) imm16 (extract 15 0 v))]\n    [(bveq pos (bv 32 6))\n     (concat (extract 63 48 v) imm16 (extract 31 0 v))]\n    [(bveq pos (bv 48 6))\n     (concat imm16 (extract 47 0 v))]\n    [else\n     (assert #f)]))\n\n(define (update datasize v pos imm16)\n  (case datasize\n    [(32) (update/32 v pos imm16)]\n    [(64) (update/64 v pos imm16)]\n    [else (assert #f)]))\n\n\n(define (decode sf hw imm16 Rd)\n  (define d Rd)\n  (define datasize (if (bveq sf (bv #b1 1)) 64 32))\n\n  ; sf == '0' && hw<1> == '1'\n  (when (&& (bveq sf (bv #b0 1)) (bveq (bit 1 hw) (bv #b1 1)))\n    (undefined))\n\n  (define pos (concat hw (bv #b0000 4)))\n\n  (values d datasize pos))\n\n\n(define (interpret-movn cpu sf hw imm16 Rd)\n  (define-values (d datasize pos) (decode sf hw imm16 Rd))\n  (define result (zeros datasize))\n  (set! result (update datasize result pos imm16))\n  (set! result (bvnot result))\n  (cpu-gpr-set! cpu d result))\n\n\n(define (interpret-movz cpu sf hw imm16 Rd)\n  (define-values (d datasize pos) (decode sf hw imm16 Rd))\n  (define result (zeros datasize))\n  (set! result (update datasize result pos imm16))\n  (cpu-gpr-set! cpu d result))\n\n\n(define (interpret-movk cpu sf hw imm16 Rd)\n  (define-values (d datasize pos) (decode sf hw imm16 Rd))\n  (define result (trunc datasize (cpu-gpr-ref cpu d)))\n  (set! result (update datasize result pos imm16))\n  (cpu-gpr-set! cpu d result))\n\n\n(define-insn (sf hw imm16 Rd)\n  #:encode (lambda (opc) (list sf (bv opc 2) (bv #b100101 6) hw imm16 Rd))\n  [(#b00) movn interpret-movn]\n  [(#b10) movz interpret-movz]\n  [(#b11) movk interpret-movk])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"I’m reviewing LDADD/STADD Rosette semantics—can you share the atomic interpreter code?"},{"role":"assistant","content":"<think>\nAtomic load-add forms decode size/A/R bits to derive datasize/regsize and choose ordered vs relaxed access types, then interpret-ldadd* truncates the source register, resolves SP vs Xn base (ensuring alignment), and calls mem-atomic with op 'ADD to fetch/update memory atomically. Results are conditionally written back to Rt (unless XZR), zero-extending to regsize. Symbolic cpu state and mem-atomic interactions give the solver the precise dataflow and guard constraints (e.g., Rt==31 suppresses writes) for LDADD/STADD.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"common.rkt\")\n\n(provide\n  ldadd32 ldadd64\n  stadd32 stadd64)\n\n\n(define (decode size A R Rs Rn Rt)\n  (define t Rt)\n  (define n Rn)\n  (define s Rs)\n\n  (define datasize (arithmetic-shift 8 (bitvector->natural size)))\n  (define regsize (if (equal? datasize 64) 64 32))\n  (define ldacctype (if (&& (bveq A (bv #b1 1)) (! (equal? Rt (integer->gpr #b11111)))) 'ORDEREDATOMICRW 'ATOMICRW))\n  (define stacctype (if (bveq R (bv #b1 1)) 'ORDEREDATOMICRW 'ATOMICRW))\n  (define tag_checked (! (equal? n (integer->gpr 31))))\n\n  (values t n s datasize regsize ldacctype stacctype tag_checked))\n\n\n(define (interpret-ldadd* cpu size A R Rs Rn Rt)\n  (define-values (t n s datasize regsize ldacctype stacctype tag_checked) (decode size A R Rs Rn Rt))\n  (define value (trunc datasize (cpu-gpr-ref cpu s)))\n  (define address\n    (if (equal? n (integer->gpr 31))\n        (begin\n          (check-sp-alignment cpu)\n          (cpu-sp-ref cpu))\n        (cpu-gpr-ref cpu n)))\n\n  (define data (mem-atomic cpu address 'ADD value ldacctype stacctype))\n  (unless (equal? t (integer->gpr 31))\n    (cpu-gpr-set! cpu t (zero-extend data (bitvector regsize)))))\n\n\n(define-insn (size A R Rs Rn Rt)\n  #:encode (lambda (V o3 opc) (list size (bv #b111 3) (bv V 1) (bv #b00 2) A R (bv #b1 1) Rs (bv o3 1) (bv opc 3) (bv #b00 2) Rn Rt))\n  [(#b0 #b0 #b000) ldadd* interpret-ldadd*])\n\n(define (ldadd32 Rs Rn Rt)\n  (ldadd* (bv #b10 2) (bv #b0 1) (bv #b0 1) Rs Rn Rt))\n\n(define (ldadd64 Rs Rn Rt)\n  (ldadd* (bv #b11 2) (bv #b0 1) (bv #b0 1) Rs Rn Rt))\n\n(define (stadd32 Rs Rn)\n  (ldadd32 Rs Rn (integer->gpr #b11111)))\n\n(define (stadd64 Rs Rn)\n  (ldadd64 Rs Rn (integer->gpr #b11111)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Remind me how branch-to and condition-holds are implemented in the ARM64 Rosette common library."},{"role":"assistant","content":"<think>\nThe common helpers define branch-to as a PC write that returns #f, signalling interpret-insn not to auto-increment PC. condition-holds decodes the 4-bit condition code: it extracts bits <3:1> for the base predicate over symbolic NZCV components, then flips the truth value when bit0 requests inversion unless the condition is in the always-true 111x set. This function is used by B.cond and other conditional branches, so capturing it preserves the bitvector-level constraints that solvers must satisfy for each predicate.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  \"define.rkt\"\n  \"../base.rkt\"\n  \"../../lib/bvarith.rkt\"\n  (prefix-in core: \"../../lib/core.rkt\"))\n\n(provide\n  (all-defined-out)\n  (all-from-out\n    \"define.rkt\"\n    \"../base.rkt\"\n    \"../../lib/bvarith.rkt\"\n    \"../../lib/core.rkt\"))\n\n\n; common library\n\n(define (add-with-carry x y carry_in)\n  (define N (core:bv-size x))\n  (define carry? (bitvector->bool carry_in))\n  (define result (bvadd x y (if carry? (bv #b1 N) (bv #b0 N))))\n  (define n (bit (sub1 N) result))\n  (define z (if (is-zero result) (bv #b1 1) (bv #b0 1)))\n  (define c (if (core:bvuadd-overflow? x y carry?) (bv #b1 1) (bv #b0 1)))\n  (define v (if (core:bvsadd-overflow? x y carry?) (bv #b1 1) (bv #b0 1)))\n  (values result (nzcv n z c v)))\n\n; return #f to skip the default behavior of bumping the PC by 4\n(define (branch-to cpu target)\n  (cpu-pc-set! cpu target)\n  #f)\n\n(define (condition-holds cpu cc)\n  ; Evaluate base condition.\n  (define base (extract 3 1 cc))\n  (define result\n    (cond\n      [(bveq base (bv #b000 3))\n       (bveq (cpu-pstate.z cpu) (bv #b1 1))]\n      [(bveq base (bv #b001 3))\n       (bveq (cpu-pstate.c cpu) (bv #b1 1))]\n      [(bveq base (bv #b010 3))\n       (bveq (cpu-pstate.n cpu) (bv #b1 1))]\n      [(bveq base (bv #b011 3))\n       (bveq (cpu-pstate.v cpu) (bv #b1 1))]\n      [(bveq base (bv #b100 3))\n       (&& (bveq (cpu-pstate.c cpu) (bv #b1 1))\n           (bveq (cpu-pstate.z cpu) (bv #b0 1)))]\n      [(bveq base (bv #b101 3))\n       (bveq (cpu-pstate.n cpu) (cpu-pstate.v cpu))]\n      [(bveq base (bv #b110 3))\n       (&& (bveq (cpu-pstate.n cpu) (cpu-pstate.v cpu))\n           (bveq (cpu-pstate.z cpu) (bv #b0 1)))]\n      [(bveq base (bv #b111 3))\n       #t]))\n\n  ; Condition flag values in the set '111x' indicate always true.\n  ; Otherwise, invert condition if necessary.\n  (when (&& (bveq (bit 0 cc) (bv #b1 1))\n            (! (bveq cc (bv #b1111 4))))\n    (set! result (! result)))\n\n  result)\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Could you share the ARM64 Rosette decoder combinator (add-decoder/decode) so I can understand how instructions are reconstructed?"},{"role":"assistant","content":"<think>\nThe decoder infrastructure maintains a list of constructor closures registered via add-decoder. Each decoder splits the 32-bit instruction into chunks based on the spec (bitvectors or symbolic boxes), then matches constant fields and returns boxed symbolic operands used to instantiate the instruction struct. decode walks all registered decoders, ensures exactly one match, and asserts that re-encoding the instruction yields the original bytes, providing a solver-visible equality constraint. The helper also falls back to llvm-mc disassembly for diagnostics via disassemble.\n</think>\n\n```racket\n#lang rosette\n\n(require\n  (prefix-in core: \"../lib/core.rkt\")\n  \"../lib/bvarith.rkt\"\n  \"base.rkt\")\n\n(provide\n  add-decoder decode)\n\n\n(define decoders null)\n\n; To construct an instruction, a decoder checks that constant fields match\n; and extracts values for symbolic fields:\n; - ctor: an instruction struct;\n; - spec: a list of bitvector types (symbolic fields) or values (constant fields).\n(define (add-decoder ctor spec)\n  ; split a 32-bit bitvector into chunks\n  (define (split x lst)\n    (define e (car lst))\n    (when (box? e)\n      (set! e (unbox e)))\n    (set! lst (cdr lst))\n    (define i\n      (cond\n        [(bitvector? e) (bitvector-size e)]\n        [(bv? e)        (core:bv-size e)]\n        [else           (error \"unknown decoder\")]))\n    (define n (core:bv-size x))\n    (if (equal? i n)\n        (begin\n          (assert (empty? lst))\n          (list x))\n        (cons (trunc i x) (split (extract (sub1 n) i x) lst))))\n  (define (proc x)\n    ; Match from lowest bits, which is a better fit for bytes\n    ; constructed using (concat ...) and simpler for offsets.\n    (define chunks (reverse (split x (reverse spec))))\n    (define match? (andmap (lambda (act exp) (if (bv? exp) (bveq act exp) #t)) chunks spec))\n    (define (make-if-bitvector act exp)\n      (cond\n        [(and (box? exp) (bitvector? (unbox exp))) (box act)]\n        [(bitvector? exp) act]\n        [else #f]))\n    (if match?\n        (apply ctor (filter-map make-if-bitvector chunks spec))\n        #f))\n  (set! decoders (cons proc decoders)))\n\n(define (decode x)\n  (define result (filter-map (lambda (proc) (proc x)) decoders))\n  (when (null? result)\n    (eprintf \"no decoder for ~a\\n\" x)\n    (eprintf \"~a\\n\" (disassemble (core:bitvector->list/le x) #:arch \"aarch64\"))\n    (exit 1))\n  (when (! (= (length result) 1))\n    (eprintf \"ambiguity in decoding for ~a\\n\" x)\n    (for ([e result])\n      (eprintf \"  ~a\\n\" e))\n    (exit 1))\n  (define insn (car result))\n  (define exp-bytes (instruction-encode insn))\n  (assert (equal? x exp-bytes)\n          \"encoded bytes must match original bytes\")\n  insn)\n\n(define (disassemble #:arch [arch #f] lst)\n  (define cmd (find-executable-path \"llvm-mc\"))\n  (define args (list \"--disassemble\"))\n  (when arch\n    (set! args (append (list \"--arch\" arch) args)))\n  ; concretize input\n  (set! lst (evaluate lst (complete-solution (sat) (symbolics lst))))\n  (define in (open-input-string (string-join (map (lambda (x) (format \"0x~x \" (bitvector->natural x))) lst))))\n  (define out (open-output-string))\n  (parameterize ([current-input-port in]\n                 [current-output-port out])\n    (apply system* cmd args))\n  (get-output-string out))\n```"}]}
