{"messages": [{"role": "system", "content": "You are a Rosette engineer expert in symbolic execution and solver-aided programming."}, {"role": "user", "content": "Craft a Rosette routine that symbolically evaluates two candidate programs, havoc their state, enforces invariants, and produces a per-method equivalence proof object."}, {"role": "assistant", "content": "<think>\nEvaluate both programs to references, havoc their reachable state, and require invariants to hold before invoking any shared methods. Use MethodProof records to enforce equal returns, invariant preservation, and matching adversary traces, and gate the overall predicate behind the discovered precondition extracted from asserts.\n</think>\n\n```racket\n(struct Proof (lhs rhs) #:transparent)\n(struct RewriteProof Proof (ctx e1 e2 assumptions) #:transparent)\n(struct EquivalenceProof Proof (predicate parts methods contexts asserts vacuity?) #:transparent)\n(struct MethodProof (predicate method parts values contexts args) #:transparent)\n(struct AdmitProof Proof () #:transparent)\n\n(struct Invariant (proc) #:transparent\n  #:property prop:procedure (struct-field-index proc))\n(struct EquivalenceInvariant Invariant () #:transparent)\n(struct OldNewInvariant Invariant () #:transparent)\n\n;; Given two expressions and a context in which to evaluate each,\n;; prove that the values returned by the two expressions are equivalent:\n;; for all common methods, in all contexts satisfying the invariant,\n;; for all arguments, the methods return the same values, and the invariant holds\n(define (Equivalent ctx lhs rhs [invs (list (lambda _ #t))] [vacuity? #t])\n  (match-define (cons _ ctx0) (Eval ctx (EmptyContext) FUEL))\n  (match-define (cons ret1 _ctx1) (Eval lhs ctx0 FUEL))\n  (define ctx0-replay (replay-all-adversaries ctx0))\n  (match-define (cons ret2 _ctx2) (Eval rhs ctx0-replay FUEL))\n\n  ; fail fast\n  (unless (Ref? ret1)\n    (error 'Equivalent \"LHS does not evaluate to a reference (instead: ~v)\" ret1))\n  (unless (Ref? ret2)\n    (error 'Equivalent \"RHS does not evaluate to a reference (instead: ~v)\" ret2))\n\n  (define ctx1 (Context-with-ths _ctx1 (Ref-addr ret1)))\n  (define ctx2 (Context-with-ths _ctx2 (Ref-addr ret2)))\n\n  (define old-asserts (asserts))\n\n  ; both sides must return references to objects\n  (define BothObjects\n    (and (Ref? ret1) (ValidRef (Ref-addr ret1) ctx1)\n         (Ref? ret2) (ValidRef (Ref-addr ret2) ctx2)))\n\n  ; the invariant must hold in the initial state\n  (define invsbase (for/list ([inv invs] #:when (EquivalenceInvariant? inv))\n                     (cons inv (inv ctx1 ctx2 (Ref-addr ret1) (Ref-addr ret2)))))\n  (define InvariantBase (apply && (map cdr invsbase)))\n\n  ; if we havoc the contexts...\n  (define ctx1* (HavocContext ctx1 (Ref-addr ret1)))\n  (define ctx2* (HavocContext ctx2 (Ref-addr ret2)))\n\n  ; and the invariant holds before running a method\n  (define InvariantInit\n    (apply && (for/list ([inv invs] #:when (EquivalenceInvariant? inv))\n                          (inv ctx1* ctx2* (Ref-addr ret1) (Ref-addr ret2)))))\n\n  ; then for each method common between the two objects\n  (define methods (CommonMethods ctx1 ctx2 (Ref-addr ret1) (Ref-addr ret2)))\n\n  ; for all possible arguments to that method...\n  (define MethodProofs\n    (for/list ([m methods])\n      (define-values (ctx1*-copy ctx2*-copy) (copy-all-adversaries ctx1* ctx2*))\n      (let ([args (HavocMethodArgs m)])\n        (match-let ([(cons retL ctxL) (CallMethod m args (Ref-addr ret1) ctx1*-copy)]\n                    [(cons retR ctxR) (CallMethod m args (Ref-addr ret2) ctx2*-copy)])\n          (let ([eqpost (or (equal? retL retR) (and (Error? retL) (Error? retR)))]\n                [invspost (for/list ([inv invs] #:when (EquivalenceInvariant? inv)) \n                            (cons inv (inv ctxL ctxR (Ref-addr ret1) (Ref-addr ret2)))]\n                [replayed (check-adversary-replays ctxR)])\n            (MethodProof (and eqpost (apply && (map cdr invspost)) replayed)\n                         m\n                         (hash-union\n                           (for/hash ([inv invspost])\n                             (values (format \"invariant ~v is not maintained\" (car inv)) (cdr inv)))\n                           (hash \"return values are not equal\" eqpost\n                                 \"adversary calls differ\" replayed))\n                         (list retL retR)\n                         (list ctxL ctxR)\n                         args))))))\n\n  ; aggregate all the preconditions generated by this proof\n  ; and remove them from the global context (so they don't appear in later proofs)\n  (define new-asserts (asserts))\n  (define precondition\n    (let* ([delta (- (length new-asserts) (length old-asserts))]\n           [new-as (take new-asserts delta)]\n           [old-as (drop new-asserts delta)])\n      (clear-asserts!)\n      (for ([a (reverse old-as)]) (assert a))\n      (apply && new-as)))\n  \n  ; build the actual predicate\n  (define pred\n    (=> precondition\n        (and\n         BothObjects\n         InvariantBase\n         (=> InvariantInit\n             (apply && (for/list ([mp MethodProofs]) (MethodProof-predicate mp)))))))\n\n  (define full-pre (and precondition BothObjects InvariantBase InvariantInit))\n\n  ; build the proof parts\n  (define parts\n    (hash-set\n      (for/hash ([inv invsbase])\n        (values (format \"invariant ~v does not hold in the initial context\" (car inv)) (cdr inv)))\n      \"both sides of a proof must be objects\" BothObjects))\n  \n  (EquivalenceProof lhs rhs pred parts MethodProofs (list ctx1* ctx2*) full-pre vacuity?))\n```"}]}
{"messages": [{"role": "system", "content": "You are a Rosette engineer expert in symbolic execution and solver-aided programming."}, {"role": "user", "content": "Show me Rosette code that checks an EquivalenceProof, printing counterexample contexts and method discrepancies when verification fails."}, {"role": "assistant", "content": "<think>\nAfter verifying the EquivalenceProof predicate with Rosette's solver I need to inspect the model on failure, so I evaluate stored symbolic contexts, dump their locals, and iterate through MethodProof obligations to display the specific violating part with evaluated arguments and return values.\n</think>\n\n```racket\n(define (print-context ctx)\n  (printf \"| this=~v  nextAddr=~v\\n\" (Context-ths ctx) (Context-nextAddr ctx))\n  (for/list ([addr/obj (Context-objs ctx)])\n    (match-define (cons addr obj) addr/obj)\n    (define mtds (assoc-get addr (Context-methods ctx)))\n    (if (adversary? mtds)\n        (printf \"| * object ~v [adversary trace: ~a]\\n\" addr (adversary->history-string mtds))\n        (let ([mtdlist (map car mtds)])\n          (if (> addr 0)\n              (printf \"| * object ~v [methods: ~a]\\n\" addr (string-join (map ~a mtdlist) \" \"))\n              (printf \"| * globals\\n\"))\n          (for/list ([l/v (Object-locals obj)])\n            (printf \"|   * ~v = ~a\\n\" (car l/v) (value-to-string (cdr l/v))))))))\n\n(define (check-equivalence-proof p)\n  (match-define (EquivalenceProof e1 e2 pred parts methods contexts precond vacuity?) p)\n  (define m (complete-solution (verify (assert pred)) (symbolics p)))\n  (cond\n    [(sat? m)\n     (define (failure)\n       (printf \"\\ncould not prove equivalence. counterexample:\\n\")\n       (for ([(c i) (in-indexed contexts)])\n         (printf \"| context ~v:\\n\" i)\n         ;(pretty-print (evaluate c m))\n         (print-context (evaluate c m)))\n       (for ([(name p) parts])\n         (unless (evaluate p m)\n           (printf \"* ~a\\n\" name)))\n       (for ([mp methods])\n         (match-define (MethodProof predicate method parts values mtd-contexts args) mp)\n         (unless (evaluate predicate m)\n           (parameterize ([print-errors? #t])\n             (printf \"method ~a(~a):\\n\" (Method-name method) (string-join (map value-to-string (evaluate args m)) \", \"))\n             (printf \"* LHS returns ~a\\n* RHS returns ~a\\n\"\n                     (value-to-string (evaluate (car values) m))\n                     (value-to-string (evaluate (cadr values) m)))\n             (printf \"| LHS context:\\n\")\n             (print-context (evaluate (car mtd-contexts) m))\n             ;(pretty-print (evaluate (car mtd-contexts) m))\n             (printf \"| RHS context:\\n\")\n             (print-context (evaluate (cadr mtd-contexts) m))\n             ;(pretty-print (evaluate (cadr mtd-contexts) m))\n             (for ([(name p) parts])\n               (unless (evaluate p m)\n                 (printf \"* ~a\\n\" name)))))))\n     (values #f failure)]\n    [vacuity?\n     (define pre (apply && (for/list ([(_ p) (in-hash parts)]) p)))\n     (define method-vacuity\n       (for/list ([mp methods])\n         (define retL (car (MethodProof-values mp)))\n         (define retR (cadr (MethodProof-values mp)))\n         (define vac? (solve (assert (and precond (not (Error? retL))))))\n         (define m_vac (complete-solution vac? (symbolics mp)))\n         (if (sat? m_vac)\n             (cons (evaluate retL m_vac) (evaluate (MethodProof-args mp) m_vac))\n             m_vac)))\n     (define (success)\n       (printf \"equivalent on methods:\\n\")\n       (for ([mp methods][mv method-vacuity])\n         (match-define (MethodProof _ method _ _ _ _) mp)\n         (if (solution? mv)\n             (printf \"* ~a (NO GOOD RETURN VALUE?)\\n\" (Method-name method))\n             (let ([name (Method-name method)]\n                   [ret (value-to-string (car mv))]\n                   [args (string-join (map value-to-string (cdr mv)) \", \")])\n               (printf \"* ~a (possible return: ~a(~a) = ~a)\\n\" name name args ret)))))\n     (values #t success)]\n    [else\n     (define (success)\n       (printf \"equivalent on methods: \")\n       (for ([mp methods])\n         (printf \"~v \" (Method-name (MethodProof-method mp))))\n       (printf \"\\n\"))\n     (values #t success)]))\n```"}]}
{"messages": [{"role": "system", "content": "You are a Rosette engineer expert in symbolic execution and solver-aided programming."}, {"role": "user", "content": "I need a proof checker that validates a rewrite by substituting a known assumption into the left-hand side before comparing expressions."}, {"role": "assistant", "content": "<think>\nTo validate a proposed rewrite it is enough to substitute the proven equivalence pair inside the LHS, compare it to the RHS, and fall back to failure reporting when the substitution misses or the expressions still differ.\n</think>\n\n```racket\n(define (check-rewrite-proof p)\n  ; lhs, rhs are the goals\n  ; e1, e2 are the substitutions\n  ; we want to check lhs[e1 := e2] == rhs\n  (match-define (RewriteProof lhs rhs ctx e1 e2 assumptions) p)\n  (define is-assumed-pair\n    (for/or ([pair assumptions])\n      (and (equal? (car pair) e1)\n           (equal? (cdr pair) e2))))\n  (cond\n    [is-assumed-pair\n     ; rewrite the lhs\n     (define lhs-rewrite (rewrite-expr lhs e1 e2))\n     (cond\n       [(equal? lhs-rewrite rhs)\n        (values #t (thunk (printf \"replaced ~a with ~a\\n\" (expr-to-string e1) (expr-to-string e2))))]\n       [else\n        (values #f (thunk (printf \"substitution did not succeed\\n\")\n                          (printf \"LHS after substitution:\\n\")\n                          (print-expr lhs-rewrite)\n                          (printf \"\\nRHS:\\n\")\n                          (print-expr rhs)))])]\n    [else\n     (values #f (thunk (printf \"no proof of ~a ~~ ~a found\\n\" (expr-to-string e1) (expr-to-string e2))))]))\n```"}]}
{"messages": [{"role": "system", "content": "You are a Rosette engineer expert in symbolic execution and solver-aided programming."}, {"role": "user", "content": "Provide a dispatcher that accepts any Proof variant, routes it to the correct checker, and reports success or failure (including a helper to enforce raw asserts)."}, {"role": "assistant", "content": "<think>\nProvide a single entry point that distinguishes among equivalence, rewrite, or admitted proofs, delegates to the proper checker, and reports success or failure while exiting on counterexamples; also include a helper that raises when a boolean constraint is satisfiable.\n</think>\n\n```racket\n(define (check-admit-proof p)\n  (values #t (thunk (printf \"(admitted)\\n\"))))\n\n(define (check-proof proof)\n  (match-define (Proof lhs rhs) proof)\n  (define checker\n    (cond\n      [(EquivalenceProof? proof)\n       check-equivalence-proof]\n      [(RewriteProof? proof)\n       check-rewrite-proof]\n      [(AdmitProof? proof)\n       check-admit-proof]\n      [else\n       (error 'check-proof \"unknown proof ~v\" proof)]))\n  (define-values (succ ret) (checker proof))\n  (if succ\n      (let ()\n        (printf \"\\nProved:\\n  \")(print-expr lhs)(printf \"\\n~~\\n  \")(print-expr rhs)(printf \"\\n\")\n        (ret)\n        (printf \"\\n\"))\n      (let ()\n        (printf \"\\nFAILED:\\n  \")(print-expr lhs)(printf \"\\n~~\\n  \")(print-expr rhs)(printf \"\\n\")\n        (ret)\n        (printf \"\\n\")\n        (exit 1)))\n  (flush-output))\n\n\n(define (check-assert a)\n  (define m (verify (assert a)))\n  (when (sat? m)\n    (error \"assert failed\")))\n```"}]}
{"messages": [{"role": "system", "content": "You are a Rosette engineer expert in symbolic execution and solver-aided programming."}, {"role": "user", "content": "Write a default EquivalenceInvariant that simply requires all fields shared by two objects to match."}, {"role": "assistant", "content": "<think>\nModel an equivalence invariant that simply walks the locals of both objects and requires every shared field to have equal values, quantifying over each pair with Rosette's for*/all and implication so that missing fields are ignored.\n</think>\n\n```racket\n; A default invariant that requires all common fields to be equal\n(define DefaultInvariant\n  (EquivalenceInvariant (lambda (ctx1 ctx2 addr1 addr2)\n    (define locals1 (Object-locals (assoc-get addr1 (Context-objs ctx1))))\n    (define locals2 (Object-locals (assoc-get addr2 (Context-objs ctx2))))\n    (for*/all ([locals1 locals1][locals2 locals2])\n      (apply && (for/list ([k/v locals1])\n                  (=> (not (false? (assoc-get (car k/v) locals2)))\n                      (equal? (cdr k/v) (assoc-get (car k/v) locals2)))))))))\n```"}]}
