{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I need to validate that @bveq over conditional 4-bit operands reduces to the guard when the bit patterns line up. Can you write the Rosette checks for all boolean branches?"},{"role":"assistant","content":"<think>\ncheck-valid? evaluates the operator application, asserts equality with the expected Boolean, and then calls solve on the negated @equal? so unsat enforces the rewrite. Here I instantiate BV=(bitvector 4) with symbolic booleans a/b and ITE patterns so Boolector must confirm each @bveq collapses to the guard (or constant #f/#t) without producing a counterexample.\n</think>\n\n```racket\n(define BV (bitvector 4))\n(define-symbolic x y z BV)\n(define-symbolic a b c d e f g @boolean?)\n\n(define (bv v [t BV]) (@bv v t))\n\n(define-syntax-rule (define-tests (name arg ...) body ...)\n  (define (name arg ...)\n    (begin\n     (clear-vc!)\n     body ...\n     (clear-vc!))))\n\n(define-syntax-rule (check-valid? (op e ...) expected)\n  (let ([actual (op e ...)])\n    (check-equal? actual expected)\n    (check-pred unsat? (solve (! (@equal? (expression op e ...) expected))))))\n\n(define-tests (check-bveq-simplifications)\n  (check-valid? (@bveq (ite b (bv 2) (bv 0)) (bv 2)) b)\n  (check-valid? (@bveq (ite b (bv 2) (bv 0)) (bv 0)) (! b))\n  (check-valid? (@bveq (ite b (bv 2) (bv 0)) (bv 1)) #f)\n  (check-valid? (@bveq (bv 2) (ite b (bv 2) (bv 0))) b)\n  (check-valid? (@bveq (bv 0) (ite b (bv 2) (bv 0))) (! b))\n  (check-valid? (@bveq (bv 1) (ite b (bv 2) (bv 0))) #f)\n  (check-valid? (@bveq (ite a (bv 2) (bv 2)) (ite b (bv 2) (bv 2))) #t)\n  (check-valid? (@bveq (ite a (bv 2) (bv 3)) (ite b (bv 4) (bv 5))) #f)\n  (check-valid? (@bveq (ite a (bv 2) (bv 3)) (ite b (bv 2) (bv 5))) (&& a b))\n  (check-valid? (@bveq (ite a (bv 2) (bv 3)) (ite b (bv 5) (bv 2))) (&& a (! b)))\n  (check-valid? (@bveq (ite a (bv 2) (bv 3)) (ite b (bv 3) (bv 5))) (&& (! a) b))\n  (check-valid? (@bveq (ite a (bv 2) (bv 3)) (ite b (bv 5) (bv 3))) (&& (! a) (! b))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Can you confirm that our signed less-than simplifier on 4-bit bitvectors handles symmetry and the min/max sentinels without leaving counterexamples?"},{"role":"assistant","content":"<think>\ncheck-bvcmp-simplifications ties each less-than operator to its dual greater-than, and check-valid? again uses solve on the negated @equal? so unsat proves the rewrite. With minval/maxval derived from the 4-bit type, Boolector has to show that every @bvslt boundary test collapses to either #t/#f or a single @bveq guard.\n</think>\n\n```racket\n(define BV (bitvector 4))\n(define-symbolic x y z BV)\n(define-symbolic a b c d e f g @boolean?)\n\n(define minval (- (expt 2 (sub1 (bitvector-size BV)))))\n(define maxval+1 (expt 2 (sub1 (bitvector-size BV))))\n(define maxval (sub1 maxval+1))\n(define (bv v [t BV]) (@bv v t))\n\n(define-syntax-rule (define-tests (name arg ...) body ...)\n  (define (name arg ...)\n    (begin\n     (clear-vc!)\n     body ...\n     (clear-vc!))))\n\n(define-syntax-rule (check-valid? (op e ...) expected)\n  (let ([actual (op e ...)])\n    (check-equal? actual expected)\n    (check-pred unsat? (solve (! (@equal? (expression op e ...) expected))))))\n\n(define-tests (check-bvcmp-simplifications l* g*)\n  (check-equal? (g* x y) (l* y x))\n  (check-valid? (l* (ite b (bv 2) (bv 0)) (bv 1)) (! b))\n  (check-valid? (l* (ite b (bv 1) (bv 3)) (bv 2)) b)\n  (check-valid? (l* (ite b (bv 2) (bv 1)) (bv 3)) #t)\n  (check-valid? (l* (ite b (bv 2) (bv 1)) (bv 0)) #f)\n  (check-valid? (l* (bv 1) (ite b (bv 2) (bv 0))) b)\n  (check-valid? (l* (bv 1) (ite b (bv 0) (bv 3))) (! b))\n  (check-valid? (l* (bv 3) (ite b (bv 2) (bv 1))) #f)\n  (check-valid? (l* (bv 0) (ite b (bv 2) (bv 1))) #t)\n  (check-valid? (l* (ite a (bv 2) (bv 1)) (ite b (bv 3) (bv 4))) #t)\n  (check-valid? (l* (ite b (bv 3) (bv 4)) (ite a (bv 2) (bv 1))) #f)\n  (check-valid? (l* (ite a (bv 3) (bv 1)) (ite b (bv 0) (bv 2))) (&& (! a) (! b)))\n  (check-valid? (l* (ite a (bv 1) (bv 3)) (ite b (bv 2) (bv 0))) (&& a b))\n  (check-valid? (l* (ite a (bv 1) (bv 3)) (ite b (bv 0) (bv 2))) (&& a (! b)))\n  (check-valid? (l* (ite a (bv 3) (bv 1)) (ite b (bv 2) (bv 0))) (&& (! a) b)))\n\n(define-tests (check-bvslt-simplifications)\n  (check-bvcmp-simplifications @bvslt @bvsgt)\n  (check-valid? (@bvslt x (bv maxval)) (! (@bveq x (bv maxval))))\n  (check-valid? (@bvslt (bv maxval) x) #f)\n  (check-valid? (@bvslt x (bv minval)) #f)\n  (check-valid? (@bvslt (bv minval) x) (! (@bveq x (bv minval)))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Please prove that the small bitvector adder canonicalizer eliminates redundant operands and commutes literal constants correctly."},{"role":"assistant","content":"<think>\ncheck-bvadd-simplifications first runs check-nary to ensure @bvadd honors the identity element and permutation invariants, then each check-valid? call asks the solver to refute the negated equality so cancellations with @bvneg and literal regroupings are validated for symbolic x/y/z.\n</think>\n\n```racket\n(define BV (bitvector 4))\n(define-symbolic x y z BV)\n(define-symbolic a b c d e f g @boolean?)\n\n(define (bv v [t BV]) (@bv v t))\n\n(define-syntax-rule (define-tests (name arg ...) body ...)\n  (define (name arg ...)\n    (begin\n     (clear-vc!)\n     body ...\n     (clear-vc!))))\n\n(define-tests (check-nary op id x y z)\n  (check-equal? (op id id) id)\n  (check-equal? (op id id id) id)\n  (check-equal? (op x) x)\n  (check-equal? (op id x) x)\n  (check-equal? (op x id) x)\n  (check-equal? (op x id y) (op x y))\n  (check-equal? (op x y) (op y x))\n)\n\n(define-syntax-rule (check-valid? (op e ...) expected)\n  (let ([actual (op e ...)])\n    (check-equal? actual expected)\n    (check-pred unsat? (solve (! (@equal? (expression op e ...) expected))))))\n\n(define-tests (check-bvadd-simplifications)\n  (check-nary @bvadd (bv 0) x y z)\n  (check-valid? (@bvadd (bv 1) x) (@bvadd x (bv 1)))\n  (check-valid? (@bvadd x (@bvneg x)) (bv 0))\n  (check-valid? (@bvadd (@bvneg x) x) (bv 0))\n  (check-valid? (@bvadd (@bvneg (@bvadd x y)) x) (@bvneg y))\n  (check-valid? (@bvadd (@bvneg (@bvadd x y)) y) (@bvneg x))\n  (check-valid? (@bvadd (@bvadd (@bvneg x) y) x) y)\n  (check-valid? (@bvadd (@bvadd x (@bvneg y)) y) x)\n  (check-valid? (@bvadd (@bvadd (bv 5) y) (bv -5)) y)\n  (check-valid? (@bvadd (@bvadd x y) (@bvneg x)) y)\n  (check-valid? (@bvadd (@bvadd x y) (@bvneg y)) x)\n  (check-valid? (@bvadd (@bvadd x y) (@bvadd (@bvneg x) (@bvneg y) z)) z)\n  (check-valid? (@bvadd (@bvadd x y z) (@bvadd (@bvneg x) (@bvneg y) (@bvneg z))) (bv 0))\n  (check-valid? (@bvadd (@bvadd y z) (@bvadd (bv 1) (@bvneg y) (@bvneg z))) (bv 1))\n  (check-valid? (@bvadd (@bvadd (bv 1) y z) (@bvadd (bv -1) (@bvneg y) (@bvneg z))) (bv 0))\n  (check-valid? (@bvadd (@bvadd (bv 1) y z) (@bvadd (bv -1) (@bvneg z))) y)\n  (check-valid? (@bvadd x y z (@bvadd (@bvneg x) (@bvneg y))) z)\n  (check-valid? (@bvadd x y z (@bvadd (@bvneg x) (@bvneg y)) (@bvneg z)) (bv 0))\n  (check-valid? (@bvadd x (bv 0) y (bv 1) z (bv 5)) (@bvadd (bv 6) x y z))\n  (check-valid? (@bvadd (@bvmul y x) (@bvmul x (@bvneg y))) (bv 0))\n  (check-valid? (@bvadd (@bvmul x (@bvneg y)) (@bvmul y x)) (bv 0))\n  (check-valid? (@bvadd (@bvmul (bv 3) x) (@bvmul x (bv -3))) (bv 0))\n  (check-valid? (@bvadd (@bvmul (bv 3) x) (@bvmul x (bv 2))) (@bvmul (bv 5) x)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I want to ensure our unsigned division primitive rewrites match SMT semantics for div-by-zero and self-division across symbolic operands. Can you encode that Rosette check?"},{"role":"assistant","content":"<think>\nEvery check-valid? call evaluates a @bvudiv instance, compares it with the expected MIPS-like behavior (bv -1 on zero divisors, ite guards for symbolic cases), and then calls solve on the negated equality so Boolector must prove the rewrite valid or return a counterexample.\n</think>\n\n```racket\n(define BV (bitvector 4))\n(define-symbolic x y z BV)\n(define-symbolic a b c d e f g @boolean?)\n\n(define (bv v [t BV]) (@bv v t))\n\n(define-syntax-rule (define-tests (name arg ...) body ...)\n  (define (name arg ...)\n    (begin\n     (clear-vc!)\n     body ...\n     (clear-vc!))))\n\n(define-syntax-rule (check-valid? (op e ...) expected)\n  (let ([actual (op e ...)])\n    (check-equal? actual expected)\n    (check-pred unsat? (solve (! (@equal? (expression op e ...) expected))))))\n\n(define-tests (check-bvudiv-simplifications)\n  (check-valid? (@bvudiv (bv 3) (bv 0)) (bv -1))\n  (check-valid? (@bvudiv x (bv 0)) (bv -1))\n  (check-valid? (@bvudiv (bv 3) (bv 1)) (bv 3))\n  (check-valid? (@bvudiv x (bv 1)) x)\n  (check-valid? (@bvudiv x (bv -1)) (ite (@bveq x (bv -1)) (bv 1) (bv 0)))\n  (check-valid? (@bvudiv (bv 0) x) (ite (@bveq x (bv 0)) (bv -1) (bv 0)))\n  (check-valid? (@bvudiv x x) (ite (@bveq x (bv 0)) (bv -1) (bv 1)))\n  (check-valid? (@bvudiv (ite b (bv 6) (bv 8)) (bv 2)) (ite b (bv 3) (bv 4)))\n  (check-valid? (@bvudiv (bv 6) (ite b (bv 2) (bv 3))) (ite b (bv 3) (bv 2))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Please show that @concat on arbitrary width operands really matches the solver semantics by synthesizing witnesses for every pair of input sizes."},{"role":"assistant","content":"<think>\ncheck-concat-semantics iterates all signed values representable in the 4-bit domain, builds concrete width-refined bitvectors for each pair, and asks solve to reconstruct vo given vi/vj constraints; unsat on the negated equality would expose a counterexample, so equality of actual vs expected validates Rosette's @concat semantics.\n</think>\n\n```racket\n(define BV (bitvector 4))\n(define-symbolic x y z BV)\n(define minval (- (expt 2 (sub1 (bitvector-size BV)))))\n(define maxval+1 (expt 2 (sub1 (bitvector-size BV))))\n(define maxval (sub1 maxval+1))\n(define (bv v [t BV]) (@bv v t))\n\n(define-syntax-rule (define-tests (name arg ...) body ...)\n  (define (name arg ...)\n    (begin\n     (clear-vc!)\n     body ...\n     (clear-vc!))))\n\n(define-tests (check-concat-semantics)\n  (for* ([i (in-range minval maxval+1)]\n         [j (in-range minval maxval+1)])\n    (define BVi (bitvector (max 1 (integer-length i))))\n    (define BVj (bitvector (max 1 (integer-length j))))\n    (define BVo (bitvector (+ (bitvector-size BVi) (bitvector-size BVj))))\n    (define-symbolic* vi BVi)\n    (define-symbolic* vj BVj)\n    (define-symbolic* vo BVo)\n    (define actual (@concat (bv i BVi) (bv j BVj)))\n    ;(printf \"(~a ~a ~a) = ~a\\n\" @concat (bv i BVi) (bv j BVj) actual)\n    (define expected \n      ((solve (@bveq (bv i BVi) vi)\n              (@bveq (bv j BVj) vj)\n              (@bveq (@concat vi vj) vo)) vo))\n    (check-equal? actual expected)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Can you codify the extract simplifications so we know every projected slice either returns the original value or the precise sub-slice, including interactions with concat and extensions?"},{"role":"assistant","content":"<think>\ncheck-extract-simplifications enumerates every rewrite we rely on: full-span extracts should be identity, nested extracts collapse, and slices through concat/extend reduce to smaller expressions. Each check-valid? drives solve on the negated equality so Boolector proves no counterexample exists.\n</think>\n\n```racket\n(define BV (bitvector 4))\n(define-symbolic x y z BV)\n(define-symbolic a b c d e f g @boolean?)\n\n(define-syntax-rule (define-tests (name arg ...) body ...)\n  (define (name arg ...)\n    (begin\n     (clear-vc!)\n     body ...\n     (clear-vc!))))\n\n(define-syntax-rule (check-valid? (op e ...) expected)\n  (let ([actual (op e ...)])\n    (check-equal? actual expected)\n    (check-pred unsat? (solve (! (@equal? (expression op e ...) expected))))))\n\n(define-tests (check-extract-simplifications)\n  (check-valid? (@extract 3 0 x) x)\n  (check-valid? (@extract 3 0 (@bvadd x y)) (@bvadd x y))\n  (check-valid? (@extract 2 1 (@extract 3 1 x)) (@extract 3 2 x))\n  (check-valid? (@extract 0 0 (@concat x (bv 1 1))) (bv 1 1))\n  (check-valid? (@extract 3 0 (@concat x y)) y)\n  (check-valid? (@extract 2 0 (@concat x y)) (@extract 2 0 y))\n  (check-valid? (@extract 7 4 (@concat x y)) x)\n  (check-valid? (@extract 7 5 (@concat x y)) (@extract 3 1 x))\n  (check-valid? (@extract 2 0 (@sign-extend x (bitvector 8))) (@extract 2 0 x))\n  (check-valid? (@extract 2 0 (@zero-extend x (bitvector 8))) (@extract 2 0 x))\n  (check-valid? (@extract 3 0 (@sign-extend x (bitvector 8))) x)\n  (check-valid? (@extract 3 0 (@zero-extend x (bitvector 8))) x)\n  (check-valid? (@extract 4 0 (@sign-extend x (bitvector 8))) (@sign-extend x (bitvector 5)))\n  (check-valid? (@extract 4 0 (@zero-extend x (bitvector 8))) (@zero-extend x (bitvector 5)))\n  (define-symbolic* n @integer?)\n  (check-equal? (type-of (@extract n n x)) (bitvector 1))\n  )\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I need reassurance that bool->bitvector and bitvector->bool are inverses under our guards, including cases where the variants are symbolic unions. Can you capture the Rosette proof obligations?"},{"role":"assistant","content":"<think>\ncheck≡ snapshots each computation with with-vc, compares vc-assumes/vc-asserts via verify, and then assumes those predicates before checking result-value equality. Instantiating bool->bitvector/bitvector->bool with symbolic x/y/z forces the solver to respect bvzero? semantics and the guard obligations when merging symbolic unions.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui (rename-in rackunit [check-exn rackunit/check-exn])\n         rosette/lib/roseunit (only-in rosette/base/core/merge merge*))\n(require (only-in rosette/base/core/bool vc-assumes vc-asserts) )\n\n(define-symbolic z (bitvector 1))\n(define-symbolic x u (bitvector 4))\n(define-symbolic y w (bitvector 8))\n(define-symbolic i integer?)\n(define-symbolic b c boolean?)\n\n(define-syntax-rule (check≡ actual expected)\n  (let ([ra (with-vc actual)]\n        [re (with-vc expected)])\n    (check-pred unsat?\n                (verify (assert (equal? (vc-assumes (result-state ra))\n                                        (vc-assumes (result-state re))))))\n    (check-pred unsat?\n                (verify (assert (equal? (vc-asserts (result-state ra))\n                                        (vc-asserts (result-state re))))))\n    (check-pred unsat?\n                (verify (begin (assume (&& (vc-assumes (result-state ra)) (vc-asserts (result-state ra))))\n                               (assert (equal? (result-value ra) (result-value re))))))))\n\n(define (check-bv<->bool)\n  (check≡ (bool->bitvector #t) (bv 1 1))\n  (check≡ (bool->bitvector #f) (bv 0 1))\n  (check≡ (bool->bitvector 'foo) (bv 1 1))\n  (check≡ (bool->bitvector b) (if b (bv 1 1) (bv 0 1)))\n  (check≡ (bool->bitvector (if b 1 'foo)) (bv 1 1))\n  (check≡ (bool->bitvector #t 4) (bv 1 4))\n  (check≡ (bool->bitvector #f 4) (bv 0 4))\n  (check≡ (bool->bitvector 'foo 4) (bv 1 4))\n  (check≡ (bool->bitvector b 4) (if b (bv 1 4) (bv 0 4)))\n  (check≡ (bool->bitvector (if b 1 'foo) 4) (bv 1 4))\n  (check≡ (bitvector->bool x) (! (bvzero? x)))\n  (check≡ (bitvector->bool y) (! (bvzero? y)))\n  (check≡ (bitvector->bool (bv 0 4)) #f)\n  (check≡ (bitvector->bool (bv 2 4)) #t)\n  (check≡ (bitvector->bool (if b (bv 0 4) (bv 1 8))) (! b))\n  (check≡ (bitvector->bool (if b (bv 0 4) 'foo)) (begin (assert b) #f))\n  (check≡ (bitvector->bool (if b x 'foo)) (begin (assert b) (! (bvzero? x))))\n  (check≡ (bool->bitvector (bitvector->bool (bv 0 1))) (bv 0 1))\n  (check≡ (bool->bitvector (bitvector->bool (bv 1 1))) (bv 1 1))\n  (check≡ (bool->bitvector (bitvector->bool z)) z)\n  (check≡ (bitvector->bool (bool->bitvector b)) b)\n  (check-exn #px\"expected\" (thunk (bitvector->bool  -1))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Show me that length-bv agrees with length across lists, including when the size target is a symbolic union that may be ill-typed."},{"role":"assistant","content":"<think>\nThis bvseq harness defines a stronger check≡ that, besides VC equivalence, asserts an optional property argument inside verify. The length-bv specification maps a sequence into integer->bitvector, so each invocation compares VC states and result values while the solver enforces the guard assumptions for union types.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui (rename-in rackunit [check-exn rackunit/check-exn])\n         rosette/lib/roseunit (only-in rosette/base/core/merge merge*))\n\n(define-symbolic b2 (bitvector 2))\n(define-symbolic b3 (bitvector 3))\n\n(define-symbolic a c d e boolean?)\n\n(define b2∪3 (if a b2 b3))\n(define b2∪3∪Err (if c b2∪3 'err))\n\n(define-syntax-rule (check≡ actual expected prop ...)\n  (let ([ra (with-vc (call-with-values (lambda () actual) list))]\n        [re (with-vc (call-with-values (lambda () expected) list))])\n    (check-pred unsat?\n                (verify (assert (equal? (vc-assumes (result-state ra))\n                                        (vc-assumes (result-state re))))))\n    ;(printf \"VC:~a\nActual: ~a\nExpected: ~a\n\" (vc) (result-state ra) (result-state re))\n    ;(printf \"Actual: ~a\nExpected: ~a\n\" ra re)\n    (check-pred unsat?\n                (verify (assert (equal? (vc-asserts (result-state ra))\n                                        (vc-asserts (result-state re))))))\n    (check-pred unsat?\n                (verify (begin (assume (&& (vc-assumes (result-state ra)) (vc-asserts (result-state ra))))\n                               (assert (equal? (result-value ra) (result-value re))))))\n    (check-pred unsat?\n                (verify (begin (assume (&& (vc-assumes (result-state ra)) (vc-asserts (result-state ra))))\n                               (assert prop)))) ...))\n\n(define (check-length-bv length-bv length make)\n  (define (spec xs t)\n    (integer->bitvector (length xs) t))\n\n  (define t3 (bitvector 3))\n  (define t4 (bitvector 4))\n  (define t3∪4 (if a t3 t4))\n  (define t3∪4∪Err (if c t3∪4 'bad))\n  \n  (define (checks vs)\n    (check≡ (length-bv xs t4) (spec xs t4))\n    (check≡ (length-bv xs t3∪4) (spec xs t3∪4))\n    (check≡ (length-bv xs t3∪4∪Err) (spec xs t3∪4∪Err)))\n  \n  (define xs (make 1 2 3 4 5))\n  (define ys (if d xs (make 6 7 8 9 10 11 12)))\n\n  (checks xs)\n  (checks ys)\n  (checks (if e ys (make)))\n  (checks (if e ys 'bad)))\n```"}]}
