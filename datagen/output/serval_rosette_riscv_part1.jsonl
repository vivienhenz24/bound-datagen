{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"I need the Rosette semantics for the base RV64I R-type ALU instructions (add/sub/xor/etc.) so I can plug them into my symbolic CPU executor."},{"role":"assistant","content":"<think>\nThe decoder pattern-matches funct7/funct3/opcode to ensure the instruction word really is an ALU R-type and then passes the rs2/rs1/rd bitfields through decode-gpr so the register file indices become symbolic register names.\nreg-reg-op pulls symbolic register values with gpr-ref, applies the requested bitvector operator, and pushes the symbolic result back with gpr-set!, while the memory manager is untouched for these pure ALU ops.\nBecause operands/results stay symbolic bitvectors, the solver just tracks the equalities produced by reg-reg-op and the only constraint asserted is the XLEN guard in reg-reg-opw when RV64-only forms are selected.\n</think>\n\n```racket\n#lang rosette\n\n(require \"common.rkt\")\n\n; Regular r-type insn.\n(define ((interpret-r-type op) cpu insn rs2 rs1 rd)\n  (reg-reg-op op cpu insn (decode-gpr rs2) (decode-gpr rs1) (decode-gpr rd)))\n\n; 32-bit ops on rv64.\n(define ((interpret-rw-type op) cpu insn rs2 rs1 rd)\n  (reg-reg-opw op cpu insn (decode-gpr rs2) (decode-gpr rs1) (decode-gpr rd)))\n\n; R-type\n(define-insn (rs2 rs1 rd)\n  #:encode (lambda (funct7 funct3 opcode)\n                   (list (bv funct7 7) rs2 rs1 (bv funct3 3) rd (bv opcode 7)))\n  [(#b0000000 #b000 #b0110011) add (interpret-r-type bvadd)]\n  [(#b0100000 #b000 #b0110011) sub (interpret-r-type bvsub)]\n  [(#b0000000 #b001 #b0110011) sll (interpret-r-type (make-shift-op bvshl))]\n  [(#b0000000 #b010 #b0110011) slt (interpret-r-type (make-cmp-op bvslt))]\n  [(#b0000000 #b011 #b0110011) sltu (interpret-r-type (make-cmp-op bvult))]\n  [(#b0000000 #b100 #b0110011) xor (interpret-r-type bvxor)]\n  [(#b0000000 #b101 #b0110011) srl (interpret-r-type (make-shift-op bvlshr))]\n  [(#b0100000 #b101 #b0110011) sra (interpret-r-type (make-shift-op bvashr))]\n  [(#b0000000 #b110 #b0110011) or_ (interpret-r-type bvor)]\n  [(#b0000000 #b111 #b0110011) and_ (interpret-r-type bvand)]\n\n  ; RV64I Base Instruction Set (in addition to RV32I)\n  [(#b0000000 #b000 #b0111011) addw (interpret-rw-type bvadd)]\n  [(#b0100000 #b000 #b0111011) subw (interpret-rw-type bvsub)]\n  [(#b0000000 #b001 #b0111011) sllw (interpret-rw-type (make-shift-op bvshl))]\n  [(#b0000000 #b101 #b0111011) srlw (interpret-rw-type (make-shift-op bvlshr))]\n  [(#b0100000 #b101 #b0111011) sraw (interpret-rw-type (make-shift-op bvashr))]\n\n  ; RV32M Standard Extension\n  [(#b0000001 #b000 #b0110011) mul (interpret-r-type (core:bvmul-proc))]\n  [(#b0000001 #b001 #b0110011) mulh (interpret-r-type (core:bvmulh-proc))]\n  [(#b0000001 #b010 #b0110011) mulhsu (interpret-r-type (core:bvmulhsu-proc))]\n  [(#b0000001 #b011 #b0110011) mulhu (interpret-r-type (core:bvmulhu-proc))]\n  [(#b0000001 #b100 #b0110011) div (interpret-r-type\n    (lambda (v1 v2) (if (bvzero? v2) (bv -1 (core:bv-size v1)) ((core:bvsdiv-proc) v1 v2))))]\n  [(#b0000001 #b101 #b0110011) divu (interpret-r-type (core:bvudiv-proc))]\n  [(#b0000001 #b110 #b0110011) rem (interpret-r-type\n    (lambda (v1 v2) (if (bvzero? v2) v1 ((core:bvsrem-proc) v1 v2))))]\n  [(#b0000001 #b111 #b0110011) remu (interpret-r-type (core:bvurem-proc))]\n\n  ; RV64M Standard Extension (in addition to RV32M)\n  [(#b0000001 #b000 #b0111011) mulw (interpret-rw-type (core:bvmul-proc))]\n  [(#b0000001 #b100 #b0111011) divw (interpret-rw-type\n    (lambda (v1 v2) (if (bvzero? v2) (bv -1 (core:bv-size v1)) ((core:bvsdiv-proc) v1 v2))))]\n  [(#b0000001 #b101 #b0111011) divuw (interpret-rw-type (core:bvudiv-proc))]\n  [(#b0000001 #b110 #b0111011) remw (interpret-rw-type\n    (lambda (v1 v2) (if (bvzero? v2) v1 ((core:bvsrem-proc) v1 v2))))]\n  [(#b0000001 #b111 #b0111011) remuw (interpret-rw-type (core:bvurem-proc))]\n)\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"Show me how Serval captures the AMO R-type instructions so I can reason about LR/SC style atomic memory exchanges in Rosette."},{"role":"assistant","content":"<think>\nThe AMO decoder grabs funct5/funct3/opcode along with the aq/rl bits and the rs/rd fields so we know exactly which atomic op and operand registers are being referenced.\ninterpret-amo-insn reads the symbolic rs1 register to form the address, uses the memory manager to load/store symbolic bytes atomically, and updates rd/rs2 via gpr-set! with the old/new values.
core:bug-on adds the no-amo.d-on-rv32 constraint, and because for/all isn't used here the solver's path condition is just the bitvector equations emitted by the memmgr load/store plus any aq/rl choices.\n</think>\n\n```racket\n#lang rosette\n\n(require \"common.rkt\")\n\n(define ((interpret-amo-insn op size) cpu insn aq rl rs2 rs1 rd)\n  (define mm (cpu-memmgr cpu))\n  (define xlen (cpu-xlen cpu))\n  (core:bug-on (&& (= size 8) (= xlen 32)) #:msg \"no amo*.d on rv32\")\n\n  (core:memmgr-atomic-begin mm)\n\n  (define addr (gpr-ref cpu (decode-gpr rs1)))\n  (define oldvalue (core:memmgr-load mm addr (bv 0 xlen) (bv size xlen)))\n  (gpr-set! cpu (decode-gpr rd) (sign-extend oldvalue (bitvector xlen)))\n  (define newvalue (op oldvalue (trunc (* 8 size) (gpr-ref cpu (decode-gpr rs2)))))\n  (core:memmgr-store! mm addr (bv 0 xlen) (trunc (* 8 size) newvalue) (bv size xlen))\n\n  (core:memmgr-atomic-end mm)\n  (cpu-next! cpu insn))\n\n; Atomic instructions\n(define-insn (aq rl rs2 rs1 rd)\n  #:encode (lambda (funct5 funct3 opcode)\n                   (list (bv funct5 5) aq rl rs2 rs1 (bv funct3 3) rd (bv opcode 7)))\n  [(#b00001 #b010 #b0101111) amoswap.w (interpret-amo-insn (lambda (v1 v2) v2) 4)]\n  [(#b00000 #b010 #b0101111) amoadd.w (interpret-amo-insn bvadd 4)]\n  [(#b00100 #b010 #b0101111) amoxor.w (interpret-amo-insn bvxor 4)]\n  [(#b01100 #b010 #b0101111) amoand.w (interpret-amo-insn bvand 4)]\n  [(#b01000 #b010 #b0101111) amoor.w (interpret-amo-insn bvor 4)]\n  [(#b10000 #b010 #b0101111) amomin.w (interpret-amo-insn bvsmin 4)]\n  [(#b10100 #b010 #b0101111) amomax.w (interpret-amo-insn bvsmax 4)]\n  [(#b11000 #b010 #b0101111) amominu.w (interpret-amo-insn bvumin 4)]\n  [(#b11100 #b010 #b0101111) amomaxu.w (interpret-amo-insn bvumax 4)]\n\n  [(#b00001 #b011 #b0101111) amoswap.d (interpret-amo-insn (lambda (v1 v2) v2) 8)]\n  [(#b00000 #b011 #b0101111) amoadd.d (interpret-amo-insn bvadd 8)]\n  [(#b00100 #b011 #b0101111) amoxor.d (interpret-amo-insn bvxor 8)]\n  [(#b01100 #b011 #b0101111) amoand.d (interpret-amo-insn bvand 8)]\n  [(#b01000 #b011 #b0101111) amoor.d (interpret-amo-insn bvor 8)]\n  [(#b10000 #b011 #b0101111) amomin.d (interpret-amo-insn bvsmin 8)]\n  [(#b10100 #b011 #b0101111) amomax.d (interpret-amo-insn bvsmax 8)]\n  [(#b11000 #b011 #b0101111) amominu.d (interpret-amo-insn bvumin 8)]\n  [(#b11100 #b011 #b0101111) amomaxu.d (interpret-amo-insn bvumax 8)])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"Can you provide the Rosette snippet that interprets I-type immediates (jalr, addi-family, and loads) using Serval's helpers?"},{"role":"assistant","content":"<think>\nThe I-type decoder slices the instruction into imm11:0/rs1/rd and the funct3/opcode constants, so immediates are sign-extended before applying reg-imm-op or memmgr access.\nAll register indices go through decode-gpr so gpr-ref/gpr-set! operate on symbolic register file entries, and interpret-load-insn turns the imm/rs1 fields into an address before hitting the symbolic memory manager.\ncore:bug-on enforces shamt bounds for rv32 and disallows lwu on rv32, which becomes part of the path constraints, and jalr masks bit0 to keep targets aligned while the solver reasons about the symbolic next PC.\n</think>\n\n```racket\n#lang rosette\n\n(require \"common.rkt\")\n\n(define ((interpret-i-type op) cpu insn imm11:0 rs1 rd)\n  (reg-imm-op op cpu insn imm11:0 (decode-gpr rs1) (decode-gpr rd)))\n\n(define ((interpret-iw-type op) cpu insn imm11:0 rs1 rd)\n  (reg-imm-opw op cpu insn imm11:0 (decode-gpr rs1) (decode-gpr rd)))\n\n(define ((interpret-ishift-type op) cpu insn shamt rs1 rd)\n  ; shamt is 6 bits: top bit must be 0 if rv32\n  (core:bug-on (&& (= (cpu-xlen cpu) 32) (bvuge shamt (bv 32 6))) #:msg \"32-bit shift immediate must be < 32\")\n  (define a (gpr-ref cpu (decode-gpr rs1)))\n  (define b (zero-extend shamt (bitvector (cpu-xlen cpu))))\n  (gpr-set! cpu (decode-gpr rd) (op a b))\n  (cpu-next! cpu insn))\n\n(define ((interpret-iwshift-type op) cpu insn shamt rs1 rd)\n  (core:bug-on (! (= (cpu-xlen cpu) 64)) #:msg \"*w: (cpu-xlen cpu) != 64\")\n  (define a (extract 31 0 (gpr-ref cpu (decode-gpr rs1))))\n  (define b (zero-extend shamt (bitvector 32)))\n  (gpr-set! cpu (decode-gpr rd) (sign-extend (op a b) (bitvector 64)))\n  (cpu-next! cpu insn))\n\n(define (interpret-jalr cpu insn imm11:0 rs1 rd)\n\n  (define next (bvadd (cpu-pc cpu) (bv 4 (cpu-xlen cpu))))\n  (gpr-set! cpu (decode-gpr rd) next)\n\n  (define target\n    (for/all ([src (gpr-ref cpu (decode-gpr rs1)) #:exhaustive])\n      (bvand\n        (bvnot (bv 1 (cpu-xlen cpu)))\n        (bvadd src (sign-extend imm11:0 (bitvector (cpu-xlen cpu)))))))\n  (set-cpu-pc! cpu target))\n\n(define ((interpret-load-insn size signed?) cpu insn imm11:0 rs1 rd)\n  (define mm (cpu-memmgr cpu))\n  (define xlen (cpu-xlen cpu))\n\n  (core:bug-on (&& (= xlen 32) (! signed?) (= size 4)) #:msg \"no lwu on rv32\")\n\n  (define addr (bvadd (gpr-ref cpu (decode-gpr rs1))\n                      (sign-extend imm11:0 (bitvector xlen))))\n\n  (define value (core:memmgr-load mm addr (bv 0 xlen) (bv size xlen)))\n\n  (set! value ((if signed? sign-extend zero-extend) value (bitvector xlen)))\n\n  (gpr-set! cpu (decode-gpr rd) value)\n  (cpu-next! cpu insn))\n\n; Regular I-type\n(define-insn (imm11:0 rs1 rd)\n  #:encode (lambda (funct3 opcode)\n                   (list imm11:0 rs1 (bv funct3 3) rd (bv opcode 7)))\n\n  [(#b000 #b1100111) jalr interpret-jalr]\n\n  [(#b000 #b0010011) addi (interpret-i-type bvadd)]\n  [(#b010 #b0010011) slti (interpret-i-type (make-cmp-op bvslt))]\n  [(#b011 #b0010011) sltiu (interpret-i-type (make-cmp-op bvult))]\n  [(#b100 #b0010011) xori (interpret-i-type bvxor)]\n  [(#b110 #b0010011) ori (interpret-i-type bvor)]\n  [(#b111 #b0010011) andi (interpret-i-type bvand)]\n\n  [(#b000 #b0011011) addiw (interpret-iw-type bvadd)]\n  [(#b001 #b0001111) fence.i skip]\n\n  [(#b000 #b0000011) lb (interpret-load-insn 1 #t)]\n  [(#b001 #b0000011) lh (interpret-load-insn 2 #t)]\n  [(#b010 #b0000011) lw (interpret-load-insn 4 #t)]\n  [(#b100 #b0000011) lbu (interpret-load-insn 1 #f)]\n  [(#b101 #b0000011) lhu (interpret-load-insn 2 #f)]\n\n  [(#b011 #b0000011) ld (interpret-load-insn 8 #t)]\n  [(#b110 #b0000011) lwu (interpret-load-insn 4 #f)])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"I also need the Rosette definitions for the standalone CSR I-type instructions (csrrw/csrrs/csrrc and their immediate forms)."},{"role":"assistant","content":"<think>\nThese instructions still parse as I-type but the decoder interprets the csr field as a CSR index plus an rs1/uimm immediate, so decode-csr turns the bitvector into the enumerated CSR symbol.\nThe helper reads/writes the symbolic CSR bank and general registers via csr-ref/csr-set! and gpr-set!, so both the CSR file and register file remain symbolic state objects.\nEach op function embodies the constraint about how csr bits change, so the solver just tracks the bitvector equations emitted along the execution path once cpu-next! advances the PC.\n</think>\n\n```racket\n#lang rosette\n\n(require \"common.rkt\")\n\n(define ((do-csr-op op) cpu insn csr rs1 rd)\n  (define xlen (cpu-xlen cpu))\n  (set! csr (decode-csr csr))\n  (set! rd (decode-gpr rd))\n  (set! rs1 (decode-gpr rs1))\n\n  (define old (zero-extend (csr-ref cpu csr) (bitvector xlen)))\n  (define new (gpr-ref cpu rs1))\n\n  (gpr-set! cpu rd old)\n\n  (csr-set! cpu csr (op old new))\n  (cpu-next! cpu insn))\n\n; CSR instructions\n(define-insn (csr rs1 rd)\n  #:encode (lambda (funct3 opcode)\n                   (list csr rs1 (bv funct3 3) rd (bv opcode 7)))\n  ; RV32/RV64 Zicsr Standard Extension\n  [(#b001 #b1110011) csrrw (do-csr-op (lambda (old new) new))]\n  [(#b010 #b1110011) csrrs (do-csr-op (lambda (old new) (bvor old new)))]\n  [(#b011 #b1110011) csrrc (do-csr-op (lambda (old new) (bvand old (bvnot new))))])\n\n(define ((do-csr-op-imm op) cpu insn csr uimm rd)\n  (define xlen (cpu-xlen cpu))\n  (set! csr (decode-csr csr))\n  (set! rd (decode-gpr rd))\n\n  (define old (zero-extend (csr-ref cpu csr) (bitvector xlen)))\n  (define new (zero-extend uimm (bitvector xlen)))\n\n  (gpr-set! cpu rd old)\n\n  (csr-set! cpu csr (op old new))\n  (cpu-next! cpu insn))\n\n; CSRI instructions\n(define-insn (csr uimm rd)\n  #:encode (lambda (funct3 opcode)\n                   (list csr uimm (bv funct3 3) rd (bv opcode 7)))\n  ; RV32/RV64 Zicsr Standard Extension\n  [(#b101 #b1110011) csrrwi (do-csr-op-imm (lambda (old new) new))]\n  [(#b110 #b1110011) csrrsi (do-csr-op-imm (lambda (old new) (bvor old new)))]\n  [(#b111 #b1110011) csrrci (do-csr-op-imm (lambda (old new) (bvand old (bvnot new))))])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"Give me the Rosette code for the immediate shift instructions (slli/srli/srai and their *w variants) so I can validate shift masking rules symbolically."},{"role":"assistant","content":"<think>\nThe shift decoders split the instruction into shamt fields (either 6 bits for XLEN-dependent shifts or 5 bits for *w variants) along with funct bits to pick the operator.\ninterpret-ishift-type guards the shamt for RV32 via core:bug-on and zero-extends the shamt to XLEN before using gpr-ref/gpr-set! on the symbolic register file; no memory activity occurs in this type.\nBecause the shamt bounds are expressed as bitvector inequalities, violating them would make the solver report UNSAT, and the write-back equation constrains the successor state in the symbolic execution.\n</think>\n\n```racket\n#lang rosette\n\n(require \"common.rkt\")\n\n; 64-bit Shift instructions\n(define-insn (shamt6 rs1 rd)\n  #:encode (lambda (funct6 funct3 opcode)\n                   (list (bv funct6 6) shamt6 rs1 (bv funct3 3) rd (bv opcode 7)))\n  [(#b000000 #b001 #b0010011) slli (interpret-ishift-type bvshl)]\n  [(#b000000 #b101 #b0010011) srli (interpret-ishift-type bvlshr)]\n  [(#b010000 #b101 #b0010011) srai (interpret-ishift-type bvashr)])\n\n; 32-bit shift instructions\n(define-insn (shamt5 rs1 rd)\n  #:encode (lambda (funct7 funct3 opcode)\n                   (list (bv funct7 7) shamt5 rs1 (bv funct3 3) rd (bv opcode 7)))\n  [(#b0000000 #b001 #b0011011) slliw (interpret-iwshift-type bvshl)]\n  [(#b0000000 #b101 #b0011011) srliw (interpret-iwshift-type bvlshr)]\n  [(#b0100000 #b101 #b0011011) sraiw (interpret-iwshift-type bvashr)])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"What does the Rosette semantics for the I-type fence instruction look like?"},{"role":"assistant","content":"<think>\nThis instruction parses the fm/pred/succ subfields plus rs1/rd/funct3/opcode, so the decoder just binds those bit slices before handing control to the skip handler.\nskip simply advances the symbolic PC via cpu-next! without touching registers or memory, so the register file and memmgr remain unchanged for the solver.\nThe lack of side effects means the solver only sees the implicit constraint that the PC increments by instruction-size, which is encoded inside cpu-next!.\n</think>\n\n```racket\n#lang rosette\n\n(require \"common.rkt\")\n\n; FENCE is a weird I-type instruction\n(define-insn (fm pred succ rs1 rd)\n  #:encode (lambda (funct3 opcode)\n                   (list fm pred succ rs1 (bv funct3 3) rd (bv opcode 7)))\n  [(#b000 #b0001111) fence skip])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"Please share the Serval Rosette code for the S-type store instructions that push bytes/halfwords/words/doublewords to memory."},{"role":"assistant","content":"<think>\nThe S-type decoder rearranges imm11:5 and imm4:0 to recover the 12-bit signed store offset, and decode-gpr maps rs1/rs2 to symbolic registers.\ninterpret-store-insn uses gpr-ref on rs1 to form the base address, sign-extends the immediate, truncates rs2 to the store width, and then calls core:memmgr-store! to update the symbolic memory manager.
Since the store writes memory but not rd, the solver sees a constraint linking the prior symbolic memory state to the updated one via the memmgr store plus the implicit PC increment performed by cpu-next!.\n</think>\n\n```racket\n#lang rosette\n\n(require \"common.rkt\")\n\n(define ((interpret-store-insn size) cpu insn imm11:5 rs2 rs1 imm4:0)\n  (define mm (cpu-memmgr cpu))\n  (define xlen (cpu-xlen cpu))\n\n  (define addr (bvadd (gpr-ref cpu (decode-gpr rs1))\n                      (sign-extend (concat imm11:5 imm4:0) (bitvector xlen))))\n  (define value (trunc (* 8 size) (gpr-ref cpu (decode-gpr rs2))))\n\n  (core:memmgr-store! mm addr (bv 0 xlen) value (bv size xlen))\n  (cpu-next! cpu insn))\n\n(define-insn (imm11:5 rs2 rs1 imm4:0)\n  #:encode (lambda (funct3 opcode)\n                   (list imm11:5 rs2 rs1 (bv funct3 3) imm4:0 (bv opcode 7)))\n\n  [(#b000 #b0100011) sb (interpret-store-insn 1)]\n  [(#b001 #b0100011) sh (interpret-store-insn 2)]\n  [(#b010 #b0100011) sw (interpret-store-insn 4)]\n  [(#b011 #b0100011) sd (interpret-store-insn 8)])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"I want the Rosette branch semantics for the B-type compare-and-branch instructions."},{"role":"assistant","content":"<think>\nThe branch decoder reconstructs the signed offset by splicing the imm12&10:5 and imm4:1&11 fields, then decode-gpr maps rs1/rs2 before the compare function runs.\ninterpret-b-type reads the symbolic register operands, applies the chosen predicate (bveq, bvslt, etc.), and either updates the symbolic PC with the sign-extended offset or falls through via cpu-next!.\nBecause the branch decision is a Boolean over symbolic bitvectors, the solver forks on that predicate, and the computed offset constraint ties directly into the symbolic PC maintained by set-cpu-pc!.\n</think>\n\n```racket\n#lang rosette\n\n(require \"common.rkt\")\n\n(define ((interpret-b-type op) cpu insn imm12&10:5 rs2 rs1 imm4:1&11)\n  (define xlen (cpu-xlen cpu))\n  (define off\n    (concat (extract 6 6 imm12&10:5)\n            (extract 0 0 imm4:1&11)\n            (extract 5 0 imm12&10:5)\n            (extract 4 1 imm4:1&11)\n            (bv 0 1)))\n\n  (define a (gpr-ref cpu (decode-gpr rs1)))\n  (define b (gpr-ref cpu (decode-gpr rs2)))\n\n  (define branch (op a b))\n\n  (if branch\n    (set-cpu-pc! cpu (bvadd (cpu-pc cpu) (sign-extend off (bitvector xlen))))\n    (cpu-next! cpu insn)))\n\n(define-insn (imm12&10:5 rs2 rs1 imm4:1&11)\n  #:encode (lambda (funct3 opcode)\n                   (list imm12&10:5 rs2 rs1 (bv funct3 3) imm4:1&11 (bv opcode 7)))\n  [(#b000 #b1100011) beq  (interpret-b-type bveq)]\n  [(#b001 #b1100011) bne  (interpret-b-type (lambda (a b) (! (bveq a b))))]\n  [(#b100 #b1100011) blt  (interpret-b-type bvslt)]\n  [(#b101 #b1100011) bge  (interpret-b-type bvsge)]\n  [(#b110 #b1100011) bltu (interpret-b-type bvult)]\n  [(#b111 #b1100011) bgeu (interpret-b-type bvuge)])\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"Provide the Rosette modeling snippet for U-type instructions (lui/auipc)."},{"role":"assistant","content":"<think>\nThe U-type format is simple: imm31:12 and rd plus the opcode, so the decoder extracts those slices and feeds them straight into interpret-lui/interpret-auipc.\nBoth helpers left-shift the 20-bit immediate by concatenating 12 zero bits, sign-extend to XLEN, and then either write the value directly or add the current symbolic PC, so only the register file and PC change.\nThese updates create solver constraints equating rd to the computed bitvector, while memory stays untouched and cpu-next! ensures control-flow monotonicity.\n</think>\n\n```racket\n#lang rosette\n\n(require \"common.rkt\")\n\n(define (interpret-lui cpu insn imm31:12 rd)\n  (gpr-set! cpu (decode-gpr rd)\n                (sign-extend (concat imm31:12 (bv 0 12))\n                             (bitvector (cpu-xlen cpu))))\n  (cpu-next! cpu insn))\n\n(define (interpret-auipc cpu insn imm31:12 rd)\n  (gpr-set! cpu (decode-gpr rd)\n                (bvadd\n                  (sign-extend (concat imm31:12 (bv 0 12)) (bitvector (cpu-xlen cpu)))\n                  (cpu-pc cpu)))\n  (cpu-next! cpu insn))\n\n(define-insn (imm31:12 rd)\n  #:encode (lambda (opcode)\n                   (list imm31:12 rd (bv opcode 7)))\n  [(#b0110111) lui interpret-lui]\n  [(#b0010111) auipc interpret-auipc]\n)\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"Finally, show me the Rosette semantics for the J-type jal instruction so I can reason about symbolic jump targets."},{"role":"assistant","content":"<think>\nThe jal decoder slices the imm20&10:1&11&19:12 field plus rd/opcode, so interpreting it requires reassembling the signed offset in the standardized bit order.\ninterpret-jal saves the symbolic next PC (pc+4) into rd, sign-extends the offset, and adds it to the current PC before calling set-cpu-pc!, leaving memory untouched.\nBecause rd receives the fall-through PC and the jump target is computed from symbolic bits, the solver has precise constraints relating registers and PC, enabling proofs about control-flow.\n</think>\n\n```racket\n#lang rosette\n\n(require \"common.rkt\")\n\n(define (interpret-jal cpu insn imm20&10:1&11&19:12 rd)\n  (define off\n    (concat (extract 19 19 imm20&10:1&11&19:12)\n            (extract 7 0 imm20&10:1&11&19:12)\n            (extract 8 8 imm20&10:1&11&19:12)\n            (extract 18 9 imm20&10:1&11&19:12)\n            (bv 0 1)))\n\n  (define next (bvadd (cpu-pc cpu) (bv 4 (cpu-xlen cpu))))\n  (gpr-set! cpu (decode-gpr rd) next)\n\n  (set-cpu-pc! cpu (bvadd (cpu-pc cpu) (sign-extend off (bitvector (cpu-xlen cpu))))))\n\n(define-insn (imm20&10:1&11&19:12 rd)\n  #:encode (lambda (opcode)\n                   (list imm20&10:1&11&19:12 rd (bv opcode 7)))\n  [(#b1101111) jal interpret-jal])\n```"}]}
