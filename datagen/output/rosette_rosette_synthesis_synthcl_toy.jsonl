{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I need a SynthCL host sketch that launches a vector-add kernel over int buffers. Please synthesize against a reference spec for every offset and any src length in {4,8,12,16,20} so I can be sure the host driver matches the sequential behavior."},{"role":"assistant","content":"<think>\nThe host sketch allocates OpenCL resources with SynthCL `procedure` forms, then launches the `sample` kernel over global work-items computed as (/ SIZE 4). The sequential `spec` procedure and `check` helper characterize the pure behavior, and the `synth` query quantifies `offset`, `len`, and the symbolic array `(: int[len] src)` via #:forall. The #:ensure clause invokes (check (host ...) (spec ...) len), so the solver must verify that the host/kern pair agrees with the spec on every multiple-of-four length, which nails down any symbolic choices inside the GPU kernel.\n</think>\n\n```racket\n#lang s-exp \"../../../lang/main.rkt\"\n\n; Given a src array of length SIZE, returns a new array dst of \n; the same size, such that dst[i] = src[i] + offset, for all \n; 0 <= i < SIZE.  The SIZE parameter must be evenly divisible by 4.\n(procedure int* (host [int* src] [int SIZE] [int offset])\n  (: cl_context context)\n  (: cl_command_queue command_queue)\n  (: cl_program program)\n  (: cl_kernel kernel)\n  (: cl_mem buffer_src buffer_dst)\n  (: int* dst)\n  (: int global)\n\n  (= global (/ SIZE 4))\n  \n  (= dst ((int*) (malloc (* SIZE (sizeof int)))))\n  \n  (= context (clCreateContext))\n  \n  (= command_queue (clCreateCommandQueue context))\n \n  (= buffer_src (clCreateBuffer context CL_MEM_READ_ONLY (* SIZE (sizeof int))))\n  (= buffer_dst (clCreateBuffer context CL_MEM_WRITE_ONLY (* SIZE (sizeof int))))\n  \n  (= program (clCreateProgramWithSource context \"kernel.rkt\"))\n  \n  (clEnqueueWriteBuffer command_queue buffer_src 0 SIZE src)\n  \n  (= kernel (clCreateKernel program \"sample\"))\n  (clSetKernelArg kernel 0 buffer_dst)\n  (clSetKernelArg kernel 1 buffer_src)\n  (clSetKernelArg kernel 2 offset)\n\n  (clEnqueueNDRangeKernel command_queue kernel 1 NULL (@ global) NULL)\n  (clEnqueueReadBuffer command_queue buffer_dst 0 SIZE dst)\n  dst)\n\n; The reference implementation for the host procedure. \n; Given a src array of length SIZE, returns a new array dst of \n; the same size, such that dst[i] = src[i] + offset, for all \n; 0 <= i < SIZE.  The SIZE parameter must be evenly divisible by 4.\n(procedure int* (spec [int* src] [int SIZE] [int offset])\n  (: int* dst)\n  (= dst ((int*) (malloc (* SIZE (sizeof int)))))\n  (for [(: int i in (range SIZE))]\n;    (= [dst i] (?: (&& (== SIZE 16) (== offset -1)) \n;                   (- [src i] offset) \n;                   (+ [src i] offset)))) ; sample bug\n    (= [dst i] (+ [src i] offset)))\n  dst)\n  \n; Given two arrays of the same size, checks that they hold the same \n; values at each index.\n(procedure void (check [int* actual] [int* expected] [int SIZE])\n  (assert (>= SIZE 0))\n  (for [(: int i in (range SIZE))]\n    (assert (== [actual i] [expected i]))))\n\n; Synthesize the kernel procedure so that it is correct for all small \n; arrays of length that is evenly divisible by 4.  In this case, we are \n; ensuring correctness for all arrays of size 4, 8, 12, 16 and 20.\n(synth #:forall [(: int offset)\n                 (: int len in (range 4 21 4))\n                 (: int[len] src)] \n       #:ensure (check (host src len offset) (spec src len offset) len))\n```"}]}\n{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"For the same toy vector-add example, capture the SynthCL kernel sketch that adds an int4 offset to each vector but leaves the index expression as a symbolic choice so the host-level synthesis can constrain it."},{"role":"assistant","content":"<think>\nThe kernel is written with SynthCL's `kernel` form over int4 vectors. It binds `id` to (get_global_id 0) and sets `idx` via a `choose` expression spanning plausible affine index forms such as id, id/4, % id 4, +/- id 4, and * id 4. That `choose` is the symbolic hole the solver must resolve when the enclosing `synth` query (in the host file) enforces correctness. The body finally assigns dst[idx] = src[idx] + offset so only the index arithmetic is under synthesis control.\n</think>\n\n```racket\n#lang s-exp \"../../../lang/main.rkt\"\n\n\n(kernel void (sample [int4* dst] [int4* src] [int4 offset])\n  (: int id idx)\n  (= id (get_global_id 0))\n  (= idx (choose id (/ id 4) (% id 4) (+ id 4) (* id 4) (- id 4)))\n  (= [dst idx] (+ [src idx] offset)))\n```"}]}\n{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Sketch a tiny unary-minus grammar where two wrapper procedures must respectively behave like identity and decrement-by-one, and synthesize the hole so both wrappers line up with their specified results for every int input."},{"role":"assistant","content":"<think>\nBoth `tiny0` and `tiny1` delegate to the nonterminal `minus`, whose grammar production is (- x (choose 0 1)). That `choose` is the only hole, letting the solver decide whether to subtract 0 or 1. The synth query quantifies all ints x and asserts that tiny0 x equals x while tiny1 x equals x-1, forcing the solver to bind the grammar choice consistently so the shared minus primitive satisfies both wrappers.\n</think>\n\n```racket\n(procedure int (tiny0 [int x])\n  (minus x))\n\n(procedure int (tiny1 [int x])\n  (minus x))\n\n(grammar int (minus [int x])\n  (- x (choose 0 1)))\n\n(procedure int (foo [int x]) (locally-scoped (- ((int) x) 1)))\n\n(synth #:forall [(: int x)]\n       #:ensure (assert (&& (== x (tiny0 x)) \n                            (== (- x 1) (tiny1 x)))))\n```"}]}\n{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I also want a constraint-only sketch that fires an assertion when t=3 and p=4, but lets the solver choose between asserting k or the literal 3. Show the SynthCL query that quantifies k,t,p and leaves that guard symbolic."},{"role":"assistant","content":"<think>\nThis query has no program body, just a solver obligation over parameters. The #:forall block ranges over scalar k plus loop-bounded t and p, with p starting at t via (range t 5). Inside the #:ensure clause we guard on (&& (== t 3) (== p 4)) and then assert either k or 3 through (choose k 3), so the solver must pick which assertion satisfies every model. A follow-on verify block covers a different guard to sanity-check the pattern.\n</think>\n\n```racket\n(synth #:forall [(: int k)\n                 (: int t in (range 1 5))\n                 (: int p in (range t 5))]\n       #:ensure (if (&& (== t 3) (== p 4)) \n                    {(assert (choose k 3))}))\n\n(verify #:forall [(: int t in (range 1 5))\n                  (: int k)\n                  (: int p in (range t 5))]\n        #:ensure (if (&& (== t 2) (== p 4)) \n                     {(assert k)}))\n```"}]}\nEOF
