{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I'm building basic verify tests and want to see how counterexamples show up when assertions are false. Can you show a minimal Rosette test suite that treats sat results as counterexamples?"},{"role":"assistant","content":"<think>\nThe test suite wraps verify in check-verify to classify results as sat? or unsat?. For verify, a sat solution is a counterexample to the asserted property, so the lines that check sat? (like (and x (not x))) are explicitly expecting a counterexample model. The handler maps exceptions to unsat, and the macro checks the solver result object returned by verify. This uses verify with assert/assume and relies on the solver to produce a model for x or n when the property is invalid.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui rosette/lib/roseunit)\n\n(define-symbolic x boolean?)\n(define-symbolic n integer?)\n\n(define-syntax-rule (check-verify pred test)\n  (let ([sol (with-handlers ([exn:fail? (const (unsat))])\n               test)])\n    (check-true (pred sol) (format \"not ~a for ~a: ~a\" (quote pred) (quote test) sol))))\n\n(define verify-tests\n  (test-suite+ \"Basic verify tests\"\n    ; basic verify tests\n    (check-verify unsat? (verify (assert (or x (not x)))))\n    (check-verify sat? (verify (assert (and x (not x)))))\n    (check-verify unsat? (verify (begin (assume x) (assert (or x (not x))))))\n    (check-verify sat? (verify (begin (assume x) (assert (not x)))))\n    \n    (check-verify unsat? (verify (assert (or (>= n 0) (< n 0)))))\n    (check-verify sat? (verify (assert (= n 0))))\n    (check-verify sat? (verify (assert (= (* n 2) 0))))\n    (check-verify unsat? (verify (begin (assume (= n 0)) (= (* n 2) 0)))) ))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I want to test how verify short-circuits when assumptions are false or assertions are trivially true/false. Show the Rosette code that treats sat results as counterexamples in these cases."},{"role":"assistant","content":"<think>\nThe short-circuit tests use verify over assert/assume combinations that are trivially valid or invalid. When the assertion is #f under a true assumption, verify should return sat? with a counterexample (the model is irrelevant because the VC is false). When the assumption is #f, the VC is valid and verify returns unsat?. This block shows how counterexamples are expected for invalid paths.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui rosette/lib/roseunit)\n\n(define-symbolic x boolean?)\n(define-symbolic n integer?)\n\n(define-syntax-rule (check-verify pred test)\n  (let ([sol (with-handlers ([exn:fail? (const (unsat))])\n               test)])\n    (check-true (pred sol) (format \"not ~a for ~a: ~a\" (quote pred) (quote test) sol))))\n\n(define short-circuit-tests\n  (test-suite+ \"Verify short-circuit tests\"\n\n    (check-verify unsat? (verify (assert #t)))\n    (check-verify unsat? (verify (begin (assume #f) (assert x))))    ; #f => x  is valid\n    (check-verify sat?   (verify (begin (assume #t) (assert #f))))   ; #t => #f is invalid\n    \n\n    (check-verify unsat? (verify (begin (assume (and (= (+ (* 2 n) 1) 0) (not (= n 0))))\n                                        (assert #f))))\n    (check-verify unsat? (verify (begin (assume (and (= (+ (* 2 n) 1) 0) (not (= n 0))))\n                                        (assert #t))))\n\n    (check-verify unsat? (verify (begin (assume #f)\n                                        (assert (and (= (+ (* 2 n) 1) 0) (not (= n 0)))))))\n    (check-verify sat? (verify (begin (assume #t)\n                                      (assert (and (= (+ (* 2 n) 1) 0) (not (= n 0)))))))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I have a symbolic expression I partially evaluate with a model and then verify it equals zero. How can I see the counterexample behavior when it doesn't?"},{"role":"assistant","content":"<think>\nThis function builds a symbolic expression over x and y, partially evaluates it with a sat model fixing x, and then uses verify to assert the result is 0. If the evaluated expression can be nonzero for some y, verify returns sat? with a counterexample model for y, demonstrating how counterexamples arise after evaluate.\n</think>\n\n```racket\n#lang rosette\n\n(define-symbolic x boolean?)\n\n(define (r0)\n  (define-symbolic y boolean?)\n  (define expression\n    (+ (if x (if y 0.5 0) 1) (if y 0.5 0)))\n\n  (define evaluated\n    (evaluate expression (sat (hash x #t))))\n\n  (verify (assert (= 0 evaluated))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I suspect my sum helper is wrong. Can you show a verify query that produces a counterexample for the list case that breaks the property?"},{"role":"assistant","content":"<think>\nThis example defines a symbolic list xs and a buggy sum, then uses verify to assert equivalence with summing after filtering zeros. If the bug exists, verify returns sat? with a counterexample model for xs, indicating which list violates the property.\n</think>\n\n```racket\n#lang rosette\n\n(define-symbolic xs integer? #:length 4)\n(define (sum xs) (foldl + xs)) ; bug: missing 0 after +\n(verify (assert (= (sum xs) (sum (filter-not zero? xs)))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I want a counterexample where a positive sum doesn't imply a positive element. Show me the verify/assume/assert code that exposes this in Rosette."},{"role":"assistant","content":"<think>\nThe query assumes (positive? (sum xs)) and asserts (ormap positive? xs). If the sum implementation is buggy or if the property is invalid, verify returns sat? with a counterexample model for xs. This illustrates counterexample extraction through verify with assume/assert.\n</think>\n\n```racket\n#lang rosette\n\n(define-symbolic xs integer? #:length 4)\n(define (sum xs) (foldl + xs)) ; bug: missing 0 after +\n(verify\n (begin\n   (assume (positive? (sum xs)))\n   (assert (ormap positive? xs))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I have a more complex sum implementation with a suspected bug. Can you show verify code that would produce a counterexample model for xs?"},{"role":"assistant","content":"<think>\nThis file defines a symbolic list and a buggy sum that mishandles the all-equal case by using (cdr xs). The verify query assumes a positive sum and asserts there is a positive element. If the bug lets the sum be positive without a positive element, verify returns sat? with a counterexample.\n</think>\n\n```racket\n#lang rosette\n\n(define-symbolic xs integer? #:length 4)\n(define (sum xs)\n  (cond\n    [(null? xs) 0]\n    [(null? (cdr xs)) (car xs)]\n    [(andmap (curry = (car xs)) (cdr xs))\n     (* (length xs) (cdr xs))] ; bug: cdr should be car\n    [else (apply + xs)]))\n\n(verify\n (begin\n   (assume (positive? (sum xs)))\n   (assert (ormap positive? xs))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I'm verifying a selection algorithm against a sorted list reference. Can you show the verify query that yields a counterexample when the algorithm is wrong?"},{"role":"assistant","content":"<think>\nThe code defines a symbolic list, an index n, and a select function with a control-flow bug. The verify query assumes k equals select xs n and asserts it matches list-ref on the sorted list. If select is wrong, verify returns sat? with a counterexample model for xs and n.\n</think>\n\n```racket\n#lang rosette\n\n(define-symbolic xs integer? #:length 4)\n(define-symbolic k integer?)\n(define-symbolic n integer?)\n(define (select xs n)\n  (cond\n    [(empty? xs) (assert #f \"unexpected empty list\")]\n    [else (define pivot (first xs))\n          (define non-pivot (rest xs))\n          (define <pivot (filter (λ (x) (< x pivot)) non-pivot))\n          (define >=pivot (filter (λ (x) (>= x pivot)) non-pivot))\n          (define len< (length <pivot))\n          (cond\n            [(= n len<) pivot]\n            [(< n len<) (select <pivot)]\n            [else (select >=pivot (- n len< 1))])]))\n\n(verify\n (begin\n   (assume (and (<= 0 n (sub1 (length xs)))\n                (= k (select xs n))))\n   (assert (= k (list-ref (sort xs <) n)))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I solved for an uninterpreted boolean function and want to double-check it with verify using evaluate. Show me code where verify would return a counterexample if the model is inconsistent."},{"role":"assistant","content":"<think>\nThis snippet solves for an uninterpreted function f that should behave like or, then uses evaluate with the solution to build a concrete assertion. The verify call checks that the evaluated f matches (or x y). If the model were inconsistent, verify would return sat? with a counterexample, but the test expects unsat?.\n</think>\n\n```racket\n#lang rosette\n\n(require rackunit rackunit/text-ui (only-in \"vc.rkt\" check-exn-svm)\n         rosette/lib/roseunit\n         rosette/base/core/term rosette/base/core/bool rosette/base/core/exn rosette/base/core/result)\n\n(define (check-uninterpreted)\n  (let ()\n    (define-symbolic x y boolean?)\n    (define-symbolic f (~> boolean? boolean? boolean?))\n    (define sol (solve (assert (forall (list x y) (equal? (f x y) (or x y))))))\n    (check-pred (disjoin sat? unknown?) sol)\n    (when (sat? sol)\n      (check-unsat (verify (assert (equal? (evaluate (f x y) sol) (or x y)))))))\n\n  (let ()\n    (define-symbolic x integer?)\n    (define-symbolic f (~> integer? integer?))\n    (define sol (solve (assert (forall (list x) (= x (f x))))))\n    (check-pred (disjoin sat? unknown?) sol)\n    (when (sat? sol)\n      (check-unsat (verify (assert (equal? (evaluate (f x) sol) (identity x)))))))\n\n  (let ()\n    (define-symbolic offset integer?)\n    (define-symbolic a (~> integer? integer?))\n    (define-symbolic disk (~> integer? integer? integer?))\n    (define sol (solve (assert (forall (list offset) (= (a offset) (disk 5 offset))))))\n    (check-pred (disjoin sat? unknown?) sol)\n    (when (sat? sol)\n      (check-unsat (verify (assert (equal? (evaluate (a offset) sol) (evaluate (disk 5 offset) sol)))))))\n    )\n\n  (let ()\n    (define-symbolic offset real?)\n    (define-symbolic a (~> real? real?))\n    (define-symbolic disk (~> real? real? real?))\n    (define sol (solve (assert (forall (list offset) (= (a offset) (disk 5.35 offset))))))\n    (check-pred (disjoin sat? unknown?) sol)\n    (when (sat? sol)\n      (check-unsat (verify (assert (equal? (evaluate (a offset) sol) (evaluate (disk 5.35 offset) sol)))))))\n  )\n  )\n```"}]}
