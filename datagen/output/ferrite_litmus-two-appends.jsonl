{"messages":[{"role":"system","content":"You are the Ferrite Rosette Litmus Engineer, expert in consistency testing and litmus design."},{"role":"user","content":"Can you craft a SeqFS litmus where two append operations run back-to-back but only the second fsyncs, so we can enumerate all crash outcomes?"},{"role":"assistant","content":"<think>\nOperation sequence: creat(0), creat(1), append (#t #t) to file 0 without fsync, append (#t) to file 1 and fsync(1); assume single-thread ordering with possible crashes after each step so file 0's unsynced data vanishes while file 1 may persist.\nConstraints: two-appends-allow enumerates the legal (ondisk 0, ondisk 1) pairs, covering unallocated, empty, and durably appended states for each crash point while ensuring '(#t) only appears once file 1's fsync completes.\nSolver usage: litmus + verify-correctness expect an UNSAT counterexample on SeqFS, confirming every reachable outcome belongs to the allow-set while all-outcomes returns all five states.\n</think>\n\n```racket\n(define two-appends-setup '())\n\n(define two-appends-test-incorrect\n  (list\n   (creat 0)\n   (creat 1)\n   (write 0 '(#t #t))\n   ; (fsync 0)\n   (write 1 '(#t))\n   (fsync 1)))\n\n(define (two-appends-allow oldfs newfs)\n  (define new-0 (ondisk newfs 0))\n  (define new-1 (ondisk newfs 1))\n  (list (and (equal? new-0 #f)  (equal? new-1 #f))\n        (and (equal? new-0 '()) (equal? new-1 #f))\n        (and (equal? new-0 '()) (equal? new-1 '()))\n        (and (equal? new-0 '(#t #t)) (equal? new-1 '()))\n        (and (equal? new-0 '(#t #t)) (equal? new-1 '(#t)))))\n\n(define (two-appends-fs-seqfs)\n  (seq-fs 2))\n\n(define (test-seqfs-incorrect)\n  (define test\n    (litmus two-appends-fs-seqfs two-appends-setup two-appends-test-incorrect two-appends-allow))\n  (define-values (cex state) (verify-correctness test))\n  (check-true (unsat? cex))\n  (check-false state)\n  (define all-states (all-outcomes test))\n  (check equal? (length all-states) 5))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Litmus Engineer, expert in consistency testing and litmus design."},{"role":"user","content":"Show me the SeqFS litmus where both appenders call fsync so we can prove each file's appended data survives every crash point."},{"role":"assistant","content":"<think>\nOperation sequence: creat(0), creat(1), append (#t #t) to file 0, fsync(0), append (#t) to file 1, fsync(1); ordering is sequential so crashes can only truncate before a completed fsync, guaranteeing durability once each fsync executes.\nConstraints: the same two-appends-allow predicate bounds the (ondisk 0, ondisk 1) pairs, but once both fsyncs occur the only durable state has '(#t #t) for file 0 and '(#t) for file 1.\nSolver usage: verify-correctness must find the SeqFS model safe (UNSAT) while all-outcomes still enumerates five legal crash states, matching the specification.\n</think>\n\n```racket\n(define two-appends-setup '())\n\n(define two-appends-test-correct\n  (list\n   (creat 0)\n   (creat 1)\n   (write 0 '(#t #t))\n   (fsync 0)\n   (write 1 '(#t))\n   (fsync 1)))\n\n(define (two-appends-allow oldfs newfs)\n  (define new-0 (ondisk newfs 0))\n  (define new-1 (ondisk newfs 1))\n  (list (and (equal? new-0 #f)  (equal? new-1 #f))\n        (and (equal? new-0 '()) (equal? new-1 #f))\n        (and (equal? new-0 '()) (equal? new-1 '()))\n        (and (equal? new-0 '(#t #t)) (equal? new-1 '()))\n        (and (equal? new-0 '(#t #t)) (equal? new-1 '(#t)))))\n\n(define (two-appends-fs-seqfs)\n  (seq-fs 2))\n\n(define (test-seqfs-correct)\n  (define test\n    (litmus two-appends-fs-seqfs two-appends-setup two-appends-test-correct two-appends-allow))\n  (define-values (cex state) (verify-correctness test))\n  (check-true (unsat? cex))\n  (check-false state)\n  (define all-states (all-outcomes test))\n  (check equal? (length all-states) 5))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Litmus Engineer, expert in consistency testing and litmus design."},{"role":"user","content":"I want the AdvFS litmus where the first append never fsyncs but the second does, demonstrating the bug where file 0's data never persists."},{"role":"assistant","content":"<think>\nOperation sequence mirrors the incorrect workload: creat(0), creat(1), append (#t #t) to file 0 with no fsync, then append (#t) to file 1 and fsync(1); AdvFS reorders writes so file 0 never reaches disk before a crash.\nConstraints: two-appends-allow still defines the legitimate crash states, forbidding '(#t #t) from being durable when file 0 has not fsynced.\nSolver usage: litmus over adv-fs(2) yields a SAT counterexample plus a concrete violating state (ondisk 0) != '(#t #t), and all-outcomes shows only four reachable states because the first append never lands on disk.\n</think>\n\n```racket\n(define two-appends-setup '())\n\n(define two-appends-test-incorrect\n  (list\n   (creat 0)\n   (creat 1)\n   (write 0 '(#t #t))\n   ; (fsync 0)\n   (write 1 '(#t))\n   (fsync 1)))\n\n(define (two-appends-allow oldfs newfs)\n  (define new-0 (ondisk newfs 0))\n  (define new-1 (ondisk newfs 1))\n  (list (and (equal? new-0 #f)  (equal? new-1 #f))\n        (and (equal? new-0 '()) (equal? new-1 #f))\n        (and (equal? new-0 '()) (equal? new-1 '()))\n        (and (equal? new-0 '(#t #t)) (equal? new-1 '()))\n        (and (equal? new-0 '(#t #t)) (equal? new-1 '(#t)))))\n\n(define (two-appends-fs-advfs)\n  (adv-fs 2))\n\n(define (test-advfs-incorrect)\n  (define test\n    (litmus two-appends-fs-advfs two-appends-setup two-appends-test-incorrect two-appends-allow))\n  (define-values (cex state) (verify-correctness test))\n  (check-true (sat? cex))\n  (check-false (equal? (ondisk state 0) '(#t #t)))\n  (define all-states (all-outcomes test))\n  (check equal? (length all-states) 4))  ; only 4 states: the write to 0 can never be synced\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Litmus Engineer, expert in consistency testing and litmus design."},{"role":"user","content":"Please capture the AdvFS variant where both appends fsync so we can show the optimizer is safe once every append is forced to disk."},{"role":"assistant","content":"<think>\nOperation sequence: creat(0), creat(1), append (#t #t) to file 0, fsync(0), append (#t) to file 1, fsync(1); ordering is the same but now each durability point commits through AdvFS's log.\nConstraints: two-appends-allow supplies the same five legal crash states, requiring AdvFS to surface '(#t #t) and '(#t) only after their respective fsyncs.\nSolver usage: after clear-asserts!, verify-correctness must report UNSAT (no bug) and all-outcomes reports all five states, matching the spec.\n</think>\n\n```racket\n(define two-appends-setup '())\n\n(define two-appends-test-correct\n  (list\n   (creat 0)\n   (creat 1)\n   (write 0 '(#t #t))\n   (fsync 0)\n   (write 1 '(#t))\n   (fsync 1)))\n\n(define (two-appends-allow oldfs newfs)\n  (define new-0 (ondisk newfs 0))\n  (define new-1 (ondisk newfs 1))\n  (list (and (equal? new-0 #f)  (equal? new-1 #f))\n        (and (equal? new-0 '()) (equal? new-1 #f))\n        (and (equal? new-0 '()) (equal? new-1 '()))\n        (and (equal? new-0 '(#t #t)) (equal? new-1 '()))\n        (and (equal? new-0 '(#t #t)) (equal? new-1 '(#t)))))\n\n(define (two-appends-fs-advfs)\n  (adv-fs 2))\n\n(define (test-advfs-correct)\n  (clear-asserts!)\n  (define test\n    (litmus two-appends-fs-advfs two-appends-setup two-appends-test-correct two-appends-allow))\n  (define-values (cex state) (verify-correctness test))\n  (check-true (unsat? cex))\n  (check-false state)\n  (define all-states (all-outcomes test))\n  (check equal? (length all-states) 5))\n```"}]}
