{"messages":[{"role":"system","content":"You are the Ferrite Rosette Filesystem Engineer, expert in modeling filesystem semantics."},{"role":"user","content":"I need a Rosette initializer for a sequentially consistent filesystem where each directory slot tracks an inode/existence pair, file descriptors map to inodes, and every inode embeds a file record with size and on-disk contents."},{"role":"assistant","content":"<think>\nState variables: `dir` is a vector of `(cons inode exists?)`, `fds` maps fd indexes to inode ids, and `files` holds `file` structs with `size` + `ondisk`; all share the same capacity parameter.\nInvariant: each `file`'s `size` equals the length of its `ondisk` list, and the three vectors stay aligned so every inode slot has metadata even before creation.\nSequential consistency: the constructor eagerly allocates deterministic slots so syscalls observe a single serial order without lazy side effects.\n</think>\n\n```racket\n(define (seq-fs [cap 3])\n  (SeqFS \n   (for/vector #:length cap ([i cap]) (cons i #f))\n   (make-vector cap 0)\n   (make-vector cap (file 0 '()))))\n\n(struct file (size ondisk) #:transparent)\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Filesystem Engineer, expert in modeling filesystem semantics."},{"role":"user","content":"Translate a sequential program of `creat`, `write`, `rename`, and `efsync` syscalls into inode-level operations while tracking each file descriptor's current offset so writes land at the right place."},{"role":"assistant","content":"<think>\nState: `lengths` hash records on-disk byte lengths per fd, seeded from the current filesystem; `nextfd` tracks the descriptor id for the next `creat`.\nInvariant: every time we emit a write op we immediately update `lengths` so subsequent writes advance offsets monotonically; `creat` installs a fresh fd entry before incrementing `nextfd`.\nSemantics: we walk the syscall list in order, emitting `i-dir-add`, `i-file-write`, `i-dir-rename`, or `i-swap` so the inode trace preserves the same serial history.\n</think>\n\n```racket\n; Compiles a program of syscalls into a program of inode-ops.\n; The important part is that we have to keep track of the current size of the\n; file pointed to by each `fd`, so that we generate inode-ops with the appropriate\n; offsets.\n(define (crack self prog)\n  (define nextfd 0)\n  (match-define (SeqFS dir fds files) self)\n  (define lengths (for/hash ([fd (vector-length fds)] [ino fds])\n                    (values fd (length (file-ondisk (vector-ref files ino))))))\n  (for/list ([op prog])\n    (match op\n      [(creat name)       (begin0\n                            (i-dir-add name nextfd)\n                            (let* ([ino (car (vector-ref dir name))]\n                                   [cnt (file-ondisk (vector-ref files ino))])\n                              (set! lengths (hash-set lengths nextfd (length cnt))))\n                            (set! nextfd (add1 nextfd)))]\n      [(write fd cnt)     (begin0\n                            (i-file-write fd cnt (hash-ref lengths fd))\n                            (set! lengths (hash-set lengths fd (+ (hash-ref lengths fd) (length cnt)))))]\n      [(rename name1 name2)   (i-dir-rename name1 name2)]\n      [(efsync fd e)         (i-swap fd e)])))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Filesystem Engineer, expert in modeling filesystem semantics."},{"role":"user","content":"Model the concrete semantics of applying inode operations to a sequential filesystem: cloning the state vectors, handling create/write/rename/sync cases, padding sparse writes, and returning the new SeqFS state."},{"role":"assistant","content":"<think>\nState variables: `(SeqFS dir fds files)` with immutable updates, so `execute` copies each vector before mutation to preserve functional semantics.\nOperation semantics: `i-dir-add` allocates a zeroed inode and marks directory entry + fd map; `i-file-write` pads gaps with `#f`, splices new content between head/tail slices, and updates file size; `i-dir-rename` swaps inode bindings after clearing old target; `i-swap` is a no-op because writes are already synchronous.\nSafety: because vectors are cloned first, each operation observes the same pre-state, and file sizes always match the length of constructed content.\n</think>\n\n```racket\n; Executes the inode-op? on this file system and returns the resulting\n; file system.\n(define (execute self call)\n  (match-define (SeqFS dir fds files) self)\n  (define new-dir (make-vector (vector-length dir)))\n  (vector-copy! new-dir 0 dir)\n  (define new-fds (make-vector (vector-length fds)))\n  (vector-copy! new-fds 0 fds)\n  (define new-files (make-vector (vector-length files)))\n  (vector-copy! new-files 0 files)\n  (match call\n    [(i-dir-add name fd)     (match-define (cons ino exists?) (vector-ref dir name))\n                             (vector-set! new-files ino (file 0 '()))\n                             (vector-set! new-dir name (cons ino #t))\n                             (vector-set! new-fds fd ino)]\n    [(i-file-write fd cnt off)   (define ino (vector-ref fds fd))\n                                 (match-define (file size ondisk) (vector-ref files ino))\n                                 (define off-end (+ off (length cnt)))\n                                 (when (> off (length ondisk))  ; pad out the file with null bytes\n                                   (set! ondisk (append ondisk (for/list ([i (- off (length ondisk))]) #f))))\n                                 (define head (take ondisk off))\n                                 (define tail (if (< off-end (length ondisk)) (drop ondisk off-end) '()))\n                                 (define newc (append head cnt tail))\n                                 (define newf (file (length newc) newc))\n                                 (vector-set! new-files ino newf)]\n    [(i-dir-rename name1 name2)  (unless (= name1 name2)\n                                   (define new-ino (car (vector-ref dir name1)))\n                                   (define old-ino (car (vector-ref dir name2)))\n                                   (vector-set! new-files old-ino (file 0 '()))\n                                   (vector-set! new-dir name1 (cons old-ino #f))\n                                   (vector-set! new-dir name2 (cons new-ino #t)))]\n    [(i-swap fd enabled)  (void)])  ; sync does nothing\n  (SeqFS new-dir new-fds new-files))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Filesystem Engineer, expert in modeling filesystem semantics."},{"role":"user","content":"Expose an `ondisk` query that returns a file's serialized contents when the directory entry is marked present, otherwise `#f`, so clients can observe committed bytes."},{"role":"assistant","content":"<think>\nState: directory vector stores `(cons inode exists?)` per name, and `files` holds inode-indexed `file` structs.\nInvariant: if `exists?` is false we must not expose stale buffers, so the lookup short-circuits before touching `files`.\nSemantics: fetch inode id, read existence flag, and return `(file-ondisk ...)` when the flag is set, otherwise `#f`.\n</think>\n\n```racket\n; Returns the on-disk contents of a file of the given name, or #f if\n; the file does not exist.\n(define (ondisk self name)\n  (match-define (SeqFS dir fds files) self)\n  (define ino (car (vector-ref dir name)))\n  (define exists? (cdr (vector-ref dir name)))\n  (if exists? (file-ondisk (vector-ref files ino)) #f))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Filesystem Engineer, expert in modeling filesystem semantics."},{"role":"user","content":"I want an observational equivalence checker for two sequential filesystem states that only compares visible directory entries and their file payloads, ignoring inode numbering differences."},{"role":"assistant","content":"<think>\nState variables: each SeqFS carries `dir`, `fds`, and `files`; comparing observational behavior means matching per-directory existence flags and, when present, the referenced file structs.\nInvariant: inode ids may differ but visible mapping must yield identical `(file size ondisk)` pairs whenever a directory slot is marked existing; non-existent entries must agree on absence.\nSemantics: iterate over directory indexes, align the inode pointers from each state, and conjoin equality checks under the existence guard.\n</think>\n\n```racket\n; Returns #t if this file system is observationally equivalent to the given\n; file system, or #f otherwise.\n(define (obs-equal? self other)\n  (match-define (SeqFS s-dir s-fds s-files) self)\n  (match-define (SeqFS o-dir o-fds o-files) other)\n  (apply && (for/list ([i (vector-length s-dir)])\n              (define s-ino (car (vector-ref s-dir i)))\n              (define s-exists? (cdr (vector-ref s-dir i)))\n              (define o-ino (car (vector-ref o-dir i)))\n              (define o-exists? (cdr (vector-ref o-dir i)))\n              (define s-file (vector-ref s-files s-ino))\n              (define o-file (vector-ref o-files o-ino))\n              (and (equal? s-exists? o-exists?)\n                   (=> s-exists? (equal? s-file o-file))))))\n```"}]}
