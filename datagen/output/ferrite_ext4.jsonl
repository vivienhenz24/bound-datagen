{"messages":[{"role":"system","content":"You are the Ferrite Rosette Filesystem Engineer, expert in modeling filesystem semantics."},{"role":"user","content":"Construct an ext4 Rosette model initializer that sets up block size, optional delayed allocation, directory slots, file descriptors, and file payload records, including helpers for file sizes and block rounding."},{"role":"assistant","content":"<think>\nState variables: BLOCK_SIZE scalar plus nodelalloc? flag, directory vector of (cons ino exists?) pairs, fd vector mapping descriptor indices to inode numbers, and file vector of (file (fsize size) ondisk) records seeded empty. Invariant: all vectors share the supplied capacity so directory slots, descriptor slots, and inode payload slots stay index-aligned. Helper roundup enforces block-aligned growth, while fsize wraps concrete sizes into mutable union values so symbolic truncations later remain tractable.\n</think>\n\n```racket\n; Creates an instance of the ext4 model with the given parameters.\n(define (ext4-fs #:capacity [cap 3] #:blocksize [bs 4096] #:nodelalloc? [nodelalloc? #f])\n  (Ext4FS \n   bs\n   nodelalloc?\n   (for/vector #:length cap ([i cap]) (cons i #f))\n   (make-vector cap 0)\n   (make-vector cap (file (fsize 0) '()))))\n\n(define (roundup x BLOCK_SIZE)\n  (if (= (remainder x BLOCK_SIZE) 0)\n      x\n      (- (+ x BLOCK_SIZE) (remainder x BLOCK_SIZE))))\n\n(struct file (size ondisk) #:transparent)\n(struct fsize (size) #:transparent #:mutable)  ; hack to force size to be a union instead of an expr\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Filesystem Engineer, expert in modeling filesystem semantics."},{"role":"user","content":"Compile user-level create/write/rename/efsync syscalls into inode-level operations that honor ext4 block granularity and delayed allocation semantics."},{"role":"assistant","content":"<think>\nState variables: lengths hash maps each fd to the current logical byte length, while block-lengths tracks how many bytes are allocated in full blocks; both are derived from the Ext4FS vectors so they remain synchronized with directory state. Invariants: callers may write across block boundaries only by emitting i-file-extend when offsets exceed allocation, and roundup ensures we align transitions at BLOCK_SIZE. Transitions: creat reserves the next fd and seeds lengths, write fills a partial block gap then iterates block-aligned chunks issuing either i-file-write or i-file-extend (padding with #f when a block is short), and rename/efsync collapse to metadata ops so later reasoning can reorder them safely.\n</think>\n\n```racket\n   ; Compiles a program of syscalls into a program of inode-ops.\n   ; The logic is complex because we must compile a `write` into multiple writes/extends\n   ; at the block granularity.\n   (define (crack self prog)\n     (define nextfd 0)\n     (match-define (Ext4FS BLOCK_SIZE nodelalloc? dir fds files) self)\n     ; Tracks the *actual* length of the file\n     (define lengths (for/hash ([fd (vector-length fds)] [ino fds])\n                       (values fd (fsize-size (file-size (vector-ref files ino)))))\n     ; Tracks the block length of the file -- i.e., the number of bytes allocated\n     (define block-lengths (for/hash ([fd (vector-length fds)] [ino fds])\n                             (values fd (length (file-ondisk (vector-ref files ino)))))\n     (flatten\n      (for/list ([op prog])\n       (match op\n         [(creat name)       (begin0\n                               (i-dir-add name nextfd)\n                               (let* ([ino (car (vector-ref dir name))]\n                                      [cnt (file-ondisk (vector-ref files ino))])\n                                 (set! lengths (hash-set lengths nextfd (length cnt))))\n                               (set! nextfd (add1 nextfd)))]\n         [(write fd cnt)     (define offset (hash-ref lengths fd))\n                             (define offset-end (+ offset (length cnt)))\n                             (define ops '())\n                             ; first, fill out the gap from offset to the next block boundary\n                             (when (not (= offset (roundup offset BLOCK_SIZE)))\n                               (define chunk (take cnt (min (- (roundup offset BLOCK_SIZE) offset) (length cnt))))\n                               (set! ops (append ops (list (i-file-write fd chunk offset)\n                                                           (i-file-setsize fd (+ offset (length chunk))))))\n                               (set! lengths (hash-set lengths fd (+ (hash-ref lengths fd) (length chunk)))))\n                             ; now write the rest of the file in block-sized chunks\n                             (for ([pos (in-range (roundup offset BLOCK_SIZE) offset-end BLOCK_SIZE)])\n                               (define pos-end (+ pos BLOCK_SIZE))\n                               (define chunk (drop (take cnt (min (- pos-end offset) (length cnt))) (- pos offset)))\n                               (set! lengths (hash-set lengths fd (+ (hash-ref lengths fd) (length chunk))))\n                               ; if pos-end <= len(fd), we can write, otherwise we must extend (alloc new blocks)\n                               (if (<= pos-end (hash-ref block-lengths fd))\n                                   (begin\n                                     (set! ops (append ops (list (i-file-write fd chunk pos)\n                                                                 (i-file-setsize fd pos-end)))))\n                                   (begin\n                                     (if (<= (length chunk) BLOCK_SIZE)\n                                         (begin\n                                           (set! chunk (append chunk (for/list ([i (- BLOCK_SIZE (length chunk))]) #f)))\n                                           (set! ops (append ops (list (i-file-extend fd chunk pos offset-end)))))\n                                         (set! ops (append ops (list (i-file-extend fd chunk pos pos-end)))))\n                                     (set! block-lengths (hash-set block-lengths fd pos-end)))))\n                             ops]\n         [(rename name1 name2)   (i-dir-rename name1 name2)]\n         [(efsync fd e)         (i-swap fd e)]))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Filesystem Engineer, expert in modeling filesystem semantics."},{"role":"user","content":"Model the ext4 inode-operation executor that applies writes, extends, renames, and swaps while preserving sparse file semantics and immutable snapshots."},{"role":"assistant","content":"<think>\nState variables: execute clones dir, fds, and files vectors so each transition returns a new Ext4FS, preserving previous states. Invariant: descriptor indexes and inode numbers stay aligned because updates always use vector-ref on the copied arrays. Transition semantics: do-write fills holes with #f before splicing new bytes alongside existing tail, update-size wraps sizes in fsize to keep symbolic unions, dir-add toggles existence bits and records inode in the fd table, rename swaps inode ownership while zeroing the destination payload, extend/setsize compose do-write with size metadata, and swap is a metadata no-op.\n</think>\n\n```racket\n   ; Executes the inode-op? on this file system and returns the resulting\n   ; file system.\n   (define (execute self call)\n     (match-define (Ext4FS BLOCK_SIZE nodelalloc? dir fds files) self)\n     (define new-dir (make-vector (vector-length dir)))\n     (vector-copy! new-dir 0 dir)\n     (define new-fds (make-vector (vector-length fds)))\n     (vector-copy! new-fds 0 fds)\n     (define new-files (make-vector (vector-length files)))\n     (vector-copy! new-files 0 files)\n     \n     ; Perform a write of the given contents at the given offset\n     (define (do-write fd cnt off)\n       (define ino (vector-ref fds fd))\n       (match-define (file size ondisk) (vector-ref files ino))\n       (define off-end (+ off (length cnt)))\n       (when (> off (length ondisk))\n         (set! ondisk (append ondisk (for/list ([i (- off (length ondisk))]) #f))))\n       (define head (take ondisk off))\n       (define tail (if (< off-end (length ondisk)) (drop ondisk off-end) '()))\n       (define newc (append head cnt tail))\n       (define newf (file size newc))\n       (vector-set! new-files ino newf))\n     ; Update the size metadata of a file\n     (define (update-size fd size)\n       (define ino (vector-ref fds fd))\n       (match-define (file s ondisk) (vector-ref new-files ino))\n       (define newf (file (fsize size) ondisk))\n       (vector-set! new-files ino newf))\n     \n     (match call\n       [(i-dir-add name fd)     (match-define (cons ino exists?) (vector-ref dir name))\n                                ;(vector-set! new-files ino (file 0 '()))\n                                (vector-set! new-dir name (cons ino #t))\n                                (vector-set! new-fds fd ino)]\n       [(i-file-write fd cnt off) (do-write fd cnt off)]\n       [(i-file-extend fd cnt off size) (do-write fd cnt off)\n                                        (update-size fd size)]\n       [(i-file-setsize fd size)        (update-size fd size)]\n       [(i-dir-rename name1 name2)  (unless (= name1 name2)\n                                      (define new-ino (car (vector-ref dir name1)))\n                                      (define old-ino (car (vector-ref dir name2)))\n                                      (vector-set! new-files old-ino (file (fsize 0) '()))\n                                      (vector-set! new-dir name1 (cons old-ino #f))\n                                      (vector-set! new-dir name2 (cons new-ino #t)))]\n       [(i-swap fd enabled)  (void)])\n     (Ext4FS BLOCK_SIZE nodelalloc? new-dir new-fds new-files))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Filesystem Engineer, expert in modeling filesystem semantics."},{"role":"user","content":"Implement an ext4 Rosette observer that returns on-disk file contents only when the directory entry exists, honoring symbolic size metadata."},{"role":"assistant","content":"<think>\nState variables: directory vector supplies inode index plus existence flag, files vector stores (file (fsize size) content). Invariant: observers must not read non-existent entries, and any read must truncate contents to the logical size stored in fsize. Semantics: look up inode by name, guard on exists?, then use for/all over the fsize struct to symbolically reflect every admissible size so take truncates the underlying list appropriately; otherwise return #f to denote missing files.\n</think>\n\n```racket\n   ; Returns the on-disk contents of a file of the given name, or #f if\n   ; the file does not exist.\n   (define (ondisk self name)\n     (match-define (Ext4FS BLOCK_SIZE nodelalloc? dir fds files) self)\n     (define ino (car (vector-ref dir name)))\n     (define exists? (cdr (vector-ref dir name)))\n     (if exists? \n         (begin\n           (define file (vector-ref files ino))\n           (define content (file-ondisk (vector-ref files ino)))\n           (define size (file-size (vector-ref files ino)))\n           ; Here, `size` is an instance of the fsize struct.\n           ; We perform symbolic reflection on that struct to get all possible\n           ; concrete values of the file's size, and perform (take ...) for each one,\n           ; generating a symbolic union of the file's possible contents.\n           ; If we didn't encapsulate size in a struct, it would be an expression\n           ; of type number?, and Rosette would be forced to compile the (take ...)\n           ; to a much larger symbolic union -- one guard for every possible \n           ; number? -- because it could not prove that they are infeasible values of size.\n           (for/all ([size size])\n             (take content (fsize-size size))))\n         #f))\n```"}]}
{"messages":[{"role":"system","content":"You are the Ferrite Rosette Filesystem Engineer, expert in modeling filesystem semantics."},{"role":"user","content":"Define an ext4 observational equivalence predicate that compares two filesystem states by directory entries, file sizes, and truncated on-disk contents."},{"role":"assistant","content":"<think>\nState variables: both Ext4FS arguments expose BLOCK_SIZE, nodelalloc?, dir, fds, and files vectors; obs-equal? iterates aligned directory slots. Invariant: existence booleans must match per entry, and when a file exists the logical size plus on-disk payload prefixes must agree even if there are extra slack bytes. Semantics: build an && over every index, compare exist flags, then under that guard assert equal fsize-size metadata and use for/all over the symbolic size struct to demand that take(file-ondisk ...) prefixes match, ensuring user-visible data equivalence despite internal layout differences.\n</think>\n\n```racket\n   ; Returns #t if this file system is observationally equivalent to the given\n   ; file system, or #f otherwise.\n   (define (obs-equal? self other)\n     (match-define (Ext4FS s-BLOCK_SIZE s-nodelalloc? s-dir s-fds s-files) self)\n     (match-define (Ext4FS o-BLOCK_SIZE o-nodelalloc? o-dir o-fds o-files) other)\n     (apply && (for/list ([i (vector-length s-dir)])\n                 (define s-ino (car (vector-ref s-dir i)))\n                 (define s-exists? (cdr (vector-ref s-dir i)))\n                 (define o-ino (car (vector-ref o-dir i)))\n                 (define o-exists? (cdr (vector-ref o-dir i)))\n                 (define s-file (vector-ref s-files s-ino))\n                 (define o-file (vector-ref o-files o-ino))\n                 (and (equal? s-exists? o-exists?)\n                      (=> s-exists? (and (equal? (fsize-size (file-size s-file)) (fsize-size (file-size o-file)))\n                                         ; The same problem as in (ondisk ...).\n                                         (for/all ([size (file-size s-file)])\n                                           (equal? (take (file-ondisk s-file) (fsize-size size))\n                                                   (take (file-ondisk o-file) (fsize-size size))))))))\n```"}]}
