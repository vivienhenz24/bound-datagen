{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I need a minimal IFC value representation with low/high labels, symbolic label/int generators, and a convenience macro for destructuring labeled values. Please show the exact Rosette DSL definitions I can reuse."},{"role":"assistant","content":"<think>\nNeed the core labeled value DSL: label constants ⊥/⊤, value struct, let@ macro, and symbolic generators (?int/?label/?bool). This is the IFC base that other semantics rely on, so the code must expose @/@int/@label and return-address wrapper R. Keep the exact definitions so the solver can lift terms and labels properly.\n</think>\n\n```racket\n#lang rosette\n\n(require rosette/lib/match)\n\n(provide ⊥ ⊤ 0@⊥ let@ R ?int ?label ?bool value? return? \n         (rename-out [boolean? label?] [|| ∨] [=> ⊑]\n                     [value @]\n                     [value-int @int]\n                     [value-label @label]\n                     [return-pc Rpc]\n                     [return-n Rn]))\n                     \n; Low/high labels.\n(define ⊥ #f)\n(define ⊤ #t)\n\n; Returns a printable representation of a label value.\n(define (format-label L)\n  (cond [(term? L) L]\n        [L '⊤]\n        [else '⊥]))\n\n; A value consists of an integer and a label.\n(struct value (int label)\n  #:transparent\n  #:methods gen:custom-write\n  [(define (write-proc self port mode)\n     (match-let ([(value n Ln) self])\n       (fprintf port \"~s@~s\" n (format-label Ln))))])\n\n; Default (zero) value.\n(define 0@⊥ (value 0 ⊥))\n\n; A convenience macro for deconstructing and binding values.\n(define-syntax let@\n  (syntax-rules ()\n    [(_ () body ...) \n     (let () body ...)]\n    [(_ ([(V L) expr]) body ...)\n     (match expr\n       [(value V L) body ...])]\n    [(_ ([x expr]) body ...)\n     (let ([x expr]) body ...)]\n    [(_ (bind0 bind ...) body ...)\n     (let@ (bind0) (let@ (bind ...) body ...))]))\n\n; Returns a fresh symbolic integer.\n; (-> void? integer?)\n(define (?int)\n  (define-symbolic* n integer?)\n  n)\n\n; Returns a fresh symbolic label.\n; (-> void? label?)\n(define (?label)\n  (define-symbolic* L boolean?)\n  L)\n\n; Returns a fresh symbolic boolean.\n; (-> void? boolean?)\n(define (?bool)\n  (define-symbolic* b boolean?)\n  b)\n\n; A return address wraps a pc value and a value (0 or 1) \n; indicating whether a call returns a value or not.\n(struct return (pc n)\n  #:transparent\n  #:methods gen:custom-write\n  [(define (write-proc self port mode)\n     (fprintf port \"R(~s, ~s)\" (return-pc self) (return-n self)))])\n\n; We'll allow return addresses to be created without providing \n; the number of return values.\n(define-match-expander R\n  (syntax-rules () [(_ pc-pat n-pat) (return pc-pat n-pat)])\n  (syntax-id-rules ()\n    [(R pc)   (return pc 0@⊥)]\n    [(R pc n) (return pc n)]\n    [R        return]))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Show me the IFC instruction representation and the program constructor that generates symbolic instruction sequences. I want the exact Rosette DSL for instruction and program."},{"role":"assistant","content":"<think>\nNeed the instruction struct with prop:procedure to apply over machine state, plus the instruction match expander and program constructor that builds symbolic programs using choose*. This is core to the IFC DSL because verification uses symbolic instruction lists. Keep match on inst-proc and the fresh symbolic argument generation.\n</think>\n\n```racket\n#lang rosette\n\n(require rosette/lib/match rosette/lib/angelic \"value.rkt\")\n\n(provide program instruction\n         (rename-out [inst? instruction?]\n                     [inst-proc procedure]\n                     [inst-args args]))\n\n; An instruction holds a procedure (-> machine? value? ..k), and a \n; list of k values. Applying an instruction i to a machine m evaluates\n; the expression (apply (inst-proc i) m (inst-args i)).\n(struct inst (proc args) \n  #:transparent\n  #:reflection-name 'instruction\n  #:property prop:procedure\n  (lambda (self m)\n    (match (inst-proc self) ; Use match in case inst-proc is symbolic.\n      [(? procedure? proc) (apply proc m (inst-args self))]))\n  #:methods gen:custom-write\n  [(define (write-proc self port mode) \n     (fprintf port \"~s\" (cons (object-name (inst-proc self)) (inst-args self))))])\n\n; Returns a fresh instruction that wraps the given proc \n; and the given arguments, if given.  If no arguments are \n; given, and the procedure accepts k arguments in addition \n; to the first machine? argument, the instruction is \n; initialized with a list of k fresh symbolic values.\n; (-> procedure? [#:rest value?] inst?)\n(define make-inst\n  (case-lambda \n    [(proc)\n     ; Use match in case proc is a symbolic reference---that is, a \n     ; symbolic representation of a procedure.  The use of this form \n     ; ensures that the instruction is correctly constructed for each \n     ; concrete procedure to which the proc reference may be resolved \n     ; by the solver.  This is needed since operations (such as apply \n     ; or procedure-arity) on Racket's procedure data type are not yet \n     ; lifted by rosette itself.\n     (match proc \n       [(? procedure? proc)\n        (inst proc (for/list ([i (sub1 (procedure-arity proc))]) \n                     (@ (?int) (?label))))])]\n    [(proc . args)\n     (inst proc args)]))\n\n; We'll export make-inst as instruction constructor and inst as \n; deconstructor for pattern matching.\n(define-match-expander instruction\n  (syntax-rules () \n    [(_ proc args) (inst proc args)])\n  (syntax-id-rules ()\n    [(instruction proc arg ...) (make-inst proc arg ...)]\n    [instruction                make-inst]))\n\n; Returns thunk that prodcues a list of fresh symbolic instructions. If given a list of k \n; procedures, the thunk's output list contains k instructions such that the ith \n; instruction wraps the ith procedure.  If given an integer LOC and a list\n; of procedures procs, the thunk's output list contains LOC instructions such \n; that the ith instruction wraps any of the procedures in procs. \n(define program\n  (case-lambda \n    [(procs)     (thunk (map instruction procs))]\n    [(LOC procs) (thunk (for/list ([i LOC])\n                          (instruction (apply choose* procs))))])) \n \n\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Please give the IFC machine model (pc/stack/mem/insts) and execution primitives like step/next/push/pop/read/write. I need the exact DSL file used by the IFC semantics."},{"role":"assistant","content":"<think>\nProvide the full machine state representation and operational helpers. The DSL uses labeled pc and value-based stack/memory, plus step to execute instructions. The code must include init/all, halted? predicates, and stack/memory operations so IFC instruction semantics are runnable.\n</think>\n\n```racket\n#lang rosette\n\n(require rosette/lib/match \"value.rkt\" \"instruction.rkt\")\n\n(provide machine machine? halted? halted∩low? init all\n         LOC step push peek pop pop-until read write goto next \n         (rename-out [machine-pc pc]\n                     [machine-insts insts]\n                     [machine-stack stack]\n                     [machine-mem memory])\n         (all-from-out \"value.rkt\" \"instruction.rkt\"))\n     \n; A machine consists of a program counter (represented as a value), a \n; stack (represented as a list of values), a memory (represented as an \n; list of values), and a program (represented as a list of instructions). \n(struct machine (pc stack mem insts) \n  #:transparent\n  #:methods gen:custom-write\n  [(define (write-proc self port mode) \n     (fprintf port \"(machine [pc = ~s]\n\"    (machine-pc self))\n     (fprintf port \"         [stack = ~s]\n\" (machine-stack self))\n     (fprintf port \"         [mem = ~s]\n\"   (machine-mem self))\n     (fprintf port \"         [insts = ~s]\"   (machine-insts self)))])\n\n; Returns a fresh machine initialized with the given program, a pc of \n; 0@⊥, an empty stack, and a memory with M cells set to 0@⊥.  The default \n; value for M is 2. \n; (-> (listof instruction?) machine?)\n; (-> (listof instruction?) integer? machine?)\n(define (init program [M 2])\n  (machine 0@⊥ '() (make-list M 0@⊥) program))\n\n; Returns a fresh machine initialized with the given program, an arbitrary\n; pc, an arbitrary stack of depth S, and an arbitrary memory with M cells. \n; (-> (listof instruction?) integer? integer? machine?)\n(define (all program S M)\n  (machine (@ (?int) (?label)) \n           (for/list ([i S]) (if (?bool) \n                                 (@ (?int) (?label))\n                                 (R (@ (?int) (?label)) (@ (?int) (?label)))))\n           (for/list ([i M]) (@ (?int) (?label)))\n           program))\n\n; Returns the number of instructions comprising the machine's program.\n(define (LOC m) \n  (length (machine-insts m)))\n\n; Returns true iff the given machine is halted.\n(define (halted? m)\n  (let@ ([(pc _) (machine-pc m)])\n    (= pc (LOC m))))\n\n; Returns true iff the given machine is halted with the pc's label set to ⊥.\n(define (halted∩low? m)\n  (let@ ([(pc Lpc) (machine-pc m)])\n    (and (= pc (LOC m)) (equal? ⊥ Lpc))))\n\n; Returns the ith value from the top of the machine's stack, without removing it,\n; where the default value for i is 0.\n; (-> machine? value?)\n; (-> machine? integer? value?)\n(define (peek m [i 0]) \n  (list-ref (machine-stack m) i))\n\n; Functionally inserts the given value at the ith slot in the machine's stack, \n; where the default value for i is 0.\n; (-> machine? value? machine?)\n; (-> machine? integer? value? machine?)\n(define push\n  (case-lambda \n    [(m v)   (struct-copy machine m [stack (cons v (machine-stack m))])]\n    [(m i v) (struct-copy machine m [stack (insert (machine-stack m) i v)])]))\n\n; Functionally removes k values from the top of the machine's stack, where \n; the default value for k is 1.\n; (-> machine? integer? machine?)\n; (-> machine? machine?)\n(define (pop m [k 1])\n  (struct-copy machine m [stack (drop (machine-stack m) k)]))\n\n; Functionally removes values from the top of the machine's stack until it \n; encounters a value that satisfies the given predicate.  The stack of the \n; returned machine consists of that value and the rest of m's stack.\n; (-> machine? (-> any/c boolean?) machine?)\n(define (pop-until m pred)\n  (struct-copy machine m [stack (memf pred (machine-stack m))]))\n\n; Returns the value at the given address in the machine's memory.\n; (-> machine? integer? value?)\n(define (read m idx)    \n  (list-ref (machine-mem m) idx))\n\n; Functionally stores the given value at the given index in the machine's memory.\n; (-> machine? integer? value? machine?)\n(define (write m idx v) \n  (struct-copy machine m [mem (list-set (machine-mem m) idx v)]))\n\n; Functionally sets the machine's pc to the given value. \n; (-> machine? value? machine?)\n(define (goto m n) (struct-copy machine m [pc n]))\n\n; Functionally advances the value of the machine's pc, leaving its tag unchanged.\n; (-> machine? machine?)\n(define (next m)\n  (let@ ([(pc Lpc) (machine-pc m)])\n    (struct-copy machine m [pc (@ (add1 pc) Lpc)])))\n\n; Executes k steps of the machine, returning the resulting machine, where the \n; default value for k is 1.\n; (-> machine? machine?)\n; (-> machine? integer? machine?)\n(define (step m [k 1])\n  ;(printf \"step ~a, stack ~a\\n\" k (machine-stack m))\n  (cond [(or (= k 0) (halted? m)) m]\n        [else (step \n               (match m\n                 [(machine (@ i _) _ _ insts)\n                  ((list-ref insts i) m)])\n               (sub1 k))]))\n\n\n\n  \n\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I want the IFC basic instruction semantics, including the sensitive upgrade check for Store and label propagation for Add/Load. Please provide the exact Rosette code."},{"role":"assistant","content":"<think>\nNeed the basic IFC instruction semantics from basic.rkt, including buggy variants (* forms) and correct versions. This uses let@ to unpack labeled values, checks ⊑ for Store, and propagates joins with ∨. Include the full module so it's runnable with machine.rkt.\n</think>\n\n```racket\n#lang rosette\n\n(require \"machine.rkt\")\n(provide (all-defined-out))\n\n; See Section 2 of the full draft of \"Testing Noninterference, Quickly\".\n; The basic semantics is expressed using the next, peek, push, pop, read and write \n; primitives for manipulating machine state.  These are defined in machine.rkt.\n\n(define (Halt m) \n  (let@ ([(_ Lpc) (pc m)])\n    (goto m (@ (LOC m) Lpc))))\n\n(define (Noop m)   (next m))\n(define (Push m v) (next (push m v)))\n(define (Pop m)    (next (pop m)))\n\n(define (Load* m)\n  (let@ ([(x Lx) (peek m 0)]\n         [v      (read m x)])\n    (next (push (pop m) v))))\n\n(define (Store*AB m)\n  (let@ ([(x _) (peek m 0)]\n         [y     (peek m 1)])\n    (next (write (pop m 2) x y))))\n\n(define (Store*B m)\n  (let@ ([(x Lx) (peek m 0)]\n         [(y Ly) (peek m 1)])\n    (next (write (pop m 2) x (@ y (∨ Lx Ly))))))\n\n(define (Add* m)\n  (let@ ([(x _) (peek m 0)]\n         [(y _) (peek m 1)])\n    (next (push (pop m 2) (@ (+ x y) ⊥)))))\n\n(define (Load m)\n  (let@ ([(x Lx) (peek m 0)]\n         [(v Lv) (read m x)])\n    (next (push (pop m) (@ v (∨ Lx Lv))))))\n\n(define (Store m)\n  (let@ ([(x Lx)  (peek m 0)]\n         [(y Ly)  (peek m 1)]\n         [(_ Lmx) (read m x)])\n    (assert (⊑ Lx Lmx) \"no sensitive upgrade\")\n    (next (write (pop m 2) x (@ y (∨ Lx Ly))))))\n\n(define (Add m)\n  (let@ ([(x Lx) (peek m 0)]\n         [(y Ly) (peek m 1)])\n    (next (push (pop m 2) (@ (+ x y) (∨ Lx Ly))))))\n\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Show the IFC jump instruction variants and the correct Join-with-PC implementation. I want the exact DSL code for Jump, Jump*AB, and Jump*B."},{"role":"assistant","content":"<think>\nNeed the jump semantics variants from jump.rkt. Jump*AB and Jump*B are buggy variants; Jump is correct, joining Lx with Lpc. This relies on pc/peek/pop and goto primitives. Include the full module for runnable context.\n</think>\n\n```racket\n#lang rosette\n\n(require \"machine.rkt\")\n\n(provide (all-defined-out))\n\n; See Section 5 of the full draft of \"Testing Noninterference, Quickly\".\n; The basic semantics is expressed using the next, goto, \n; peek, push, pop, pop-until, read and write primitives \n; for manipulating machine state.  These are defined in machine.rkt.\n; The basic semantics (Halt Noop Push Pop Add Load Store) is defined in basic.rkt.\n\n(define (Jump*AB m)\n  (let@ ([(x _) (peek m 0)])\n    (goto (pop m) (@ x ⊥))))\n\n(define (Jump*B m)\n  (let@ ([x (peek m 0)])\n    (goto (pop m) x)))\n\n(define (Jump m)\n  (let@ ([(x Lx)  (peek m 0)]\n         [(_ Lpc) (pc m)])\n    (goto (pop m) (@ x (∨ Lx Lpc)))))\n\n\n  \n\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I need the IFC Call/Return semantics, including the fixed Return rule and StoreCR/PopCR used with calls. Please provide the exact Rosette definitions."},{"role":"assistant","content":"<think>\nInclude call.rkt with Call/Return variants, StoreCR, PopCR, and the corrected Return that joins return value label with Lpc. This is central to IFC control-flow semantics. Keep the asserts for low labels and return arity.\n</think>\n\n```racket\n#lang rosette\n\n(require \"machine.rkt\" )\n\n(provide (all-defined-out))\n; See Section 5 of the full draft of \"Testing Noninterference, Quickly\".\n; The basic semantics is expressed using the next, goto, \n; peek, push, pop, pop-until, read and write primitives \n; for manipulating machine state.  These are defined in machine.rkt.\n; The basic semantics is defined in basic.rkt.\n;\n; To make instruction implementation uniform, we use values rather \n; than integers for Call and Return arguments; the label of the value \n; is simply ignored.\n\n(define (Call*B m k)\n  (let@ ([(k Lk)   k]\n         [(x Lx)   (peek m 0)]\n         [(pc Lpc) (pc m)])\n    (assert (equal? Lk ⊥))  \n    (goto (push (pop m) k (R (@ (add1 pc) Lpc))) (@ x (∨ Lx Lpc)))))\n\n(define (Return*AB m n)\n  (let@ ([(n Ln) n]\n         [v (peek m 0)]\n         [m (pop-until m return?)]\n         [r (peek m 0)])\n    (assert (equal? Ln ⊥))\n    (assert (|| (= 0 n) (= 1 n)))\n    (if (= n 0)\n        (goto (pop m) (Rpc r))\n        (goto (push (pop m) v) (Rpc r)))))\n\n(define (Return*B m n)\n  (let@ ([(n Ln)  n]\n         [(_ Lpc) (pc m)]\n         [(v _) (peek m 0)]\n         [m (pop-until m return?)]\n         [r (peek m 0)])\n    (assert (equal? Ln ⊥))\n    (assert (|| (= 0 n) (= 1 n)))\n    (if (= n 0)\n        (goto (pop m) (Rpc r))\n        (goto (push (pop m) (@ v Lpc)) (Rpc r))))) ; bug (see Return)\n\n; We use StoreCR for the Store rule that is correct in \n; the presence of Call/Return to avoid conflict with the \n; basic Store rule.\n(define (StoreCR m)\n  (let@ ([(x Lx)  (peek m 0)]\n         [(y Ly)  (peek m 1)]\n         [(_ Lpc) (pc m)]\n         [(_ Lmx) (read m x)])\n    (assert (⊑ (∨ Lpc Lx) Lmx) \"no sensitive upgrade\")\n    (next (write (pop m 2) x (@ y (∨ Lx Ly Lpc))))))\n\n(define (PopCR m)\n  (assert (value? (peek m)))\n  (next (pop m)))\n\n(define (Call m k n)\n  (let@ ([(k Lk)   k]\n         [(vn Ln)  n]\n         [(x Lx)   (peek m 0)]\n         [(pc Lpc) (pc m)])\n    (assert (equal? Lk ⊥))\n    (assert (equal? Ln ⊥))\n    (assert (|| (= 0 vn) (= 1 vn)))\n    (goto (push (pop m) k (R (@ (add1 pc) Lpc) n)) (@ x (∨ Lx Lpc)))))\n\n; Bug in the paper: the label on the returned value should be joined \n; with the PC label (it cannot be just the PC label).\n(define (Return m)\n  (let@ ([(v Lv)  (peek m 0)]\n         [m       (pop-until m return?)]\n         [r       (peek m 0)]\n         [(n _)   (Rn r)]\n         [(_ Lpc) (pc m)])\n    (if (= n 0) \n        (goto (pop m) (Rpc r))\n        (goto (push (pop m) (@ v (∨ Lv Lpc))) (Rpc r)))))\n\n                   \n\n#|\n(define p0\n  (vector-immutable\n   (instruction Push (@ 3 ⊤))\n   (instruction Call*B 0@⊥)\n   (instruction Halt)\n   (instruction Push (@ 1 ⊥))\n   (instruction Push 0@⊥)\n   (instruction Store)\n   (instruction Return*AB 0@⊥)))\n\n(define p1\n  (vector-immutable\n   (instruction Push (@ 6 ⊤))\n   (instruction Call*B 0@⊥)\n   (instruction Halt)\n   (instruction Push (@ 1 ⊥))\n   (instruction Push 0@⊥)\n   (instruction Store)\n   (instruction Return*AB 0@⊥)))\n\n(define m0 (init p0))\n(define m1 (init p1))\n\n(define m0k (step m0 7))\n(define m1k (step m1 7))\n\nm0k\nm1k|#\n\n#|\n\n(define (Call*B m n)\n  (let@ ([(n Ln)    n]\n         [(x Lx)   (peek m 0)]\n         [(pc Lpc) (pc m)])\n    (assert (equal? Ln ⊥)) ; ignore Ln\n    (goto (push (pop m) n (R (@ (add1 pc) Lpc))) (@ x (∨ Lx Lpc)))))\n\n(define (Return*AB m n)\n  (cond [(= (@int n) 0) \n         (let@ ([m (pop-until m return?)]\n                [r (peek m 0)])\n           (goto (pop m) (Rpc r)))]\n        [else \n         (assert (= (@int n) 1))\n         (let@ ([v (peek m 0)]\n                [m (pop-until (pop m) return?)]\n                [r (peek m 0)])\n           (goto (push (pop m) v) (Rpc r)))]))\n\n\n(define (Return*B m n)\n  (cond [(= (@int n) 0) \n         (let@ ([m (pop-until m return?)]\n                [r (peek m 0)])\n           (goto (pop m) (Rpc r)))]\n        [else \n         (assert (= (@int n) 1))\n         (let@ ([(v Lv) (peek m 0)]\n                [m (pop-until (pop m) return?)]\n                [r (peek m 0)]\n                [(_ Lpc) (pc m)])\n           (goto (push (pop m) (@ v Lpc)) (Rpc r)))]))\n\n(define (Call m n v)\n  (assert (|| (= 0 (@int v)) (= 1 (@int v))))\n  (assert (equal? ⊥ (@label v)))\n  (assert (equal? ⊥ (@label n)))\n  (let@ ([(n _)    n]\n         [(x Lx)   (peek m 0)]\n         [(pc Lpc) (pc m)])\n    (goto (push (pop m) n (R (@ (add1 pc) Lpc) v)) (@ x (∨ Lx Lpc)))))\n\n; Bug in the paper: the label on the returned value should be joined \n; with the PC label (it cannot be just the PC label).\n(define (Return m)\n  (let@ ([(v Lv)  (peek m 0)]\n         [m       (pop-until m return?)]\n         [r       (peek m 0)]\n         [(n _)   (Rn r)]\n         [(_ Lpc) (pc m)])\n    (if (= n 0) \n        (goto (pop m) (Rpc r))\n        (goto (push (pop m) (@ v (∨ Lv Lpc))) (Rpc r)))))\n\n|#\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Can you show the indistinguishability relations for IFC machines (≈, mem≈, low≈, full≈) including the cropStack helper? I need the exact Rosette definitions."},{"role":"assistant","content":"<think>\nIndistinguishability relations are central to IFC verification. Provide the ≈ relation over labeled values and machine relations mem≈, low≈, full≈, plus cropStack and low-return-address? The code relies on pattern matching of values, instructions, and machines, and uses ⊤/⊥ labels to decide visibility.\n</think>\n\n```racket\n#lang rosette\n\n(require rosette/lib/match \"machine.rkt\")\n\n(provide ≈ mem≈ low≈ full≈)\n         \n; See Def. 2.3.1 in the full draft of \"Testing Noninterference, Quickly\".\n(define (≈ v0 v1)\n  (match* (v0 v1)\n    [((@ x Lx) (@ y Ly))\n     (and (equal? Lx Ly)\n          (or (equal? Lx ⊤)\n              (equal? x y)))]\n    [((R x _) (R y _)) (≈ x y)]\n    [((instruction p0 args0) (instruction p1 args1))\n     (and (equal? p0 p1)\n          (≈ args0 args1))]\n    [((? list? v0) (? list? v1))\n     (and (= (length v0) (length v1))\n          (andmap ≈ v0 v1))]\n    [(_ _) #f]))\n\n; See Def. 5.1.1. in the full draft of \"Testing Noninterference, Quickly\".\n(define (mem≈ v0 v1)\n  (match* (v0 v1)\n    [((machine (@ _ L0) _ mem0 insts0) (machine (@ _ L1) _ mem1 insts1))\n     (and (equal? L0 L1)\n          (or (equal? L0 ⊤)\n              (and (≈ insts0 insts1)\n                   (≈ mem0 mem1))))]\n    [(_ _) #f]))\n\n; See Def. 6.1.1. in the full draft of \"Testing Noninterference, Quickly\".\n(define (low≈ v0 v1)\n  (match* (v0 v1)\n    [((machine (@ pc0 L0) stack0 mem0 insts0) (machine (@ pc1 L1) stack1 mem1 insts1))\n     (and (equal? L0 L1)\n          (or (equal? L0 ⊤)\n              (and (= pc0 pc1)\n                   (≈ insts0 insts1)\n                   (≈ stack0 stack1)\n                   (≈ mem0 mem1))))]\n    [(_ _) #f]))\n\n; See Def. 6.4.2. in the full draft of \"Testing Noninterference, Quickly\".\n(define (full≈ v0 v1)\n  (match* (v0 v1)\n    [((machine (@ pc0 L0) stack0 mem0 insts0) (machine (@ pc1 L1) stack1 mem1 insts1))\n     (and (equal? L0 L1)\n          (≈ insts0 insts1)\n          (≈ mem0 mem1)\n          (if (equal? L0 ⊥)\n              (and (equal? pc0 pc1)         \n                   (≈ stack0 stack1))\n              (≈ (cropStack stack0) (cropStack stack1))))]))\n\n; The cropStack helper function takes a stack and removes elements from \n; the top until it reaches the first low return address (or until all \n; elements are removed).\n(define (cropStack s)\n  (or (memf low-return-address? s) '()))\n\n; Returns true iff v is a return value, and (Rpc v) has the low label.\n(define (low-return-address? v)\n  (and (return? v)\n       (let@ ([(_ L) (Rpc v)])\n             (equal? L ⊥))))\n  \n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"I want the IFC EENI verification routine that sets up two machines, runs k steps, and uses Rosette verify/assume/assert to check indistinguishability. Please show the exact implementation."},{"role":"assistant","content":"<think>\nNeed verify.rkt with verify-EENI and verify-EENI* that constructs two machines from a symbolic program, steps them, and uses verify to check the EENI condition. This includes with-terms, current-bitwidth, and EENI-witness struct to return counterexamples.\n</think>\n\n```racket\n#lang rosette\n\n(require \"machine.rkt\" \"indistinguishable.rkt\")\n\n(provide verify-EENI verify-EENI* (struct-out EENI-witness))\n\n; Verifies the EENI[start, end, ≈] property for machines executing \n; k steps of a program that is indistinguishable from the given program.  \n; The start argument is a procedure that takes as input a program and \n; returns a fresh machine m initialized with that program.  The pc, \n; stack and memory of every machine m0 and m1 returned by start must be \n; indistinguishable. The end argument is a predicate on machines, and \n; ≈ is an indistinguishability relation on machines.  The length \n; of the program list is used as the default value for the number of steps.\n; (-> (-> (-> () (listof instruction?)) machine?)\n;     (-> machine? boolean?)\n;     (-> machine? machine? boolean?)\n;     (listof instruction?)\n;     [(or/c integer? #f)]\n;     void?)\n(define (verify-EENI start end ≈ prog [k #f])\n  (time (displayln (verify-EENI* start end ≈ prog k #t))))\n\n; Verifies the EENI[start, end, ≈] property for machines executing \n; k steps of a program that is indistinguishable from the given program.  \n; The start argument is a procedure that takes as input a program and \n; returns a fresh machine m initialized with that program.  The pc, \n; stack and memory of every machine m0 and m1 returned by start must be \n; indistinguishable. The end argument is a predicate on machines, and \n; ≈ is an indistinguishability relation on machines.  The length \n; of the program list is used as the default value for the number of steps.\n; The procedure returns a counterexample, if any, that the EENI[start, end, ≈] \n; property is violated by producing an EENI-witness.  If there are no \n; counterexample, the procedure returns #t.\n; (-> (-> (-> () (listof instruction?)) machine?)\n;     (-> machine? boolean?)\n;     (-> machine? machine? boolean?)\n;     (listof instruction?)\n;     [(or/c integer? #f)]\n;     (or/c EENI-witness? #t))\n(define (verify-EENI* start end ≈ prog [k #f] [verbose? #f])\n  (with-terms\n    (parameterize ([current-bitwidth 5])\n    \n      (define p (prog))\n    \n      (unless k \n        (set! k (length p)))\n    \n      (when verbose?\n        (printf \"\\n-------Verify EENI[~a, ~a, ~a] for ~a steps of ~s-------\\n\"\n                (object-name start) (object-name end) (object-name ≈) k (format-program p)))\n\n      (define m0 (start p))\n      (define m1 (start (map instruction (map procedure p)))) ; Use a fresh program (same procedures, fresh args).\n    \n      (define cex\n        (result-value\n         (with-vc\n             (let* ([m0k (step m0 k)]\n                    [m1k (step m1 k)])\n               (verify\n                (begin\n                  (assume (≈ m0 m1))\n                  (assume (end m0k))\n                  (assume (end m1k))\n                  (assert (≈ m0k m1k))))))))\n       \n    \n      (if (sat? cex) (EENI-witness (evaluate m0 cex) (evaluate m1 cex) k ≈) #t))))\n\n(struct EENI-witness (m0 m1 k ≈)\n  #:transparent \n  #:guard (lambda (m0 m1 k ≈ id)\n            (unless (and (≈ m0 m1) (not (≈ (step m0 k) (step m1 k))))\n              (error id \"Not a valid EENI witness: ~a, ~a, ~a, ~a.\" m0 m1 k ≈))\n            (values m0 m1 k ≈))\n  #:methods gen:custom-write\n  [(define (write-proc self port mode)\n     (match-let ([(EENI-witness m0 m1 k _) self])\n        (fprintf port \"m0 initial:\\n~s\\n\" m0)\n        (fprintf port \"m0 final:\\n~s\\n\" (step m0 k))\n        (fprintf port \"m1 initial:\\n~s\\n\" m1)\n        (fprintf port \"m1 final:\\n~s\" (step m1 k))))])\n        \n     \n; Returns a printable representation of the given program.\n(define (format-program prog)\n  (match prog\n    [(list (instruction (? union? r) _) _ ...)        \n     (sort (map object-name (union-values r)) string<? #:key symbol->string)]\n    [(list (instruction (? procedure? proc) _) ...) \n     (map object-name proc)]))\n```\n"}]}
