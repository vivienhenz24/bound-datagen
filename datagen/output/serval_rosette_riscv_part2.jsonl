{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"Can you show the Rosette semantics for the CR two-register compressed instructions c.mv and c.add?"},{"role":"assistant","content":"<think>\nDecode the nz-rs1/rd and nz-rs2 fields with decode-gpr so we operate on the symbolic register file. reg-reg-op reads rs2, applies the supplied op, writes back to rs1/rd, and cpu-next! keeps execution moving, so c.mv just forwards the second operand while c.add adds both bitvectors. No solver calls are needed because everything is concretely determined by the decoded fields.\n</think>\n\n```racket\n(define ((interpret-cr-2reg-type op) cpu insn rs1/rd rs2)\n  (reg-reg-op op cpu insn (decode-gpr rs2) (decode-gpr rs1/rd) (decode-gpr rs1/rd)))\n\n(define-insn (nz-rs1/rd nz-rs2)\n  #:encode (lambda (funct4 op)\n                   (list (bv funct4 4) nz-rs1/rd nz-rs2 (bv op 2)))\n  [(#b1000 #b10) c.mv  (interpret-cr-2reg-type (lambda (a b) b))]\n  [(#b1001 #b10) c.add (interpret-cr-2reg-type bvadd)])\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"I need the Rosette model of the compressed c.jr/c.jalr instructions."},{"role":"assistant","content":"<think>\nDecode the nz-rs1/rd field to pick the jump register, optionally write the link address (pc+2) into ra, then use for/all to mask off bit 0 of the symbolic target so the solver enforces aligned control flow. Finally set-cpu-pc! updates the PC, giving c.jr a plain jump and c.jalr the link behavior.\n</think>\n\n```racket\n(define ((interpret-cr-jmp link) cpu insn nz-rs1/rd)\n  (define rs1 (decode-gpr nz-rs1/rd))\n\n  (when link\n    (define next (bvadd (cpu-pc cpu) (bv 2 (cpu-xlen cpu))))\n    (gpr-set! cpu 'ra next))\n\n  (define target\n    (for/all ([src (gpr-ref cpu rs1) #:exhaustive])\n      (bvand (bvnot (bv 1 (cpu-xlen cpu))) src)))\n  (set-cpu-pc! cpu target))\n\n(define-insn (nz-rs1/rd)\n  #:encode (lambda (funct4 op)\n                   (list (bv funct4 4) nz-rs1/rd (bv 0 5) (bv op 2)))\n  [(#b1000 #b10) c.jr (interpret-cr-jmp #f)]\n  [(#b1001 #b10) c.jalr (interpret-cr-jmp #t)])\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"Walk me through the Rosette semantics for the compressed c.addi16sp instruction."},{"role":"assistant","content":"<think>\nRebuild the stack-pointer immediate from nzimm9 and nzimm4&6&8:7&5, sign-extend it to XLEN, and assert it's non-zero per the ISA. Then add it to the symbolic sp register and advance the CPU, modeling the stack bump this instruction performs.\n</think>\n\n```racket\n(define (interpret-c.addi16sp cpu insn nzimm9 nzimm4&6&8:7&5)\n  (define xlen (cpu-xlen cpu))\n  (define imm\n    (sign-extend\n      (concat (extract 0 0 nzimm9)\n              (extract 2 1 nzimm4&6&8:7&5)\n              (extract 3 3 nzimm4&6&8:7&5)\n              (extract 0 0 nzimm4&6&8:7&5)\n              (extract 4 4 nzimm4&6&8:7&5)\n              (bv 0 4))\n      (bitvector xlen)))\n\n  (core:bug-on (bvzero? imm) #:msg \"c.addi16sp: imm cannot be zero\")\n\n  (gpr-set! cpu 'sp (bvadd (gpr-ref cpu 'sp) imm))\n\n  (cpu-next! cpu insn))\n\n(define-insn (nzimm9 nzimm4&6&8:7&5)\n  #:encode (lambda (funct3 op)\n                   (list (bv funct3 3) nzimm9 (bv 2 5) nzimm4&6&8:7&5 (bv op 2)))\n  [(#b011 #b01) c.addi16sp interpret-c.addi16sp])\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"Provide the Rosette snippet that interprets c.addi4spn."},{"role":"assistant","content":"<think>\nFor the CIW form we decode the compressed rd^ field and rebuild the non-zero unsigned immediate from the scattered bit slices, zero-extending it to the current XLEN. Adding that offset to sp populates the compact stack-pointer relative destination before cpu-next! advances execution.\n</think>\n\n```racket\n(define (interpret-c.addi4spn cpu insn nzuimm5:4&9:6&2&3 rd^)\n  (define xlen (cpu-xlen cpu))\n  (define rd (decode-compressed-gpr rd^))\n\n  (define imm\n    (zero-extend\n      (concat (extract 5 2 nzuimm5:4&9:6&2&3)\n              (extract 7 6 nzuimm5:4&9:6&2&3)\n              (extract 0 0 nzuimm5:4&9:6&2&3)\n              (extract 1 1 nzuimm5:4&9:6&2&3)\n              (bv 0 2))\n      (bitvector xlen)))\n\n  (gpr-set! cpu rd (bvadd (gpr-ref cpu 'sp) imm))\n  (cpu-next! cpu insn))\n\n(define-insn (nzuimm5:4&9:6&2&3 rd^)\n  #:encode (lambda (funct3 op)\n                   (list (bv funct3 3) nzuimm5:4&9:6&2&3 rd^ (bv op 2)))\n  [(#b000 #b00) c.addi4spn interpret-c.addi4spn])\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"Show the Rosette interpreter code for the compressed c.lw load."},{"role":"assistant","content":"<think>\nThe CL format splits the offset across uimm5:3 and uimm2&6, so we reassemble it, zero-extend to XLEN, and add it to the decoded base register from the compressed register set. We then use core:memmgr-load to fetch the 4-byte value, sign-extend it to XLEN, write it into rd, and step the CPU.\n</think>\n\n```racket\n(define ((interpret-cl-type size) cpu insn imm_hi rs1^ imm_lo rd^)\n  (define xlen (cpu-xlen cpu))\n  (define mm (cpu-memmgr cpu))\n  (define rs (decode-compressed-gpr rs1^))\n  (define rd (decode-compressed-gpr rd^))\n  (define off\n    (zero-extend\n      (cond\n        [(= size 4)\n          ; decode offset[5:3] and offset[2|6]\n          (concat (extract 0 0 imm_lo)\n                  (extract 2 0 imm_hi)\n                  (extract 1 1 imm_lo)\n                  (bv 0 2))]\n        [(= size 8)\n          ; decode offset[5:3] and offset[7:6]\n          (concat (extract 1 0 imm_lo)\n                  (extract 2 0 imm_hi)\n                  (bv 0 3))])\n      (bitvector xlen)))\n\n  (define addr (bvadd (gpr-ref cpu rs) off))\n  (define value (core:memmgr-load mm addr (bv 0 xlen) (bv size xlen)))\n\n  ; Always sign-extend.\n  (set! value (sign-extend value (bitvector xlen)))\n\n  (gpr-set! cpu rd value)\n  (cpu-next! cpu insn))\n\n(define-insn (uimm5:3 rs1^ uimm2&6 rd^)\n  #:encode (lambda (funct3 op)\n                   (list (bv funct3 3) uimm5:3 rs1^ uimm2&6 rd^ (bv op 2)))\n  [(#b010 #b00) c.lw (interpret-cl-type 4)])\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"How are the compressed branch instructions c.beqz and c.bnez encoded in Rosette?"},{"role":"assistant","content":"<think>\nCB branches reconstruct their offsets from imm8&4:3 and imm7:6&2:1&5, align them, and evaluate the predicate on the decoded compressed register. If the predicate succeeds we sign-extend the offset to XLEN and add it to the current pc; otherwise cpu-next! falls through.\n</think>\n\n```racket\n(define ((interpret-c-branch op) cpu insn imm8&4:3 rs1^ imm7:6&2:1&5)\n  (define xlen (cpu-xlen cpu))\n\n  (define off\n    (concat (extract 2 2 imm8&4:3)\n            (extract 4 3 imm7:6&2:1&5)\n            (extract 0 0 imm7:6&2:1&5)\n            (extract 1 0 imm8&4:3)\n            (extract 2 1 imm7:6&2:1&5)\n            (bv 0 1)))\n\n  (define a (gpr-ref cpu (decode-compressed-gpr rs1^)))\n  (define branch (op a))\n\n  (if branch\n    (set-cpu-pc! cpu (bvadd (cpu-pc cpu) (sign-extend off (bitvector xlen))))\n    (cpu-next! cpu insn)))\n\n(define-insn (imm8&4:3 rs1^ imm7:6&2:1&5)\n  #:encode (lambda (funct3 op)\n                   (list (bv funct3 3) imm8&4:3 rs1^ imm7:6&2:1&5 (bv op 2)))\n  [(#b110 #b01) c.beqz (interpret-c-branch bvzero?)]\n  [(#b111 #b01) c.bnez (interpret-c-branch (compose ! bvzero?))])\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"Please share the Rosette helper that declares the RISC-V register bundle and produces a zeroed state."},{"role":"assistant","content":"<think>\nWe package the architectural state in a regs struct that lists every integer and supervisor CSR we care about, along with an equality procedure so symbolic comparisons work under gen:equal+hash. zero-regs simply constructs that struct with 64-bit zero bitvectors, giving a clean initial state for specs or interpreters.\n</think>\n\n```racket\n(struct regs\n  (ra sp gp tp t0 t1 t2 s0 s1 a0 a1 a2 a3 a4 a5 a6 a7 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 t3 t4 t5 t6\n  satp scause scounteren sepc sscratch sstatus stvec stval mepc sip sie)\n  #:methods\n  gen:equal+hash\n  [(define (equal-proc a b equal?-recur)\n    (&& (equal?-recur (regs-ra a) (regs-ra b))\n        (equal?-recur (regs-sp a) (regs-sp b))\n        (equal?-recur (regs-gp a) (regs-gp b))\n        (equal?-recur (regs-tp a) (regs-tp b))\n        (equal?-recur (regs-t0 a) (regs-t0 b))\n        (equal?-recur (regs-t1 a) (regs-t1 b))\n        (equal?-recur (regs-t2 a) (regs-t2 b))\n        (equal?-recur (regs-s0 a) (regs-s0 b))\n        (equal?-recur (regs-s1 a) (regs-s1 b))\n        (equal?-recur (regs-a0 a) (regs-a0 b))\n        (equal?-recur (regs-a1 a) (regs-a1 b))\n        (equal?-recur (regs-a2 a) (regs-a2 b))\n        (equal?-recur (regs-a3 a) (regs-a3 b))\n        (equal?-recur (regs-a4 a) (regs-a4 b))\n        (equal?-recur (regs-a5 a) (regs-a5 b))\n        (equal?-recur (regs-a6 a) (regs-a6 b))\n        (equal?-recur (regs-a7 a) (regs-a7 b))\n        (equal?-recur (regs-s2 a) (regs-s2 b))\n        (equal?-recur (regs-s3 a) (regs-s3 b))\n        (equal?-recur (regs-s4 a) (regs-s4 b))\n        (equal?-recur (regs-s5 a) (regs-s5 b))\n        (equal?-recur (regs-s6 a) (regs-s6 b))\n        (equal?-recur (regs-s7 a) (regs-s7 b))\n        (equal?-recur (regs-s8 a) (regs-s8 b))\n        (equal?-recur (regs-s9 a) (regs-s9 b))\n        (equal?-recur (regs-s10 a) (regs-s10 b))\n        (equal?-recur (regs-s11 a) (regs-s11 b))\n        (equal?-recur (regs-t3 a) (regs-t3 b))\n        (equal?-recur (regs-t4 a) (regs-t4 b))\n        (equal?-recur (regs-t5 a) (regs-t5 b))\n        (equal?-recur (regs-t6 a) (regs-t6 b))\n        (equal?-recur (regs-satp a) (regs-satp b))\n        (equal?-recur (regs-scause a) (regs-scause b))\n        (equal?-recur (regs-scounteren a) (regs-scounteren b))\n        (equal?-recur (regs-sepc a) (regs-sepc b))\n        (equal?-recur (regs-sscratch a) (regs-sscratch b))\n        (equal?-recur (regs-sstatus a) (regs-sstatus b))\n        (equal?-recur (regs-stvec a) (regs-stvec b))\n        (equal?-recur (regs-stval a) (regs-stval b))\n        (equal?-recur (regs-mepc a) (regs-mepc b))\n        (equal?-recur (regs-sip a) (regs-sip b))\n        (equal?-recur (regs-sie a) (regs-sie b))))\n\n   (define (hash-proc a hash-recur) 1)\n   (define (hash2-proc a hash2-recur) 22)])\n\n(define (zero-regs)\n  (regs (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64)\n        (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64)\n        (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64)\n        (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64)\n        (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64) (bv 0 64)\n        (bv 0 64) (bv 0 64)))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"What shim do we use to model the libc memset call on RISC-V?"},{"role":"assistant","content":"<think>\nThe shim reads its arguments from a0/a1/a2, masks the byte value down to 8 bits, and relies on the memmgr to blast len bytes starting at ptr. Afterwards it mimics a ret by restoring pc from x1, havocing caller-saved registers, and returns ptr in a0.\n</think>\n\n```racket\n(define (memset-shim cpu)\n  (define ptr (gpr-ref cpu 'a0))\n  (define c (extract 7 0 (gpr-ref cpu 'a1)))\n  (define len (gpr-ref cpu 'a2))\n\n  ; Use memmgr to implement memset.\n  (define memmgr (cpu-memmgr cpu))\n  (memmgr-memset! memmgr ptr c len)\n\n  ; Fake a 'ret' instruction to return control to calling function.\n  (set-cpu-pc! cpu (gpr-ref cpu 'x1))\n  (havoc-caller-saved! cpu)\n  (gpr-set! cpu 'a0 ptr))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"Give me the Rosette helper that checks PMP permissions for an access."},{"role":"assistant","content":"<think>\npmp-privs pulls the current pmpcfg0/2 and pmpaddr registers from the csr file, slices each 8-bit config entry, and recursively walks them to interpret OFF, TOR, and NAPOT modes. For TOR we compare the symbolic ptr/size range against successive bounds to detect overlaps, returning the permissions if the access is fully contained, otherwise we fall through until either a match is found or we default to RWX.\n</think>\n\n```racket\n(define PMPCFG_A_OFF 0)\n(define PMPCFG_A_NAPOT 24)\n(define PMPCFG_A_TOR 8)\n(define PMPCFG_R 1)\n(define PMPCFG_W 2)\n(define PMPCFG_X 4)\n(define PMPCFG_RWX 7)\n\n(define (pmp-privs cpu ptr size)\n  (define pmpcfg0 (csr-ref cpu 'pmpcfg0))\n  (define pmpcfg2 (csr-ref cpu 'pmpcfg2))\n\n  (define addrs (map (lambda (r) (csr-ref cpu r))\n                     '(pmpaddr0 pmpaddr1 pmpaddr2 pmpaddr3\n                       pmpaddr4 pmpaddr5 pmpaddr6 pmpaddr7\n                       pmpaddr8 pmpaddr9 pmpaddr10 pmpaddr11\n                       pmpaddr12 pmpaddr13 pmpaddr14 pmpaddr15)))\n  (define configs\n    (list (extract 7 0 pmpcfg0)\n          (extract 15 8 pmpcfg0)\n          (extract 23 16 pmpcfg0)\n          (extract 31 24 pmpcfg0)\n          (extract 39 32 pmpcfg0)\n          (extract 47 40 pmpcfg0)\n          (extract 55 48 pmpcfg0)\n          (extract 63 56 pmpcfg0)\n          (extract 7 0 pmpcfg2)\n          (extract 15 8 pmpcfg2)\n          (extract 23 16 pmpcfg2)\n          (extract 31 24 pmpcfg2)\n          (extract 39 32 pmpcfg2)\n          (extract 47 40 pmpcfg2)\n          (extract 55 48 pmpcfg2)\n          (extract 63 56 pmpcfg2)))\n\n  (define (pmp-privs prev-addr any? cfgs addrs)\n    (match (cons cfgs addrs)\n      [(cons (cons cfg cfgs-rest) (cons addr addrs-rest))\n\n        (define cfg-a (bvand cfg (bv PMPCFG_A_NAPOT 8)))\n        (define cfg-perm (bvand cfg (bv PMPCFG_RWX 8)))\n        (define this-addr (bvshl addr (bv 2 64)))\n\n        (cond\n          [(bveq cfg-a (bv PMPCFG_A_OFF 8))\n            (pmp-privs this-addr any? cfgs-rest addrs-rest)]\n          [(bveq cfg-a (bv PMPCFG_A_TOR 8))\n\n            (define overlaps (&& (bvugt (bvadd ptr size) prev-addr)\n                                 (bvult ptr this-addr)))\n            (define contains (&& (bvuge ptr prev-addr)\n                                 (bvule (bvadd ptr size) this-addr)))\n            (if overlaps\n              (if contains cfg-perm (bv 0 8))\n              (pmp-privs this-addr #t cfgs-rest addrs-rest))]\n          [else (assert #f)])]\n      [(cons null null) (if (! any?) (bv PMPCFG_RWX 8) (bv 0 8))]\n      [_ (assert #f)]))\n\n  (pmp-privs (bv 0 64) #f configs addrs))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in RISC-V Rosette modeling."},{"role":"user","content":"How does the objdump frontend in Rosette compile parsed instructions into a program?"},{"role":"assistant","content":"<think>\nWe parse each objdump tuple by turning the raw hex into a bitvector via parse-objdump-instr, then compile-objdump-program asserts a concrete context and non-empty instruction stream. It builds a hash from addresses to decoded instructions, using either the provided size/raw or the ISA default, and finally wraps that in a program record for interpret-program.\n</think>\n\n```racket\n(define (parse-objdump-instr i #:addr i-addr #:size size #:raw [raw #f])\n  (define rawbv (bv (string->number raw 16) (* 8 size)))\n  (decode rawbv))\n\n(define (compile-objdump-program instructions)\n  (core:bug-on (! (core:concrete?)))\n  (core:bug-on (null? instructions) #:msg \"Cannot have empty objdump program.\")\n  (define base (bv (car (list-ref instructions 0)) (XLEN())))\n  (define insn-hash\n    (for/hash ([insn instructions])\n      (define addr (bv (car insn) (XLEN)))\n      (define instr\n        (match (cdr insn)\n          [(list (list i ...) '#:size size '#:raw raw)\n            (parse-objdump-instr i #:addr addr #:size size #:raw raw)]\n          [(list i ...) #:when (riscv-default-size)\n            (parse-objdump-instr i #:addr addr #:size (riscv-default-size))]\n          [_\n            (core:bug #:msg (format \"Bad objdump ~e\" instr))]))\n      (values addr instr)))\n  (program base insn-hash))\n```\n"}]}
