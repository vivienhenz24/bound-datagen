{"messages":[{"role":"system","content":"You are a Rosette engineer expert in symbolic execution and solver-aided programming."},{"role":"user","content":"I need a Rosette utility that substitutes every occurrence of a sub-expression e1 inside an expression tree with e2 while preserving all other AST nodes like tuples, calls, and new declarations."},{"role":"assistant","content":"<think>\nDefine rewrite-expr that compares the current node against the target, recursively maps over every constructor (ETuple, ESeq, ECVar, etc.), and uses match to ensure unknown variants raise an error.\n</think>\n\n```racket\n; return expr[e1 := e2]\n(define (rewrite-expr expr e1 e2)\n  (cond\n    [(equal? expr e1) e2]\n    [else\n     (define rec (curryr rewrite-expr e1 e2))\n     (match expr\n       [(EVar _) expr]\n       [(EConst _) expr]\n       [(ETuple elts) (ETuple (map rec elts))]\n       [(ESeq e1 e2) (ESeq (rec e1) (rec e2))]\n       [(ECVar obj name idx) (ECVar (rec obj) name (rec idx))]\n       [(ENew locals body)\n        (ENew (for/list ([l locals]) (Init (Init-name l) (rec (Init-val l))))\n              (rec body))]\n       [(EMethod name args body)\n        (EMethod name args (rec body))]\n       [(EAssign lhs rhs)\n        (EAssign (rec lhs) (rec rhs))]\n       [(ECall obj name vars)\n        (ECall (rec obj) name (map rec vars))]\n       [(EITE cnd thn els)\n        (EITE (rec cnd) (rec thn) (rec els))]\n       [(ENop) expr]\n       [_ (error 'rewrite-expr \"unknown expr: ~v\" expr)])]))\n```"}]}
{"messages":[{"role":"system","content":"You are a Rosette engineer expert in symbolic execution and solver-aided programming."},{"role":"user","content":"Extend the rewriting pass so that when I rewrite an entire execution context, every method body is rewritten using the same substitution helper over expressions."},{"role":"assistant","content":"<think>\nOnly method bodies need substitution, so iterate over Context-methods, rebuild the association lists, and rebuild each Method with rewrite-expr applied to its body while preserving names and args.\n</think>\n\n```racket\n; return ctx[e1 := e2]\n; (only method bodies need rewriting)\n(define (rewrite-context ctx e1 e2)\n  (Context-with-methods\n   ctx\n   (for/list ([addr/mtds (Context-methods ctx)])\n     (cons (car addr/mtds)\n           (for/list ([name/mtd (cdr addr/mtds)])\n             (match-define (Method name args body) (cdr name/mtd))\n             (cons (car name/mtd)\n                   (Method name args (rewrite-expr body e1 e2))))))))\n```"}]}
