{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Verify a simple SynthCL kernel that adds an offset to each element of an array and prove the host-side OpenCL wrapper matches a sequential spec for small array lengths divisible by 4."},{"role":"assistant","content":"<think>\nUse the SynthCL kernel form to compute dst[id] = src[id] + offset with get_global_id. The host procedure allocates buffers, sets kernel args, and launches NDRange with global and local sizes. The verify form quantifies symbolic offset, len, and src, and checks host vs spec with element-wise assertions. The solver should show the OpenCL wrapper is correct for lengths 4..16.\n</think>\n\n```racket\n#lang s-exp \"../../../lang/main.rkt\"\n\n(kernel void (sample [int* dst] [int* src] [int offset])\n  (: int id)\n  (= id (get_global_id 0))\n  (= [dst id] (+ [src id] offset)))\n```\n\n```racket\n#lang s-exp \"../../../lang/main.rkt\"\n\n; Given a src array of length SIZE, returns a new array dst of \n; the same size, such that dst[i] = src[i] + offset, for all \n; 0 <= i < SIZE.  The SIZE parameter must be evenly divisible by 4.\n(procedure int* (host [int* src] [int SIZE] [int offset])\n  (: cl_context context)\n  (: cl_command_queue command_queue)\n  (: cl_program program)\n  (: cl_kernel kernel)\n  (: cl_mem buffer_src buffer_dst)\n  (: int* dst)\n  (: int local global)\n  \n  (= local 4)\n  (= global SIZE)\n  \n  (= dst ((int*) (malloc (* SIZE (sizeof int)))))\n  \n  (= context (clCreateContext))\n  \n  (= command_queue (clCreateCommandQueue context))\n \n  (= buffer_src (clCreateBuffer context CL_MEM_READ_ONLY (* SIZE (sizeof int))))\n  (= buffer_dst (clCreateBuffer context CL_MEM_WRITE_ONLY (* SIZE (sizeof int))))\n  \n  (= program (clCreateProgramWithSource context \"kernel.rkt\"))\n  \n  (clEnqueueWriteBuffer command_queue buffer_src 0 SIZE src)\n  \n  (= kernel (clCreateKernel program \"sample\"))\n  (clSetKernelArg kernel 0 buffer_dst)\n  (clSetKernelArg kernel 1 buffer_src)\n  (clSetKernelArg kernel 2 offset)\n\n  (clEnqueueNDRangeKernel command_queue kernel 1 NULL (@ global) (@ local))\n  (clEnqueueReadBuffer command_queue buffer_dst 0 SIZE dst)\n  dst)\n\n; The reference implementation for the host procedure. \n; Given a src array of length SIZE, returns a new array dst of \n; the same size, such that dst[i] = src[i] + offset, for all \n; 0 <= i < SIZE.  The SIZE parameter must be evenly divisible by 4.\n(procedure int* (spec [int* src] [int SIZE] [int offset])\n  (: int* dst)\n  (= dst ((int*) (malloc (* SIZE (sizeof int)))))\n  (for [(: int i in (range SIZE))]\n;    (= [dst i] (?: (&& (== SIZE 16) (== offset -1)) \n;                   (- [src i] offset) \n;                   (+ [src i] offset)))) ; sample bug\n    (= [dst i] (+ [src i] offset)))\n  dst)\n  \n; Given two arrays of the same size, checks that they hold the same \n; values at each index.\n(procedure void (check [int* actual] [int* expected] [int SIZE])\n  (assert (>= SIZE 0))\n  (for [(: int i in (range SIZE))]\n    (assert (== [actual i] [expected i]))))\n\n; Verify the host procedure for all small arrays of length that is \n; evenly divisible by 4.\n(verify #:forall [(: int offset)\n                  (: int len in (range 4 17 4))\n                  (: int[len] src)] \n        #:ensure (check (host src len offset) (spec src len offset) len))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Synthesize the missing indexing choice in a vectorized SynthCL kernel so the host wrapper matches a scalar specification for sizes divisible by 4."},{"role":"assistant","content":"<think>\nThe kernel uses choose to synthesize the index expression used for int4 array access. The host procedure launches the kernel with a global size of SIZE/4 and uses clSetKernelArg for dst/src/offset. The synth form quantifies symbolic offset, len, and src and ensures host equals spec, so the solver should pick the correct index mapping among the candidates.\n</think>\n\n```racket\n#lang s-exp \"../../../lang/main.rkt\"\n\n\n(kernel void (sample [int4* dst] [int4* src] [int4 offset])\n  (: int id idx)\n  (= id (get_global_id 0))\n  (= idx (choose id (/ id 4) (% id 4) (+ id 4) (* id 4) (- id 4)))\n  (= [dst idx] (+ [src idx] offset)))\n```\n\n```racket\n#lang s-exp \"../../../lang/main.rkt\"\n\n; Given a src array of length SIZE, returns a new array dst of \n; the same size, such that dst[i] = src[i] + offset, for all \n; 0 <= i < SIZE.  The SIZE parameter must be evenly divisible by 4.\n(procedure int* (host [int* src] [int SIZE] [int offset])\n  (: cl_context context)\n  (: cl_command_queue command_queue)\n  (: cl_program program)\n  (: cl_kernel kernel)\n  (: cl_mem buffer_src buffer_dst)\n  (: int* dst)\n  (: int global)\n\n  (= global (/ SIZE 4))\n  \n  (= dst ((int*) (malloc (* SIZE (sizeof int)))))\n  \n  (= context (clCreateContext))\n  \n  (= command_queue (clCreateCommandQueue context))\n \n  (= buffer_src (clCreateBuffer context CL_MEM_READ_ONLY (* SIZE (sizeof int))))\n  (= buffer_dst (clCreateBuffer context CL_MEM_WRITE_ONLY (* SIZE (sizeof int))))\n  \n  (= program (clCreateProgramWithSource context \"kernel.rkt\"))\n  \n  (clEnqueueWriteBuffer command_queue buffer_src 0 SIZE src)\n  \n  (= kernel (clCreateKernel program \"sample\"))\n  (clSetKernelArg kernel 0 buffer_dst)\n  (clSetKernelArg kernel 1 buffer_src)\n  (clSetKernelArg kernel 2 offset)\n\n  (clEnqueueNDRangeKernel command_queue kernel 1 NULL (@ global) NULL)\n  (clEnqueueReadBuffer command_queue buffer_dst 0 SIZE dst)\n  dst)\n\n; The reference implementation for the host procedure. \n; Given a src array of length SIZE, returns a new array dst of \n; the same size, such that dst[i] = src[i] + offset, for all \n; 0 <= i < SIZE.  The SIZE parameter must be evenly divisible by 4.\n(procedure int* (spec [int* src] [int SIZE] [int offset])\n  (: int* dst)\n  (= dst ((int*) (malloc (* SIZE (sizeof int)))))\n  (for [(: int i in (range SIZE))]\n;    (= [dst i] (?: (&& (== SIZE 16) (== offset -1)) \n;                   (- [src i] offset) \n;                   (+ [src i] offset)))) ; sample bug\n    (= [dst i] (+ [src i] offset)))\n  dst)\n  \n; Given two arrays of the same size, checks that they hold the same \n; values at each index.\n(procedure void (check [int* actual] [int* expected] [int SIZE])\n  (assert (>= SIZE 0))\n  (for [(: int i in (range SIZE))]\n    (assert (== [actual i] [expected i]))))\n\n; Synthesize the kernel procedure so that it is correct for all small \n; arrays of length that is evenly divisible by 4.  In this case, we are \n; ensuring correctness for all arrays of size 4, 8, 12, 16 and 20.\n(synth #:forall [(: int offset)\n                 (: int len in (range 4 21 4))\n                 (: int[len] src)] \n       #:ensure (check (host src len offset) (spec src len offset) len))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Prove the scalar Fast Walsh Transform kernel and host wrapper produce the same results as the sequential reference for small power-of-two lengths."},{"role":"assistant","content":"<think>\nThe fwtKernel uses get_global_id and step to compute pair/match indices and updates the array in place. The host sets up a buffer and iterates over steps, launching the kernel each time. The verify form quantifies logLength/length and symbolic arrays, then compares fwtScalarHost to the sequential fwt with an element-wise check. The solver should confirm equivalence for the bounded lengths.\n</think>\n\n```racket\n#lang s-exp \"../../../lang/main.rkt\"\n\n(kernel void (fwtKernel [float* tArray] [int step])\n  (: int tid group pair match)\n  (: float t1 t2)\n  (= tid (get_global_id 0))\n  (= group (% tid step))\n  (= pair  (+ (* (<< step 1) (/ tid step)) group)) \n  (= match (+ pair step))\n  (= t1 [tArray pair])\n  (= t2 [tArray match])\n  (= [tArray pair]  (+ t1 t2))\n  (= [tArray match] (- t1 t2)))\n\n(kernel void (fwtKernel4 [float4* tArray] [int step])\n  (: int tid group pair match)\n  (: float4 t1 t2)\n  (= tid (get_global_id 0))\n  (= step (/ step 4))\n  (= group (% tid step))\n  (= pair  (+ (* (<< step 1) (/ tid step)) group)) \n  (= match (+ pair step))\n  (= t1 [tArray pair])\n  (= t2 [tArray match])\n  (= [tArray pair]  (+ t1 t2))\n  (= [tArray match] (- t1 t2)))\n```\n\n```racket\n#lang s-exp \"../../../lang/main.rkt\"\n     \n; Compute the number of steps for the algorithm, \n; assuming that v is a power of 2.  See the log2 \n; algorithm from http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog\n(procedure int (steps [int v])\n  (: int r)\n  (= r 0)\n  ($= r (<< (!= 0 (& v #xAAAAAAAA)) 0))\n  ($= r (<< (!= 0 (& v #xCCCCCCCC)) 1))\n  ($= r (<< (!= 0 (& v #xF0F0F0F0)) 2))\n  ($= r (<< (!= 0 (& v #xFF00FF00)) 3))\n  ($= r (<< (!= 0 (& v #xFFFF0000)) 4))\n  r)\n\n; Reference implementation for Fast Walsh Transform.  This implementation\n; requires the length of the input array to be a power of 2, and it modifies\n; the input array in place.\n(procedure float* (fwt [float* tArray] [int length])\n  (for [(: int i in (range 0 (steps length)))]\n    (: int step)\n    (= step (<< 1 i))\n    (for [(: int group in (range 0 step))\n          (: int pair  in (range group length (<< step 1)))]\n      (: int match)\n      (: float t1 t2)\n      (= match (+ pair step))\n      (= t1 [tArray pair])\n      (= t2 [tArray match])\n      (= [tArray pair]  (+ t1 t2))\n      (= [tArray match] (- t1 t2))))\n  tArray)\n\n; Scalar host for Fast Walsh Transform.   This implementation\n; requires the length of the input array to be a power of 2.  The \n; input array is not modified; the output is a new array that holds\n; the result of the transform.\n(procedure float* (fwtScalarHost [float* input] [int length])\n  (: cl_context context)\n  (: cl_command_queue command_queue)\n  (: cl_program program)\n  (: cl_kernel kernel)\n  (: cl_mem tBuffer)\n  (: float* tArray)\n  (: int dim global)\n  \n  (= dim (* length (sizeof float)))\n  (= global (/ length 2))\n  \n  (= tArray ((float*) (malloc dim)))\n  \n  (= context (clCreateContext))\n  \n  (= command_queue (clCreateCommandQueue context))\n \n  (= tBuffer (clCreateBuffer context CL_MEM_READ_WRITE dim))\n  (= program (clCreateProgramWithSource context \"kernel.rkt\"))\n  \n  (clEnqueueWriteBuffer command_queue tBuffer 0 dim input)\n  \n  (= kernel (clCreateKernel program \"fwtKernel\"))\n  (clSetKernelArg kernel 0 tBuffer)\n  \n  (for [(: int i in (range 0 (steps length)))]\n    (: int step)\n    (= step (<< 1 i))\n    (clSetKernelArg kernel 1 step)\n    (clEnqueueNDRangeKernel command_queue kernel 1 NULL (@ global) NULL))\n  \n  (clEnqueueReadBuffer command_queue tBuffer 0 dim tArray)\n  tArray)\n\n; Given two arrays of the same size, checks that they hold the same \n; values at each index.\n(procedure void (check [int* actual] [int* expected] [int SIZE]) \n  (assert (>= SIZE 0)) \n  (for [(: int i in (range SIZE))] \n    (assert (== [actual i] [expected i]))))\n\n(procedure void (verify_scalar)   \n  (verify #:forall [(: int logLength in (range 0 7))\n                    (: int length in (range (<< 1 logLength) (+ 1 (<< 1 logLength))))\n                    (: float[length] tArray)]\n          #:ensure (check (fwtScalarHost tArray length)\n                          (fwt tArray length)\n                          length)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Check that the vectorized Fast Walsh Transform host logic is equivalent to the sequential reference across small power-of-two lengths."},{"role":"assistant","content":"<think>\nThe vector host uses runKernel to execute fwtKernel and fwtKernel4 depending on the number of stages. It computes steps(length), splits execution into scalar then vector stages, and reads the buffer back. The verify form quantifies lengths and symbolic float arrays, comparing fwtVectorHost to fwt with a check procedure. The solver should validate equivalence for bounded sizes.\n</think>\n\n```racket\n#lang s-exp \"../../../lang/main.rkt\"\n\n(kernel void (fwtKernel [float* tArray] [int step])\n  (: int tid group pair match)\n  (: float t1 t2)\n  (= tid (get_global_id 0))\n  (= group (% tid step))\n  (= pair  (+ (* (<< step 1) (/ tid step)) group)) \n  (= match (+ pair step))\n  (= t1 [tArray pair])\n  (= t2 [tArray match])\n  (= [tArray pair]  (+ t1 t2))\n  (= [tArray match] (- t1 t2)))\n\n(kernel void (fwtKernel4 [float4* tArray] [int step])\n  (: int tid group pair match)\n  (: float4 t1 t2)\n  (= tid (get_global_id 0))\n  (= step (/ step 4))\n  (= group (% tid step))\n  (= pair  (+ (* (<< step 1) (/ tid step)) group)) \n  (= match (+ pair step))\n  (= t1 [tArray pair])\n  (= t2 [tArray match])\n  (= [tArray pair]  (+ t1 t2))\n  (= [tArray match] (- t1 t2)))\n```\n\n```racket\n#lang s-exp \"../../../lang/main.rkt\"\n     \n; Compute the number of steps for the algorithm, \n; assuming that v is a power of 2.  See the log2 \n; algorithm from http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog\n(procedure int (steps [int v])\n  (: int r)\n  (= r 0)\n  ($= r (<< (!= 0 (& v #xAAAAAAAA)) 0))\n  ($= r (<< (!= 0 (& v #xCCCCCCCC)) 1))\n  ($= r (<< (!= 0 (& v #xF0F0F0F0)) 2))\n  ($= r (<< (!= 0 (& v #xFF00FF00)) 3))\n  ($= r (<< (!= 0 (& v #xFFFF0000)) 4))\n  r)\n\n; Reference implementation for Fast Walsh Transform.  This implementation\n; requires the length of the input array to be a power of 2, and it modifies\n; the input array in place.\n(procedure float* (fwt [float* tArray] [int length])\n  (for [(: int i in (range 0 (steps length)))]\n    (: int step)\n    (= step (<< 1 i))\n    (for [(: int group in (range 0 step))\n          (: int pair  in (range group length (<< step 1)))]\n      (: int match)\n      (: float t1 t2)\n      (= match (+ pair step))\n      (= t1 [tArray pair])\n      (= t2 [tArray match])\n      (= [tArray pair]  (+ t1 t2))\n      (= [tArray match] (- t1 t2))))\n  tArray)\n\n; Vectorized host for Fast Walsh Transform.   This implementation\n; requires the length of the input array to be a power of 2.  The \n; input array is not modified; the output is a new array that holds\n; the result of the transform.\n(procedure float* (fwtVectorHost [float* input] [int length])\n  (: cl_context context)\n  (: cl_command_queue command_queue)\n  (: cl_program program)\n  (: cl_mem tBuffer)\n  (: float* tArray)\n  (: int dim global n)\n  \n  (= dim (* length (sizeof float)))\n  (= global (/ length 2))\n  \n  (= tArray ((float*) (malloc dim)))\n  \n  (= context (clCreateContext))\n  \n  (= command_queue (clCreateCommandQueue context))\n \n  (= tBuffer (clCreateBuffer context CL_MEM_READ_WRITE dim))\n  (= program (clCreateProgramWithSource context \"kernel.rkt\"))\n  \n  (clEnqueueWriteBuffer command_queue tBuffer 0 dim input)\n  \n  (= n (steps length))\n  \n  (runKernel command_queue (clCreateKernel program \"fwtKernel\") tBuffer global 0 (?: (< n 2) n 2))\n  (if (> n 2) \n      { (/= global 4)\n        (runKernel command_queue (clCreateKernel program \"fwtKernel4\") tBuffer global 2 n) })\n\n  (clEnqueueReadBuffer command_queue tBuffer 0 dim tArray)\n  tArray)\n\n(procedure void (runKernel [cl_command_queue command_queue] [cl_kernel kernel] [cl_mem tBuffer] \n                           [int global] [int start] [int end])\n  (clSetKernelArg kernel 0 tBuffer)\n  (for [(: int i in (range start end))]\n    (: int step)\n    (= step (<< 1 i))\n    (clSetKernelArg kernel 1 step)\n    (clEnqueueNDRangeKernel command_queue kernel 1 NULL (@ global) NULL)))\n  \n; Given two arrays of the same size, checks that they hold the same \n; values at each index.\n(procedure void (check [int* actual] [int* expected] [int SIZE]) \n  (assert (>= SIZE 0)) \n  (for [(: int i in (range SIZE))] \n    (assert (== [actual i] [expected i]))))\n\n(procedure void (verify_vector) \n  (verify #:forall [(: int logLength in (range 0 7))\n                    (: int length in (range (<< 1 logLength) (+ 1 (<< 1 logLength))))\n                    (: float[length] tArray)]\n          #:ensure (check (fwtVectorHost tArray length)\n                          (fwt tArray length)\n                          length)))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Synthesize the missing offset constant in the vectorized Sobel filter kernel so the host implementation matches the sequential reference on small images."},{"role":"assistant","content":"<think>\nThe sketch kernel uses (?? int) for the offset used to access neighboring pixels in the int4 image. The host for the vector kernel runs an NDRange over width/height and is checked against the sequential sobelFilter reference. The synth form quantifies width/height and inputImage, uses a bitwidth, and ensures check passes, so the solver finds the correct offset constant.\n</think>\n\n```racket\n#lang s-exp \"../../lang/main.rkt\"\n\n; Scalar kernel for the Sobel filter.  See the loop body of the sobelFilter reference \n; implementation in host.rkt.\n(kernel void (sobelFilterScalarKernel [int* inputImage] [int* outputImage] [int w])\n  (: int x y i i00 i01 i02 i10 i11 i12 i20 i21 i22 gx gy)\n  (= x (get_global_id 0))\n  (= y (get_global_id 1))\n  (= i (+ (* y w) x))\n  (= i00 [inputImage (- i 4 w)])\n  (= i01 [inputImage (- i w)])\n  (= i02 [inputImage (- (+ i 4) w)])\n  (= i10 [inputImage (- i 4)])\n  (= i11 [inputImage i])\n  (= i12 [inputImage (+ i 4)])\n  (= i20 [inputImage (+ (- i 4) w)])\n  (= i21 [inputImage (+ i w)])\n  (= i22 [inputImage (+ i 4 w)])\n  (= gx (+ i00 (* 2 i01) i02 (* -1 i20) (* -2 i21) (* -1 i22)))\n  (= gy (+ i00 (* -1 i02) (* 2 i10) (* -2 i12) i20 (* -1 i22)))\n  (= [outputImage i] ((int) (/ (sqrt (+ (* ((float) gx) gx) (* ((float) gy) gy))) 2))))\n\n; Sketch of the vector kernel for the Sobel filter.  The sketch expresses the hypothesis \n; that the vectorized kernel will look pretty much the same as the scalar one, except for the offset from i.\n(kernel void (sobelFilterVectorKernelSketch [int4* inputImage] [int4* outputImage] [int w])\n  (: int x y i offset)\n  (: int4 i00 i01 i02 i10 i11 i12 i20 i21 i22)\n  (: float4 gx gy)\n  (= x (get_global_id 0))\n  (= y (get_global_id 1))\n  (= i (+ (* y w) x))\n  (= offset (?? int)) \n  (= i00 [inputImage (- i offset w)])\n  (= i01 [inputImage (- i w)])\n  (= i02 [inputImage (- (+ i offset) w)])\n  (= i10 [inputImage (- i offset)])\n  (= i11 [inputImage i])\n  (= i12 [inputImage (+ i offset)])\n  (= i20 [inputImage (+ (- i offset) w)])\n  (= i21 [inputImage (+ i w)])\n  (= i22 [inputImage (+ i offset w)])\n  (= gx (convert_float4 (+ i00 (* 2 i01) i02 (* -1 i20) (* -2 i21) (* -1 i22))))\n  (= gy (convert_float4 (+ i00 (* -1 i02) (* 2 i10) (* -2 i12) i20 (* -1 i22))))\n  (= [outputImage i] (convert_int4 (/ (sqrt (+ (* gx gx) (* gy gy))) ((float4) 2)))))\n\n; Vector kernel for the Sobel filter.  \n(kernel void (sobelFilterVectorKernel [int4* inputImage] [int4* outputImage] [int w])\n  (: int x y i off)\n  (: int4 i00 i01 i02 i10 i11 i12 i20 i21 i22)\n  (: float4 gx gy)\n  (= x (get_global_id 0))\n  (= y (get_global_id 1))\n  (= i (+ (* y w) x))\n  (= off 1)    \n  (= i00 [inputImage (- i off w)])\n  (= i01 [inputImage (- i w)])\n  (= i02 [inputImage (- (+ i off) w)])\n  (= i10 [inputImage (- i off)])\n  (= i11 [inputImage i])\n  (= i12 [inputImage (+ i off)])\n  (= i20 [inputImage (+ (- i off) w)])\n  (= i21 [inputImage (+ i w)])\n  (= i22 [inputImage (+ i off w)])\n  (= gx (convert_float4 (+ i00 (* 2 i01) i02 (* -1 i20) (* -2 i21) (* -1 i22))))\n  (= gy (convert_float4 (+ i00 (* -1 i02) (* 2 i10) (* -2 i12) i20 (* -1 i22))))\n  (= [outputImage i] (convert_int4 (/ (sqrt (+ (* gx gx) (* gy gy))) ((float4) 2)))))\n```\n\n```racket\n#lang s-exp \"../../lang/main.rkt\"\n \n; We are using the sobelFilter5 function from reference.rkt as a reference\n; sequential implementation for the Sobel filter.  This reference implementation \n; was derived via a multi-step refinment process from the implementation provided \n; by Samsung, using a combination of verification and synthesis.\n;\n; We represent images as arrays of ints, since chars are not supported. The reference \n; implementation applies the Sobel filter to a width x height x pixelSize image,\n; represented as a flat array of ints.  The implementation works for pixelSize = 4 * (sizeof int).\n(procedure int* (sobelFilter [int* inputImage] [int width] [int height] [int pixelSize])\n                 \n  (: int* outputImage)\n  (= outputImage ((int*) (malloc (* width height pixelSize))))\n  (memset outputImage 0 (* width height pixelSize))\n  \n  (: int gx gy w i i00 i01 i02 i10 i11 i12 i20 i21 i22)\n  (= w (* width 4))\n  \n  (for [(: int y in (range 1 (- height 1)))  ; [Y]\n        (: int x in (range 4 (- w 4)))]      ; [X]\n    (= i (+ (* y w) x))\n    (= i00 [inputImage (- i 4 w)])\n    (= i01 [inputImage (- i w)])\n    (= i02 [inputImage (- (+ i 4) w)])\n    (= i10 [inputImage (- i 4)])\n    (= i11 [inputImage i])\n    (= i12 [inputImage (+ i 4)])\n    (= i20 [inputImage (+ (- i 4) w)])\n    (= i21 [inputImage (+ i w)])\n    (= i22 [inputImage (+ i 4 w)])\n    (= gx (+ i00 (* 2 i01) i02 (* -1 i20) (* -2 i21) (* -1 i22)))\n    (= gy (+ i00 (* -1 i02) (* 2 i10) (* -2 i12) i20 (* -1 i22)))\n    (= [outputImage i] ((int) (/ (sqrt (+ (* ((float) gx) gx) (* ((float) gy) gy))) 2))))\n  \n  outputImage)\n\n; A host implementation for a vectorized Sobel filter.  This is a straightforward adaption of the \n; scalar parallelized implementation, in which we change the type of the array from int to int4, \n; and we adjust the iteration space accordingly (by dividing the x dimensions by 4).  We assume \n; that width and height are both at least 3.\n(procedure int* (sobelFilterVectorHost [char* name] [int* inputImage] [int width] [int height] [int pixelSize])\n  (: cl_context context)\n  (: cl_command_queue command_queue)\n  (: cl_program program)\n  (: cl_kernel kernel)\n  (: cl_mem inputImageBuffer outputImageBuffer)\n  (: int* outputImage)\n  (: int size)\n  (: int[2] global offset)\n  \n  (= [global 0] (- width 2))  ; see line [X] of sobelFilter:  we divide x size and offset by 4 due to the use of int4 datatype\n  (= [offset 0] 1)\n  (= [global 1] (- height 2)) ; see line [Y] of sobelFilter\n  (= [offset 1] 1)\n  \n  (= size (* width height pixelSize))\n  (= outputImage ((int*) (malloc size)))\n  (memset outputImage 0 size)\n  \n  (= context (clCreateContext))\n  \n  (= command_queue (clCreateCommandQueue context))\n \n  (= inputImageBuffer (clCreateBuffer context CL_MEM_READ_ONLY size))\n  (= outputImageBuffer (clCreateBuffer context CL_MEM_WRITE_ONLY size))\n  \n  (= program (clCreateProgramWithSource context \"kernel.rkt\"))\n  \n  (clEnqueueWriteBuffer command_queue inputImageBuffer 0 size inputImage)\n  (clEnqueueWriteBuffer command_queue outputImageBuffer 0 size outputImage)\n  \n  (= kernel (clCreateKernel program name))\n  (clSetKernelArg kernel 0 inputImageBuffer)\n  (clSetKernelArg kernel 1 outputImageBuffer)\n  (clSetKernelArg kernel 2 width)\n\n  (clEnqueueNDRangeKernel command_queue kernel 2 offset global NULL)\n  (clEnqueueReadBuffer command_queue outputImageBuffer 0 size outputImage)\n  outputImage)\n\n; Given two arrays of the same size, checks that they hold the same \n; values at each index.\n(procedure void (check [int* actual] [int* expected] [int SIZE])\n  (assert (>= SIZE 0))\n  (for [(: int i in (range SIZE))]\n    (assert (== [actual i] [expected i]))))\n\n(: int pixelSize)\n(= pixelSize (* 4 (sizeof int)))\n\n; Synthesizes the missing constants in sobelFilterVectorKernel so that \n; sobelFilterVectorHost and sobelFilter are equivalent on all \n; images with dimensions 4x4 (~16 sec).  The solution is correct for all \n; sizes, which can be verified using the verify form.\n(procedure void (synth_vectorized)\n  (synth #:forall [(: int width in (range 4 5))\n                   (: int height in (range 4 5))\n                   (: int[(* width height pixelSize)] inputImage)]\n         #:bitwidth 9\n         #:ensure (check (sobelFilterVectorHost \"sobelFilterVectorKernelSketch\" inputImage width height pixelSize)\n                         (sobelFilter inputImage width height pixelSize)\n                         (* width height pixelSize))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Verify the scalar Sobel filter kernel and host wrapper against the sequential reference for small image sizes."},{"role":"assistant","content":"<think>\nThe scalar kernel mirrors the inner loop of sobelFilter, using get_global_id and an offset work range. The host sets offsets and globals that align with the sequential bounds. The verify form quantifies width, height, and inputImage and checks equality element-wise. The solver should validate equivalence for the bounded sizes.\n</think>\n\n```racket\n#lang s-exp \"../../lang/main.rkt\"\n\n; Scalar kernel for the Sobel filter.  See the loop body of the sobelFilter reference \n; implementation in host.rkt.\n(kernel void (sobelFilterScalarKernel [int* inputImage] [int* outputImage] [int w])\n  (: int x y i i00 i01 i02 i10 i11 i12 i20 i21 i22 gx gy)\n  (= x (get_global_id 0))\n  (= y (get_global_id 1))\n  (= i (+ (* y w) x))\n  (= i00 [inputImage (- i 4 w)])\n  (= i01 [inputImage (- i w)])\n  (= i02 [inputImage (- (+ i 4) w)])\n  (= i10 [inputImage (- i 4)])\n  (= i11 [inputImage i])\n  (= i12 [inputImage (+ i 4)])\n  (= i20 [inputImage (+ (- i 4) w)])\n  (= i21 [inputImage (+ i w)])\n  (= i22 [inputImage (+ i 4 w)])\n  (= gx (+ i00 (* 2 i01) i02 (* -1 i20) (* -2 i21) (* -1 i22)))\n  (= gy (+ i00 (* -1 i02) (* 2 i10) (* -2 i12) i20 (* -1 i22)))\n  (= [outputImage i] ((int) (/ (sqrt (+ (* ((float) gx) gx) (* ((float) gy) gy))) 2))))\n```\n\n```racket\n#lang s-exp \"../../lang/main.rkt\"\n \n; We are using the sobelFilter5 function from reference.rkt as a reference\n; sequential implementation for the Sobel filter.  This reference implementation \n; was derived via a multi-step refinment process from the implementation provided \n; by Samsung, using a combination of verification and synthesis.\n;\n; We represent images as arrays of ints, since chars are not supported. The reference \n; implementation applies the Sobel filter to a width x height x pixelSize image,\n; represented as a flat array of ints.  The implementation works for pixelSize = 4 * (sizeof int).\n(procedure int* (sobelFilter [int* inputImage] [int width] [int height] [int pixelSize])\n                 \n  (: int* outputImage)\n  (= outputImage ((int*) (malloc (* width height pixelSize))))\n  (memset outputImage 0 (* width height pixelSize))\n  \n  (: int gx gy w i i00 i01 i02 i10 i11 i12 i20 i21 i22)\n  (= w (* width 4))\n  \n  (for [(: int y in (range 1 (- height 1)))  ; [Y]\n        (: int x in (range 4 (- w 4)))]      ; [X]\n    (= i (+ (* y w) x))\n    (= i00 [inputImage (- i 4 w)])\n    (= i01 [inputImage (- i w)])\n    (= i02 [inputImage (- (+ i 4) w)])\n    (= i10 [inputImage (- i 4)])\n    (= i11 [inputImage i])\n    (= i12 [inputImage (+ i 4)])\n    (= i20 [inputImage (+ (- i 4) w)])\n    (= i21 [inputImage (+ i w)])\n    (= i22 [inputImage (+ i 4 w)])\n    (= gx (+ i00 (* 2 i01) i02 (* -1 i20) (* -2 i21) (* -1 i22)))\n    (= gy (+ i00 (* -1 i02) (* 2 i10) (* -2 i12) i20 (* -1 i22)))\n    (= [outputImage i] ((int) (/ (sqrt (+ (* ((float) gx) gx) (* ((float) gy) gy))) 2))))\n  \n  outputImage)\n\n; A host implementation for a scalar Sobel filter.  This is a straightforward adaption of the \n; reference implementation, in which the loop body is placed into a kernel and the loop bounds \n; are expressed with a suitable global offset and work size.  We assume that width and height are \n; both at least 3.\n(procedure int* (sobelFilterScalarHost [int* inputImage] [int width] [int height] [int pixelSize])\n  (: cl_context context)\n  (: cl_command_queue command_queue)\n  (: cl_program program)\n  (: cl_kernel kernel)\n  (: cl_mem inputImageBuffer outputImageBuffer)\n  (: int* outputImage)\n  (: int size w)\n  (: int[2] global offset)\n  \n  (= w (* width 4))\n  (= [global 0] (- w 8))      ; see line [X] of sobelFilter\n  (= [offset 0] 4)\n  (= [global 1] (- height 2)) ; see line [Y] of sobelFilter\n  (= [offset 1] 1)\n  \n  (= size (* width height pixelSize))\n  (= outputImage ((int*) (malloc size)))\n  (memset outputImage 0 size)\n  \n  (= context (clCreateContext))\n  \n  (= command_queue (clCreateCommandQueue context))\n \n  (= inputImageBuffer (clCreateBuffer context CL_MEM_READ_ONLY size))\n  (= outputImageBuffer (clCreateBuffer context CL_MEM_WRITE_ONLY size))\n  \n  (= program (clCreateProgramWithSource context \"kernel.rkt\"))\n  \n  (clEnqueueWriteBuffer command_queue inputImageBuffer 0 size inputImage)\n  (clEnqueueWriteBuffer command_queue outputImageBuffer 0 size outputImage)\n  \n  (= kernel (clCreateKernel program \"sobelFilterScalarKernel\"))\n  (clSetKernelArg kernel 0 inputImageBuffer)\n  (clSetKernelArg kernel 1 outputImageBuffer)\n  (clSetKernelArg kernel 2 w)\n\n  (clEnqueueNDRangeKernel command_queue kernel 2 offset global NULL)\n  (clEnqueueReadBuffer command_queue outputImageBuffer 0 size outputImage)\n  outputImage)\n\n; Given two arrays of the same size, checks that they hold the same \n; values at each index.\n(procedure void (check [int* actual] [int* expected] [int SIZE])\n  (assert (>= SIZE 0))\n  (for [(: int i in (range SIZE))]\n    (assert (== [actual i] [expected i]))))\n\n(: int pixelSize)\n(= pixelSize (* 4 (sizeof int)))\n\n; Verifies that sobelFilterScalarHost and sobelFilter are equivalent on all \n; images with dimensions ranging from 3..10 x 3..10 (~26 sec).\n(procedure void (verify_scalar)\n  (verify #:forall [(: int width in (range 3 10))\n                    (: int height in (range 3 10))\n                    (: int[(* width height pixelSize)] inputImage)]\n          #:ensure (check (sobelFilterScalarHost inputImage width height pixelSize)\n                          (sobelFilter inputImage width height pixelSize)\n                          (* width height pixelSize))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Verify a scalar matrix multiplication kernel and host wrapper against a sequential reference for small matrix dimensions."},{"role":"assistant","content":"<think>\nThe scalar kernel computes one C[i,j] using nested k accumulation and stores into C. The host sets up buffers and launches a 2D NDRange over n and m. The verify form quantifies n, p, m, and symbolic A/B arrays, then checks mmulScalar against mmulSequential for correctness. The solver should confirm equality for bounded dimensions.\n</think>\n\n```racket\n#lang s-exp \"../../../lang/main.rkt\"\n\n; Matrix multiplication C = A * B, where A is an n x p matrix and B is a p x m matrix.\n(kernel void (mmulScalarKernel [int* A] [int* B] [int* C] [int p] [int m])\n  (: int i j sum)\n  (= i (get_global_id 0))\n  (= j (get_global_id 1))\n  (= sum 0)\n  (for [(: int k in (range p))]\n    (+= sum (* [A (+ (* i p) k)] [B (+ (* k m) j)])))\n  (= [C (+ (* i m) j)] sum))\n```\n\n```racket\n#lang s-exp \"../../../lang/main.rkt\"\n\n; The reference implementation for square matrix multiplication.  \n; Multiplies two squre matrices A and B, where the dimension of A is \n; n x p and dimension of B is p x m.  Both matrices are given as \n; flat arrays in row-major form.  The output is the matrix C = A*B, \n; also given in row-major form. \n(procedure int* (mmulSequential [int* A] [int* B] [int n] [int p] [int m])\n  (: int* C)\n  (= C ((int*) (malloc (* n m (sizeof int)))))\n  (for [(: int i in (range n))\n        (: int j in (range m))\n        (: int k in (range p))]\n        (+= [C (+ (* i m) j)] (* [A (+ (* i p) k)] [B (+ (* k m) j)])))\n  C)\n\n; A host implementation of matrix multiplication.\n(procedure int* (mmulHost [char* kernelName] [int typeLen] \n                          [int* A] [int* B] [int n] [int p] [int m])\n  (: cl_context context)\n  (: cl_command_queue command_queue)\n  (: cl_program program)\n  (: cl_kernel kernel)\n  (: cl_mem buffer_A buffer_B buffer_C)\n  (: int* C)\n  (: int[2] global)\n  (: int dimA dimB dimC)\n  \n  (= [global 0] (/ n typeLen))\n  (= [global 1] (/ m typeLen))\n  (= dimA (* n p (sizeof int))) \n  (= dimB (* p m (sizeof int))) \n  (= dimC (* n m (sizeof int)))\n  \n  (= C ((int*) (malloc dimC)))\n  \n  (= context (clCreateContext))\n  \n  (= command_queue (clCreateCommandQueue context))\n \n  (= buffer_A (clCreateBuffer context CL_MEM_READ_ONLY dimA))\n  (= buffer_B (clCreateBuffer context CL_MEM_READ_ONLY dimB))\n  (= buffer_C (clCreateBuffer context CL_MEM_WRITE_ONLY dimC))\n  \n  (= program (clCreateProgramWithSource context \"kernel.rkt\"))\n  \n  (clEnqueueWriteBuffer command_queue buffer_A 0 dimA A)\n  (clEnqueueWriteBuffer command_queue buffer_B 0 dimB B)\n  \n  (= kernel (clCreateKernel program kernelName))\n  (clSetKernelArg kernel 0 buffer_A)\n  (clSetKernelArg kernel 1 buffer_B)\n  (clSetKernelArg kernel 2 buffer_C)\n  (clSetKernelArg kernel 3 p)\n  (clSetKernelArg kernel 4 m)\n\n  (clEnqueueNDRangeKernel command_queue kernel 2 NULL global NULL)\n  (clEnqueueReadBuffer command_queue buffer_C 0 dimC C)\n  C)\n; A scalar parallel implementation of matrix multiplication.\n(procedure int* (mmulScalar [int* A] [int* B] [int n] [int p] [int m])\n  (mmulHost \"mmulScalarKernel\" 1 A B n p m))\n\n; Given two arrays of the same size, checks that they hold the same \n; values at each index.\n(procedure void (check [int* actual] [int* expected] [int SIZE])\n  (assert (>= SIZE 0))\n  (for [(: int i in (range SIZE))]\n    (assert (== [actual i] [expected i]))))\n\n(procedure void (verify_scalar [int from] [int to])\n  (verify #:forall [(: int n in (range from to))\n                    (: int p in (range from to))\n                    (: int m in (range from to))\n                    (: int[(* n p)] A) \n                    (: int[(* p m)] B)] \n          #:ensure (check (mmulScalar A B n p m) \n                          (mmulSequential A B n p m)\n                          (* n m))))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette DSLs and solver-aided verification/synthesis."},{"role":"user","content":"Verify the vectorized Sobel filter host against the sequential reference using the concrete vector kernel."},{"role":"assistant","content":"<think>\nThe vector kernel uses int4 and a fixed off=1 to load neighbor pixels, and the vector host adjusts the iteration space by dividing x by 4. The verify_vectorized procedure quantifies width/height and checks sobelFilterVectorHost against sobelFilter. The solver should prove equivalence for the bounded ranges.\n</think>\n\n```racket\n#lang s-exp \"../../lang/main.rkt\"\n\n; Vector kernel for the Sobel filter.  \n(kernel void (sobelFilterVectorKernel [int4* inputImage] [int4* outputImage] [int w])\n  (: int x y i off)\n  (: int4 i00 i01 i02 i10 i11 i12 i20 i21 i22)\n  (: float4 gx gy)\n  (= x (get_global_id 0))\n  (= y (get_global_id 1))\n  (= i (+ (* y w) x))\n  (= off 1)    \n  (= i00 [inputImage (- i off w)])\n  (= i01 [inputImage (- i w)])\n  (= i02 [inputImage (- (+ i off) w)])\n  (= i10 [inputImage (- i off)])\n  (= i11 [inputImage i])\n  (= i12 [inputImage (+ i off)])\n  (= i20 [inputImage (+ (- i off) w)])\n  (= i21 [inputImage (+ i w)])\n  (= i22 [inputImage (+ i off w)])\n  (= gx (convert_float4 (+ i00 (* 2 i01) i02 (* -1 i20) (* -2 i21) (* -1 i22))))\n  (= gy (convert_float4 (+ i00 (* -1 i02) (* 2 i10) (* -2 i12) i20 (* -1 i22))))\n  (= [outputImage i] (convert_int4 (/ (sqrt (+ (* gx gx) (* gy gy))) ((float4) 2)))))\n```\n\n```racket\n#lang s-exp \"../../lang/main.rkt\"\n \n; We are using the sobelFilter5 function from reference.rkt as a reference\n; sequential implementation for the Sobel filter.  This reference implementation \n; was derived via a multi-step refinment process from the implementation provided \n; by Samsung, using a combination of verification and synthesis.\n;\n; We represent images as arrays of ints, since chars are not supported. The reference \n; implementation applies the Sobel filter to a width x height x pixelSize image,\n; represented as a flat array of ints.  The implementation works for pixelSize = 4 * (sizeof int).\n(procedure int* (sobelFilter [int* inputImage] [int width] [int height] [int pixelSize])\n                 \n  (: int* outputImage)\n  (= outputImage ((int*) (malloc (* width height pixelSize))))\n  (memset outputImage 0 (* width height pixelSize))\n  \n  (: int gx gy w i i00 i01 i02 i10 i11 i12 i20 i21 i22)\n  (= w (* width 4))\n  \n  (for [(: int y in (range 1 (- height 1)))  ; [Y]\n        (: int x in (range 4 (- w 4)))]      ; [X]\n    (= i (+ (* y w) x))\n    (= i00 [inputImage (- i 4 w)])\n    (= i01 [inputImage (- i w)])\n    (= i02 [inputImage (- (+ i 4) w)])\n    (= i10 [inputImage (- i 4)])\n    (= i11 [inputImage i])\n    (= i12 [inputImage (+ i 4)])\n    (= i20 [inputImage (+ (- i 4) w)])\n    (= i21 [inputImage (+ i w)])\n    (= i22 [inputImage (+ i 4 w)])\n    (= gx (+ i00 (* 2 i01) i02 (* -1 i20) (* -2 i21) (* -1 i22)))\n    (= gy (+ i00 (* -1 i02) (* 2 i10) (* -2 i12) i20 (* -1 i22)))\n    (= [outputImage i] ((int) (/ (sqrt (+ (* ((float) gx) gx) (* ((float) gy) gy))) 2))))\n  \n  outputImage)\n\n; A host implementation for a vectorized Sobel filter.  This is a straightforward adaption of the \n; scalar parallelized implementation, in which we change the type of the array from int to int4, \n; and we adjust the iteration space accordingly (by dividing the x dimensions by 4).  We assume \n; that width and height are both at least 3.\n(procedure int* (sobelFilterVectorHost [char* name] [int* inputImage] [int width] [int height] [int pixelSize])\n  (: cl_context context)\n  (: cl_command_queue command_queue)\n  (: cl_program program)\n  (: cl_kernel kernel)\n  (: cl_mem inputImageBuffer outputImageBuffer)\n  (: int* outputImage)\n  (: int size)\n  (: int[2] global offset)\n  \n  (= [global 0] (- width 2))  ; see line [X] of sobelFilter:  we divide x size and offset by 4 due to the use of int4 datatype\n  (= [offset 0] 1)\n  (= [global 1] (- height 2)) ; see line [Y] of sobelFilter\n  (= [offset 1] 1)\n  \n  (= size (* width height pixelSize))\n  (= outputImage ((int*) (malloc size)))\n  (memset outputImage 0 size)\n  \n  (= context (clCreateContext))\n  \n  (= command_queue (clCreateCommandQueue context))\n \n  (= inputImageBuffer (clCreateBuffer context CL_MEM_READ_ONLY size))\n  (= outputImageBuffer (clCreateBuffer context CL_MEM_WRITE_ONLY size))\n  \n  (= program (clCreateProgramWithSource context \"kernel.rkt\"))\n  \n  (clEnqueueWriteBuffer command_queue inputImageBuffer 0 size inputImage)\n  (clEnqueueWriteBuffer command_queue outputImageBuffer 0 size outputImage)\n  \n  (= kernel (clCreateKernel program name))\n  (clSetKernelArg kernel 0 inputImageBuffer)\n  (clSetKernelArg kernel 1 outputImageBuffer)\n  (clSetKernelArg kernel 2 width)\n\n  (clEnqueueNDRangeKernel command_queue kernel 2 offset global NULL)\n  (clEnqueueReadBuffer command_queue outputImageBuffer 0 size outputImage)\n  outputImage)\n\n; Given two arrays of the same size, checks that they hold the same \n; values at each index.\n(procedure void (check [int* actual] [int* expected] [int SIZE])\n  (assert (>= SIZE 0))\n  (for [(: int i in (range SIZE))]\n    (assert (== [actual i] [expected i]))))\n\n(: int pixelSize)\n(= pixelSize (* 4 (sizeof int)))\n\n; Verifies that sobelFilterVectorHost and sobelFilter are equivalent on all \n; images with dimensions ranging from 3..10 x 3..10 (~26 sec).\n(procedure void (verify_vectorized)\n  (verify #:forall [(: int width in (range 3 10))\n                    (: int height in (range 3 10))\n                    (: int[(* width height pixelSize)] inputImage)]\n          #:ensure (check (sobelFilterVectorHost \"sobelFilterVectorKernel\" inputImage width height pixelSize)\n                          (sobelFilter inputImage width height pixelSize)\n                          (* width height pixelSize))))\n```"}]}
