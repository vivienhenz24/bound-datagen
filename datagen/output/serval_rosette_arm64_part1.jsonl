{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Audit the ADD/SUB (immediate) semantics in Serval's ARM64 Rosette interpreter, including helpers, so I can port them to a new proof."},{"role":"assistant","content":"<think>\nInstruction form ADD/SUB (immediate) decoded by pattern `sf|op|S|100010|sh|imm12|Rn|Rd`.\nSymbolic CPU state covers SP-aliasing of X31, the boxed GPR vector, and nzcv flags, so register updates and flag writes stay symbolic.\nConstraints come from `decode`, `add-with-carry`, and the zero-extension of immediates; solver reasoning relies on Rosette bitvectors and overflow predicates without extra queries.\n</think>\n\n```racket\n(struct nzcv (n z c v) #:transparent)\n```\n\n```racket\n(define (add-with-carry x y carry_in)\n  (define N (core:bv-size x))\n  (define carry? (bitvector->bool carry_in))\n  (define result (bvadd x y (if carry? (bv #b1 N) (bv #b0 N))))\n  (define n (bit (sub1 N) result))\n  (define z (if (is-zero result) (bv #b1 1) (bv #b0 1)))\n  (define c (if (core:bvuadd-overflow? x y carry?) (bv #b1 1) (bv #b0 1)))\n  (define v (if (core:bvsadd-overflow? x y carry?) (bv #b1 1) (bv #b0 1)))\n  (values result (nzcv n z c v)))\n\n(define (is-zero x)\n  (bvzero? x))\n```\n\n```racket\n(define (decode sf sh imm12 Rn Rd)\n  (define d Rd)\n  (define n Rn)\n  (define datasize (if (bveq sf (bv #b1 1)) 64 32))\n\n  (define imm\n    (cond\n      [(bveq sh (bv #b0 1))\n       (zero-extend imm12 (bitvector datasize))]\n      [(bveq sh (bv #b1 1))\n       (zero-extend (concat imm12 (zeros 12)) (bitvector datasize))]))\n\n  (values d n datasize imm))\n\n\n(define (interpret-adds-immediate cpu sf sh imm12 Rn Rd)\n  (define-values (d n datasize imm) (decode sf sh imm12 Rn Rd))\n  (define operand1 (trunc datasize (if (equal? n (integer->gpr 31)) (cpu-sp-ref cpu) (cpu-gpr-ref cpu n))))\n\n  (define-values (result nzcv)\n    (add-with-carry operand1 imm (bv #b0 1)))\n\n  (cpu-nzcv-set! cpu nzcv)\n\n  (cpu-gpr-set! cpu d result))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Derive the ADD/SUB (shifted register) Rosette semantics, including the shared shift helpers, so I can double-check data-processing register proofs."},{"role":"assistant","content":"<think>\nInstruction form ADD/SUB (shifted register) uses `sf|op|S|01011|shift|0|Rm|imm6|Rn|Rd`, banning shift=`11` and 32-bit shifts beyond the architectural width.\nSymbolic state flows through `cpu-gpr-ref`/`cpu-gpr-set!`, with `shift-reg` producing the rotated operand and NZCV updates coming from `add-with-carry` when S=1.\nConstraints stem from the guard checks plus `undefined` traps, so the solver only sees the well-formed bitvector cases in Rosette.\n</think>\n\n```racket\n(define (undefined)\n  (core:bug #:msg \"UNDEFINED\"))\n```\n\n```racket\n(define (add-with-carry x y carry_in)\n  (define N (core:bv-size x))\n  (define carry? (bitvector->bool carry_in))\n  (define result (bvadd x y (if carry? (bv #b1 N) (bv #b0 N))))\n  (define n (bit (sub1 N) result))\n  (define z (if (is-zero result) (bv #b1 1) (bv #b0 1)))\n  (define c (if (core:bvuadd-overflow? x y carry?) (bv #b1 1) (bv #b0 1)))\n  (define v (if (core:bvsadd-overflow? x y carry?) (bv #b1 1) (bv #b0 1)))\n  (values result (nzcv n z c v)))\n\n(define (is-zero x)\n  (bvzero? x))\n```\n\n```racket\n(define (decode-shift op)\n  (cond\n    [(bveq op (bv #b00 2)) 'LSL]\n    [(bveq op (bv #b01 2)) 'LSR]\n    [(bveq op (bv #b10 2)) 'ASR]\n    [(bveq op (bv #b11 2)) 'ROR]))\n\n(define (shift-reg cpu reg type amount)\n  (define datasize (core:bv-size amount))\n  (define result (trunc datasize (cpu-gpr-ref cpu reg)))\n  (case type\n    [(LSL) (bvshl result amount)]\n    [(LSR) (bvlshr result amount)]\n    [(ASR) (bvashr result amount)]\n    [(ROR) (bvror result amount)]))\n```\n\n```racket\n(define (decode sf shift Rm imm6 Rn Rd)\n  (define d Rd)\n  (define n Rn)\n  (define m Rm)\n  (define datasize (if (bveq sf (bv #b1 1)) 64 32))\n\n  (when (bveq shift (bv #b11 2))\n    (undefined))\n  (when (&& (bveq sf (bv #b0 1)) (bveq (bit 5 imm6) (bv #b1 1)))\n    (undefined))\n\n  (define shift_type (decode-shift shift))\n  (define shift_amount (zero-extend imm6 (bitvector datasize)))\n\n  (values d n m datasize shift_type shift_amount))\n\n\n(define (interpret-adds-shifted-register cpu sf shift Rm imm6 Rn Rd)\n  (define-values (d n m datasize shift_type shift_amount) (decode sf shift Rm imm6 Rn Rd))\n  (define operand1 (trunc datasize (cpu-gpr-ref cpu n)))\n  (define operand2 (shift-reg cpu m shift_type shift_amount))\n\n  (define-values (result nzcv)\n    (add-with-carry operand1 operand2 (bv #b0 1)))\n\n  (cpu-nzcv-set! cpu nzcv)\n\n  (cpu-gpr-set! cpu d result))\n```"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Show me the logical immediate interpreter (AND/ORR/EOR/ANDS) in Rosette along with the bitmask helper so I can reason about constant synthesis proofs."},{"role":"assistant","content":"<think>\nLogical immediate instructions match `sf|opc|100100|N|immr|imms|Rn|Rd`, so `decode` checks `sf`/`N` consistency and builds the rotated mask via `decode-bit-masks`.\nSymbolic state is the general-purpose register file plus NZCV flags for the ANDS form, with `is-zero-bit` extracting the Z flag and the bitvector width chosen by `sf`.\nConstraints arise from the mask construction (`undefined` guards illegal patterns), meaning solver queries stay within finite Rosette bitvectors when validating constant forms.\n</think>\n\n```racket\n(define (highest-set-bit x)\n  (define lst (reverse (range (core:bv-size x))))\n  ; if bit i is set, return i (otherwise #f)\n  (define (pred i) (if (bveq (bit i x) (bv #b1 1)) i #f))\n  ; find the highest bit set (#f if x is zero)\n  (define pos (ormap pred lst))\n  ; return -1 if no bit is set\n  (if pos pos -1))\n\n(define (ones n)\n  ; Use bv for now, but can switch to for/all if a symbolic n is needed.\n  ; Don't use integer->bitvector here.\n  (bv -1 n))\n\n(define (replicate x n)\n  (apply concat (build-list n (lambda (i) x))))\n\n(define (undefined)\n  (core:bug #:msg "UNDEFINED"))\n\n(define (zeros n)\n  ; Use bv for now, but can switch to for/all if a symbolic n is needed.\n  ; Don't use integer->bitvector here.\n  (bv 0 n))\n\n(define (is-zero x)\n  (bvzero? x))\n\n(define (is-zero-bit x)\n  (if (is-zero x) (bv #b1 1) (bv #b0 1)))\n\n(define (decode-bit-masks M immN imms immr immediate)\n  ; Compute log2 of element size.\n  ; 2^len must be in range [2, M]\n  (define len (highest-set-bit (concat immN (bvnot imms))))\n\n  ; Since len is integer, split over all possible concrete values (up to 6).\n  (define lst (for/all ([len len #:exhaustive])\n    (assert (integer? len))\n    (when (< len 1)\n      (undefined))\n    (assert (>= M (arithmetic-shift 1 len)))\n\n    ; Determine S, R and S - R parameters.\n    (define levels (zero-extend (ones len) (bitvector 6)))\n\n    ; For logical immediates an all-ones value of S is reserved\n    ; since it would generate a useless all-ones result (many times).\n    (when (&& immediate (bveq (bvand imms levels) levels))\n      (undefined))\n\n    ; S = UInt(imms AND levels);\n    ; R = UInt(immr AND levels);\n    ; diff = S - R;\n    ;\n    ; To avoid integers, represent S and R using (bitvector len).\n    ; Use extract here instead of masking levels.\n    (define S (trunc len imms))\n    (define R (trunc len immr))\n    (define diff (bvsub S R))\n\n    ; esize = 2^len\n    (define esize (arithmetic-shift 1 len))\n    ; No need for truncation as diff is already of (bitvector len).\n    (define d diff)\n\n    ; welem = ZeroExtend(Ones(S + 1), esize);\n    ; telem = ZeroExtend(Ones(d + 1), esize);\n    ;\n    ; To avoid integers, start from all-one values and right-shift instead:\n    ; welem: ones(esize) >> (esize - 1 - S)\n    ; telem: ones(esize) >> (esize - 1 - d)\n    ;\n    ; Note that both S and d are of (bitvector len), they need to be zero-extended.\n    (define welem (bvlshr (ones esize) (bvsub (bv (sub1 esize) esize) (zero-extend S (bitvector esize)))))\n    (define telem (bvlshr (ones esize) (bvsub (bv (sub1 esize) esize) (zero-extend d (bitvector esize)))))\n\n    (define wmask (replicate (bvror welem (zero-extend R (bitvector esize))) (quotient M esize)))\n    (define tmask (replicate telem (quotient M esize)))\n    (list wmask tmask)))\n\n  ; As values is not lifted by Rosette, use list inside for/all and\n  ; values after merging.\n  (apply values lst))\n```\n\n```racket\n(define (decode sf N immr imms Rn Rd)\n  (define d Rd)\n  (define n Rn)\n  (define datasize (if (bveq sf (bv #b1 1)) 64 32))\n\n  (when (&& (bveq sf (bv #b0 1)) (! (bveq N (bv #b0 1))))\n    (undefined))\n\n  (define-values (imm _) (decode-bit-masks datasize N imms immr #t))\n\n  (values d n datasize imm))\n\n\n(define (interpret-ands-immediate cpu sf N immr imms Rn Rd)\n  (define-values (d n datasize imm) (decode sf N immr imms Rn Rd))\n  (define operand1 (trunc datasize (cpu-gpr-ref cpu n)))\n\n  (define result (bvand operand1 imm))\n  (cpu-nzcv-set! cpu (nzcv (bit (sub1 datasize) result) (is-zero-bit result) (bv #b0 1) (bv #b0 1)))\n\n  (cpu-gpr-set! cpu d result))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Document the logical shifted-register Rosette interpreter (focus on BICS) so I can reason about flag-setting bitwise ops."},{"role":"assistant","content":"<think>\nThe logical shifted-register group decodes `sf|opc|01010|shift|N|Rm|imm6|Rn|Rd`, with `decode` restricting 32-bit shifts via bit5 and sharing `decode-shift`/`shift-reg` for operand2.\nSymbolic state includes the nzcv struct to capture BICS flag writes plus general-purpose regs; `is-zero-bit` forms Z while other flags are cleared.\nBy constraining shift amounts and staying in Rosette bitvectors, solver obligations boil down to bvand/bvnot algebra on truncated operands.\n</think>\n\n```racket\n(struct nzcv (n z c v) #:transparent)\n\n(define (is-zero x)\n  (bvzero? x))\n\n(define (is-zero-bit x)\n  (if (is-zero x) (bv #b1 1) (bv #b0 1)))\n\n(define (decode-shift op)\n  (cond\n    [(bveq op (bv #b00 2)) 'LSL]\n    [(bveq op (bv #b01 2)) 'LSR]\n    [(bveq op (bv #b10 2)) 'ASR]\n    [(bveq op (bv #b11 2)) 'ROR]))\n\n(define (shift-reg cpu reg type amount)\n  (define datasize (core:bv-size amount))\n  (define result (trunc datasize (cpu-gpr-ref cpu reg)))\n  (case type\n    [(LSL) (bvshl result amount)]\n    [(LSR) (bvlshr result amount)]\n    [(ASR) (bvashr result amount)]\n    [(ROR) (bvror result amount)]))\n```\n\n```racket\n(define (decode sf shift Rm imm6 Rn Rd)\n  (define d Rd)\n  (define n Rn)\n  (define m Rm)\n  (define datasize (if (bveq sf (bv #b1 1)) 64 32))\n\n  (when (&& (bveq sf (bv #b0 1)) (bveq (bit 5 imm6) (bv #b1 1)))\n    (undefined))\n\n  (define shift_type (decode-shift shift))\n  (define shift_amount (zero-extend imm6 (bitvector datasize)))\n\n  (values d n m datasize shift_type shift_amount))\n\n\n(define (interpret-bics-shifted-register cpu sf shift Rm imm6 Rn Rd)\n  (define-values (d n m datasize shift_type shift_amount) (decode sf shift Rm imm6 Rn Rd))\n  (define operand1 (trunc datasize (cpu-gpr-ref cpu n)))\n  (define operand2 (shift-reg cpu m shift_type shift_amount))\n\n  (set! operand2 (bvnot operand2))\n\n  (define result (bvand operand1 operand2))\n  (cpu-nzcv-set! cpu (nzcv (bit (sub1 datasize) result) (is-zero-bit result) (bv #b0 1) (bv #b0 1)))\n\n  (cpu-gpr-set! cpu d result))\n```\n\n```racket\n(define (undefined)\n  (core:bug #:msg \"UNDEFINED\"))\n```\n\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Walk me through the SBFM/BFM/UBFM bitfield-move Rosette semantics, including the bitmask helper, so I can reuse them in my synthesis proofs."},{"role":"assistant","content":"<think>\nBitfield move decodes `sf|opc|100110|N|immr|imms|Rn|Rd`, enforcing `sf`/`N` consistency and using `decode-bit-masks` to build the rotate-and-mask windows.\nSymbolic state uses zero-extended register slices plus NZCV is untouched; `interpret-sbfm` composes sign-extension via replicated bits while `interpret-bfm/ubfm` mix destination bits based on `tmask`.\nConstraints come from the guard checks on `sf`, `N`, and immr/imms bit5, so solver work reduces to bitvector rotations and masking in Rosette.\n</think>\n\n```racket\n(define (highest-set-bit x)\n  (define lst (reverse (range (core:bv-size x))))\n  ; if bit i is set, return i (otherwise #f)\n  (define (pred i) (if (bveq (bit i x) (bv #b1 1)) i #f))\n  ; find the highest bit set (#f if x is zero)\n  (define pos (ormap pred lst))\n  ; return -1 if no bit is set\n  (if pos pos -1))\n\n(define (ones n)\n  ; Use bv for now, but can switch to for/all if a symbolic n is needed.\n  ; Don't use integer->bitvector here.\n  (bv -1 n))\n\n(define (replicate x n)\n  (apply concat (build-list n (lambda (i) x))))\n\n(define (undefined)\n  (core:bug #:msg "UNDEFINED"))\n\n(define (zeros n)\n  ; Use bv for now, but can switch to for/all if a symbolic n is needed.\n  ; Don't use integer->bitvector here.\n  (bv 0 n))\n\n(define (decode-bit-masks M immN imms immr immediate)\n  ; Compute log2 of element size.\n  ; 2^len must be in range [2, M]\n  (define len (highest-set-bit (concat immN (bvnot imms))))\n\n  ; Since len is integer, split over all possible concrete values (up to 6).\n  (define lst (for/all ([len len #:exhaustive])\n    (assert (integer? len))\n    (when (< len 1)\n      (undefined))\n    (assert (>= M (arithmetic-shift 1 len)))\n\n    ; Determine S, R and S - R parameters.\n    (define levels (zero-extend (ones len) (bitvector 6)))\n\n    ; For logical immediates an all-ones value of S is reserved\n    ; since it would generate a useless all-ones result (many times).\n    (when (&& immediate (bveq (bvand imms levels) levels))\n      (undefined))\n\n    ; S = UInt(imms AND levels);\n    ; R = UInt(immr AND levels);\n    ; diff = S - R;\n    ;\n    ; To avoid integers, represent S and R using (bitvector len).\n    ; Use extract here instead of masking levels.\n    (define S (trunc len imms))\n    (define R (trunc len immr))\n    (define diff (bvsub S R))\n\n    ; esize = 2^len\n    (define esize (arithmetic-shift 1 len))\n    ; No need for truncation as diff is already of (bitvector len).\n    (define d diff)\n\n    ; welem = ZeroExtend(Ones(S + 1), esize);\n    ; telem = ZeroExtend(Ones(d + 1), esize);\n    ;\n    ; To avoid integers, start from all-one values and right-shift instead:\n    ; welem: ones(esize) >> (esize - 1 - S)\n    ; telem: ones(esize) >> (esize - 1 - d)\n    ;\n    ; Note that both S and d are of (bitvector len), they need to be zero-extended.\n    (define welem (bvlshr (ones esize) (bvsub (bv (sub1 esize) esize) (zero-extend S (bitvector esize)))))\n    (define telem (bvlshr (ones esize) (bvsub (bv (sub1 esize) esize) (zero-extend d (bitvector esize)))))\n\n    (define wmask (replicate (bvror welem (zero-extend R (bitvector esize))) (quotient M esize)))\n    (define tmask (replicate telem (quotient M esize)))\n    (list wmask tmask)))\n\n  ; As values is not lifted by Rosette, use list inside for/all and\n  ; values after merging.\n  (apply values lst))\n```\n\n```racket\n(define (decode sf N immr imms Rn Rd)\n  (define d Rd)\n  (define n Rn)\n  (define datasize (if (bveq sf (bv #b1 1)) 64 32))\n\n  (when (&& (bveq sf (bv #b1 1)) (! (bveq N (bv #b1 1))))\n    (undefined))\n\n  (when (&& (bveq sf (bv #b0 1))\n            (|| (! (bveq N (bv #b0 1)))\n                (! (bveq (bit 5 immr) (bv #b0 1)))\n                (! (bveq (bit 5 imms) (bv #b0 1)))))\n    (undefined))\n\n  (define R (zero-extend immr (bitvector datasize)))\n  (define S (zero-extend imms (bitvector datasize)))\n  (define-values (wmask tmask) (decode-bit-masks datasize N imms immr #f))\n  (values d n datasize R S wmask tmask))\n\n\n(define (interpret-sbfm cpu sf N immr imms Rn Rd)\n  (define-values (d n datasize R S wmask tmask) (decode sf N immr imms Rn Rd))\n  (define src (trunc datasize (cpu-gpr-ref cpu n)))\n\n  (define bot (bvand (bvror src R) wmask))\n  (define top (replicate (bv-bit S src) datasize))\n\n  (cpu-gpr-set! cpu d (bvor (bvand top (bvnot tmask))\n                            (bvand bot tmask))))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Capture the REV/REV16/REV32 Rosette semantics so I can reason about byte-swap behavior in my proofs."},{"role":"assistant","content":"<think>\nREV-family instructions decode with `sf|revop|11010110|00000|0000|opc|Rn|Rd`, where opc selects container size and `decode-rev*` asserts legal `sf`/`opc` combinations.\nSymbolic state only touches the source/dest GPRs; the interpreter concretely iterates over byte containers, reversing slices before re-concatenating into a bitvector.\nGuards funnel unsupported encodings to `unreachable`/`undefined`, so solver reasoning reduces to equality over concatenated byte vectors.\n</think>\n\n```racket\n(define (undefined)\n  (core:bug #:msg \"UNDEFINED\"))\n\n(define (unreachable)\n  (core:bug #:msg \"UNREACHABLE\"))\n```\n\n```racket\n(define (decode-rev* sf opc Rn Rd)\n  (define d Rd)\n  (define n Rn)\n\n  (define datasize (if (bveq sf (bv #b1 1)) 64 32))\n\n  (define container_size\n    (cond\n      [(bveq opc (bv #b00 2))\n       (unreachable)]\n      [(bveq opc (bv #b01 2))\n       16]\n      [(bveq opc (bv #b10 2))\n       32]\n      [(bveq opc (bv #b11 2))\n       (when (bveq sf (bv #b0 1))\n         (undefined))\n       64]))\n\n  (values d n datasize container_size))\n\n\n(define (interpret-rev* cpu sf opc Rn Rd)\n  (define-values (d n datasize container_size) (decode-rev* sf opc Rn Rd))\n  (define operand (trunc datasize (cpu-gpr-ref cpu n)))\n  (define result (make-vector (quotient datasize 8) #f))\n\n  (define containers (quotient datasize container_size))\n  (define elements_per_container (quotient container_size 8))\n  (define index 0)\n\n  (for ([c (range containers)])\n    (define rev_index (+ index (* (sub1 elements_per_container) 8)))\n    (for ([e (range elements_per_container)])\n      (vector-set! result (quotient rev_index 8) (extract (+ index 7) index operand))\n      (set! index (+ index 8))\n      (set! rev_index (- rev_index 8))))\n\n  (cpu-gpr-set! cpu d (apply concat (reverse (vector->list result)))))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Provide the MADD/MSUB Rosette interpreter so I can reason about fused multiply-add proofs on ARM64."},{"role":"assistant","content":"<think>\nMADD/MSUB decode as `sf|00|11011|000|Rm|o0|Ra|Rn|Rd`, selecting 32- vs 64-bit lanes with `sf` before truncating operands.\nSymbolic state consists of the general-purpose regs; `interpret-madd/msub` fetches three operands, multiplies via `core:bvmul-proc`, and accumulates/adds or subtracts before writing back to Rd.\nConstraints are just the truncation and optional subtraction flag (`sub_op`), so solver checks reduce to polynomial bitvector identities.\n</think>\n\n```racket\n(define (interpret-madd/msub cpu sf Rm Ra Rn Rd sub_op)\n  (define d Rd)\n  (define n Rn)\n  (define m Rm)\n  (define a Ra)\n  (define destsize (if (bveq sf (bv #b1 1)) 64 32))\n\n  (define operand1 (trunc destsize (cpu-gpr-ref cpu n)))\n  (define operand2 (trunc destsize (cpu-gpr-ref cpu m)))\n  (define operand3 (trunc destsize (cpu-gpr-ref cpu a)))\n\n  (define result (sub_op operand3 ((core:bvmul-proc) operand1 operand2)))\n  (cpu-gpr-set! cpu d result))\n\n(define (interpret-madd cpu sf Rm Ra Rn Rd)\n  (interpret-madd/msub cpu sf Rm Ra Rn Rd bvadd))\n\n(define (interpret-msub cpu sf Rm Ra Rn Rd)\n  (interpret-madd/msub cpu sf Rm Ra Rn Rd bvsub))\n```\n"}]}
{"messages":[{"role":"system","content":"You are the Rosette Maintainer AI, an expert in Rosette ISA modeling and solver-aided verification."},{"role":"user","content":"Share the Rosette interpreter for UDIV/SDIV so I can validate divide-by-zero handling in my model."},{"role":"assistant","content":"<think>\nDivision instructions decode as `sf|01|11010110|Rm|00001|o1|Rn|Rd`, selecting unsigned vs signed via `o1` and 32/64-bit lanes via `sf`.\nSymbolic regs are truncated to the operand width, with a divide-by-zero check that returns all zeros; otherwise the interpreter calls `core:bvudiv-proc` or `core:bvsdiv-proc`.\nThese constraints keep the solver in defined territory (no exceptions modeled) while preserving exact bitvector semantics for proofs.\n</think>\n\n```racket\n(define (is-zero x)\n  (bvzero? x))\n\n(define (zeros n)\n  (bv 0 n))\n```\n\n```racket\n(define (interpret-udiv/sdiv cpu sf Rm Rn Rd proc)\n  (define d Rd)\n  (define n Rn)\n  (define m Rm)\n  (define datasize (if (bveq sf (bv #b1 1)) 64 32))\n\n  (define operand1 (trunc datasize (cpu-gpr-ref cpu n)))\n  (define operand2 (trunc datasize (cpu-gpr-ref cpu m)))\n\n  (define result\n    (if (is-zero operand2)\n        (zeros datasize)\n        (proc operand1 operand2)))\n\n  (cpu-gpr-set! cpu d result))\n\n(define (interpret-udiv cpu sf Rm Rn Rd)\n  (interpret-udiv/sdiv cpu sf Rm Rn Rd (core:bvudiv-proc)))\n\n(define (interpret-sdiv cpu sf Rm Rn Rd)\n  (interpret-udiv/sdiv cpu sf Rm Rn Rd (core:bvsdiv-proc)))\n```\n"}]}
