{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"We need the HTTP client module imports and a case-sensitive header map alias so the webhook request builder preserves header casing when sending events."},{"role":"assistant","content":"<think>\nWe rely on hyper/hyper_util for low-level request construction while keeping parity with reqwest-based tooling, and tokio drives the async client lifecycle. I also need the case-sensitive header map alias so we can retain custom header casing without extra allocations when feeding hyper requests.\n</think>\n\n```rust\nuse std::{\n    collections::HashMap,\n    future::Future,\n    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr},\n    pin::Pin,\n    str::FromStr,\n    sync::Arc,\n    task::{ready, Poll},\n    time::{Duration, Instant},\n};\n\nuse axum::{body::Body, response::Response};\nuse axum_extra::headers::{authorization::Credentials, Authorization};\nuse bytes::Bytes;\nuse futures::{future::BoxFuture, FutureExt};\nuse hickory_resolver::{lookup_ip::LookupIpIntoIter, ResolveError, Resolver, TokioResolver};\nuse http::{header::HeaderName, HeaderMap, HeaderValue, Method, StatusCode, Version};\nuse http_body_util::Full;\nuse hyper::{body::Incoming, ext::HeaderCaseMap, Uri};\nuse hyper_openssl::client::legacy::{HttpsConnector, MaybeHttpsStream};\nuse hyper_util::{\n    client::{\n        legacy::{\n            connect::{\n                dns::Name,\n                proxy::{SocksV5, Tunnel},\n                HttpConnector,\n            },\n            Client,\n        },\n        proxy::matcher::Matcher,\n    },\n    rt::{TokioExecutor, TokioIo},\n};\nuse ipnet::IpNet;\nuse openssl::ssl::{SslConnector, SslConnectorBuilder, SslMethod, SslVerifyMode};\nuse serde::Serialize;\nuse thiserror::Error;\nuse tokio::{net::TcpStream, sync::Mutex};\nuse tower::Service;\n\nuse crate::cfg::{ProxyAddr, ProxyBypassCfg, ProxyConfig};\n\npub type CaseSensitiveHeaderMap = HashMap<String, HeaderValue>;\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Please define the webhook HTTP client struct that wraps the hyper client along with the whitelisted networks we use for building webhook requests."},{"role":"assistant","content":"<think>\nWe stick with hyper/hyper_util instead of reqwest for this layer so we can fully control request headers and connectors, and tokio drives the executor backing the client. The struct should cache the hyper client plus the Arc of whitelisted networks so repeated webhook builds avoid reallocating filter state.\n</think>\n\n```rust\nuse std::{\n    collections::HashMap,\n    future::Future,\n    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr},\n    pin::Pin,\n    str::FromStr,\n    sync::Arc,\n    task::{ready, Poll},\n    time::{Duration, Instant},\n};\n\nuse bytes::Bytes;\nuse http_body_util::Full;\nuse hyper_util::{\n    client::{\n        legacy::{\n            connect::{\n                dns::Name,\n                proxy::{SocksV5, Tunnel},\n                HttpConnector,\n            },\n            Client,\n        },\n        proxy::matcher::Matcher,\n    },\n    rt::{TokioExecutor, TokioIo},\n};\nuse ipnet::IpNet;\n\n#[derive(Clone)]\npub struct WebhookClient {\n    client: Client<SvixHttpsConnector, Full<Bytes>>,\n    whitelist_nets: Arc<Vec<IpNet>>,\n}\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Build the webhook HTTP client constructor that wires hyper's connector, whitelist handling, and proxy config toggles."},{"role":"assistant","content":"<think>\nWe prefer hyper/hyper_util here over reqwest so we can configure DNS resolvers, proxy chaining, and header casing before building webhook requests, and tokio's executor drives the client lifecycle. The constructor should pre-build the whitelist Arcs, reuse the NonLocalDnsResolver, and configure hyper to keep title-case headers for downstream signature logic without extra allocations.\n</think>\n\n```rust\nuse std::{\n    collections::HashMap,\n    future::Future,\n    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr},\n    pin::Pin,\n    str::FromStr,\n    sync::Arc,\n    task::{ready, Poll},\n    time::{Duration, Instant},\n};\n\nuse hyper_util::{\n    client::{\n        legacy::{\n            connect::{\n                dns::Name,\n                proxy::{SocksV5, Tunnel},\n                HttpConnector,\n            },\n            Client,\n        },\n        proxy::matcher::Matcher,\n    },\n    rt::{TokioExecutor, TokioIo},\n};\nuse ipnet::IpNet;\n\nuse crate::cfg::{ProxyAddr, ProxyBypassCfg, ProxyConfig};\n\nimpl WebhookClient {\n    pub fn new(\n        whitelist_nets: Option<Arc<Vec<IpNet>>>,\n        whitelist_names: Option<Arc<Vec<String>>>,\n        dangerous_disable_tls_verification: bool,\n        proxy_config: Option<&ProxyConfig>,\n    ) -> Self {\n        let whitelist_nets = whitelist_nets.unwrap_or_else(|| Arc::new(Vec::new()));\n        let whitelist_names = whitelist_names.unwrap_or_else(|| Arc::new(Vec::new()));\n\n        let dns_resolver = NonLocalDnsResolver::new(whitelist_nets.clone(), whitelist_names);\n        let mut http = HttpConnector::new_with_resolver(dns_resolver);\n        http.enforce_http(false);\n\n        if dangerous_disable_tls_verification {\n            tracing::warn!(\"TLS certificate verification has been disabled by the configuration.\");\n        }\n        let https = SvixHttpsConnector::new(http, proxy_config, dangerous_disable_tls_verification)\n            .expect(\"SvixHttpsConnector build failed\");\n\n        let client = hyper_util::client::legacy::Client::builder(TokioExecutor::new())\n            .http1_ignore_invalid_headers_in_responses(true)\n            .http1_title_case_headers(true)\n            .build(https);\n\n        Self {\n            client,\n            whitelist_nets,\n        }\n    }\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Add an execute helper that turns our request builder output into an axum response while keeping the same header handling."},{"role":"assistant","content":"<think>\nWe keep hyper as the low-level client even though other code uses reqwest, so this helper just awaits the hyper future and adapts it into axum's Body on tokio. Keeping it simple avoids extra allocations while preserving the headers built earlier.\n</think>\n\n```rust\nuse axum::{body::Body, response::Response};\n\n    pub async fn execute(&self, request: Request) -> Result<Response, Error> {\n        let resp = self.execute_inner(request, true).await?;\n        Ok(resp.map(Body::new))\n    }\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Implement the inner execution routine that validates destination IPs, builds the hyper request with our headers, and handles timeout/retry semantics for webhook delivery."},{"role":"assistant","content":"<think>\nHyper lets us build the exact request (including case-preserving headers) before handing it to the client, something reqwest hides, and tokio's runtime gives us the timeout future we need. I'll enforce the whitelist before building the request, copy the header map directly, add the case map extension, and only retry immediately when the first attempt fails quickly to avoid extra allocations.\n</think>\n\n```rust\nuse std::{\n    collections::HashMap,\n    future::Future,\n    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr},\n    pin::Pin,\n    str::FromStr,\n    sync::Arc,\n    task::{ready, Poll},\n    time::{Duration, Instant},\n};\n\nuse futures::{future::BoxFuture, FutureExt};\nuse http_body_util::Full;\nuse hyper::{body::Incoming, ext::HeaderCaseMap, Uri};\n\n    pub fn execute_inner(\n        &self,\n        request: Request,\n        retry: bool,\n    ) -> BoxFuture<'_, Result<Response<Incoming>, Error>> {\n        async move {\n            let org_req = request.clone();\n            if let Some(auth) = request.uri.authority() {\n                if let Ok(ip) = auth.host().parse::<IpAddr>() {\n                    if !is_allowed(ip)\n                        && !self\n                            .whitelist_nets\n                            .iter()\n                            .any(|subnet| subnet.contains(&ip))\n                    {\n                        return Err(Error::BlockedIp);\n                    }\n                }\n            }\n\n            let mut req = if let Some(body) = request.body {\n                hyper::Request::builder()\n                    .method(request.method)\n                    .uri(request.uri)\n                    .version(request.version)\n                    .body(Full::from(body))\n                    .map_err(Error::InvalidHttpRequest)?\n            } else {\n                hyper::Request::builder()\n                    .method(request.method)\n                    .uri(request.uri)\n                    .version(request.version)\n                    .body(Full::default())\n                    .map_err(Error::InvalidHttpRequest)?\n            };\n\n            *req.headers_mut() = request.headers;\n\n            if let Some(header_names) = request.header_names {\n                req.extensions_mut().insert(header_names);\n            }\n\n            let start = Instant::now();\n            let res = if let Some(timeout) = request.timeout {\n                match tokio::time::timeout(timeout, self.client.request(req)).await {\n                    Ok(Ok(resp)) => Ok(resp),\n                    Ok(Err(e)) => Err(e.into()),\n                    Err(_to) => Err(Error::TimedOut),\n                }\n            } else {\n                self.client.request(req).await.map_err(Into::into)\n            };\n\n            if !retry {\n                return res;\n            }\n\n            match res {\n                Err(Error::FailedRequest(e)) if start.elapsed() < Duration::from_millis(1000) => {\n                    tracing::info!(\"Insta-retrying: {e}\");\n                    self.execute_inner(org_req, false).await\n                }\n                res => res,\n            }\n        }\n        .boxed()\n    }\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Lay out the internal webhook Request struct so we carry method, URI, headers, the header case map, optional body, timeout, and HTTP version for request building."},{"role":"assistant","content":"<think>\nWe rely on hyper/hyper_util for low-level request control while keeping parity with reqwest-based tooling, and tokio drives these async requests. Capturing the header map, case map, and timeout here lets us build hyper requests without extra allocations later.\n</think>\n\n```rust\nuse std::{\n    collections::HashMap,\n    future::Future,\n    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr},\n    pin::Pin,\n    str::FromStr,\n    sync::Arc,\n    task::{ready, Poll},\n    time::{Duration, Instant},\n};\n\nuse http::{header::HeaderName, HeaderMap, HeaderValue, Method, StatusCode, Version};\nuse hyper::{body::Incoming, ext::HeaderCaseMap, Uri};\n\n#[derive(Clone)]\npub struct Request {\n    method: Method,\n    uri: Uri,\n    headers: HeaderMap,\n    header_names: Option<HeaderCaseMap>,\n    body: Option<Vec<u8>>,\n    timeout: Option<Duration>,\n    version: Version,\n}\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Model the RequestBuilder struct so it tracks all of the optional headers, body, timeout, and HTTP metadata we need before building webhook requests."},{"role":"assistant","content":"<think>\nWe stage request data in this builder before handing it to hyper so we can precisely control headers compared to reqwest's higher-level API, and tokio will later drive the send. Keeping these Option fields avoids unnecessary allocations until we finalize the request.\n</think>\n\n```rust\nuse std::{\n    collections::HashMap,\n    future::Future,\n    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr},\n    pin::Pin,\n    str::FromStr,\n    sync::Arc,\n    task::{ready, Poll},\n    time::{Duration, Instant},\n};\n\nuse http::{header::HeaderName, HeaderMap, HeaderValue, Method, StatusCode, Version};\nuse hyper::{body::Incoming, ext::HeaderCaseMap, Uri};\n\npub struct RequestBuilder {\n    method: Option<Method>,\n    uri: Option<Uri>,\n    accept: Option<HeaderValue>,\n    user_agent: Option<HeaderValue>,\n    headers: Option<HeaderMap>,\n    header_names: Option<HeaderCaseMap>,\n    body: Option<Vec<u8>>,\n    version: Option<Version>,\n    timeout: Option<Duration>,\n    basic_auth: Option<Vec<u8>>,\n\n    // Derived from body\n    content_type: Option<HeaderValue>,\n}\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Expose a RequestBuildError that aggregates builder validation issues so we fail fast before sending webhook requests."},{"role":"assistant","content":"<think>\nCatching builder issues before handing anything to hyper keeps us from wasting tokio tasks, and it mirrors the failure surface reqwest users expect. I'll format the error to include every missing field so we can fix header or URI issues without multiple allocations.\n</think>\n\n```rust\n#[derive(Debug)]\npub struct RequestBuildError(pub Vec<BuildError>);\n\nimpl std::fmt::Display for RequestBuildError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        let mut iter = self.0.iter();\n\n        f.write_str(\"Build failed\")?;\n\n        if let Some(first) = iter.next() {\n            write!(f, \": {first}\")?;\n\n            for err in iter {\n                write!(f, \"; {err}\")?;\n            }\n        }\n\n        Ok(())\n    }\n}\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Define the BuildError variants so we can signal when webhook requests are missing a URI or HTTP version."},{"role":"assistant","content":"<think>\nHyper requires both the URI and version before we can serialize headers, and we want the same clarity engineers get from reqwest's builder, all still on tokio. I'll use thiserror so the variants give precise strings without extra boilerplate.\n</think>\n\n```rust\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum BuildError {\n    #[error(\"uri missing\")]\n    UriMissing,\n    #[error(\"version missing\")]\n    VersionMissing,\n}\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"We need a helper that safely decodes percent-encoded credentials before building webhook headers."},{"role":"assistant","content":"<think>\nBasic auth headers must be constructed deterministically for hyper, and reqwest-based tooling expects the same behavior, so I'll decode user info while logging failures. This keeps tokio tasks from panicking over bad percent-encoding and still returns the raw string.\n</think>\n\n```rust\nfn decode_or_log(s: &str) -> String {\n    urlencoding::decode(s)\n        .map(|x| x.into_owned())\n        .unwrap_or_else(|_| {\n            tracing::error!(\"URL decoding failed\");\n            s.to_owned()\n        })\n}\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Add the RequestBuilder initializer along with a method setter so we can start staging webhook requests."},{"role":"assistant","content":"<think>\nWe keep a builder so we can assemble hyper requests with full header control instead of relying on reqwest defaults, and tokio tasks can reuse the builder cheaply. Initializing everything to None avoids allocations until we actually set fields, and the method setter just records the HTTP verb.\n</think>\n\n```rust\nuse http::{header::HeaderName, HeaderMap, HeaderValue, Method, StatusCode, Version};\n\nimpl RequestBuilder {\n    pub fn new() -> Self {\n        Self {\n            method: None,\n            uri: None,\n            accept: None,\n            user_agent: None,\n            headers: None,\n            header_names: None,\n            body: None,\n            version: None,\n            timeout: None,\n            content_type: None,\n            basic_auth: None,\n        }\n    }\n\n    pub fn method(mut self, method: Method) -> Self {\n        self.method = Some(method);\n        self\n    }\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Extend the request builder with URI setters that parse embedded credentials and allow passing a &str URL."},{"role":"assistant","content":"<think>\nWe parse URLs ourselves instead of relying on reqwest so we can capture basic-auth info for hyper header construction, and tokio tasks shouldn't block on it. I'll decode the username/password, stash the Authorization bytes, and convert into hyper's Uri while preserving validation errors.\n</think>\n\n```rust\nuse std::{\n    collections::HashMap,\n    future::Future,\n    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr},\n    pin::Pin,\n    str::FromStr,\n    sync::Arc,\n    task::{ready, Poll},\n    time::{Duration, Instant},\n};\n\nuse axum_extra::headers::{authorization::Credentials, Authorization};\nuse hyper::{body::Incoming, ext::HeaderCaseMap, Uri};\n\n    pub fn uri(mut self, uri: url::Url) -> Self {\n        let basic_auth = if uri.password().is_some() || !uri.username().is_empty() {\n            let username = decode_or_log(uri.username());\n            let password = uri.password().map(decode_or_log).unwrap_or_default();\n\n            Some(\n                Authorization::basic(&username, &password)\n                    .0\n                    .encode()\n                    .as_bytes()\n                    .to_vec(),\n            )\n        } else {\n            None\n        };\n        self.basic_auth = basic_auth;\n\n        let uri =\n            Uri::from_str(uri.as_str()).expect(\"If it's a valid url::Url, it's also a valid Uri\");\n        self.uri = Some(uri);\n        self\n    }\n\n    pub fn uri_str(self, uri: &str) -> Result<Self, url::ParseError> {\n        let uri = url::Url::from_str(uri)?;\n        Ok(self.uri(uri))\n    }\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Implement the header ingestion logic so we keep case-sensitive header names when building webhook requests."},{"role":"assistant","content":"<think>\nHyper lets us stuff headers directly, but unlike reqwest we also need to stash the original casing for signature verification, and tokio tasks shouldn't pay for extra copies. I'll preallocate the hyper maps, copy the bytes once, and store the case map alongside the regular header map.\n</think>\n\n```rust\nuse bytes::Bytes;\nuse http::{header::HeaderName, HeaderMap, HeaderValue, Method, StatusCode, Version};\n\n    fn build_headers(\n        headers: CaseSensitiveHeaderMap,\n    ) -> (hyper::HeaderMap, hyper::ext::HeaderCaseMap) {\n        let mut hdr_map = hyper::HeaderMap::with_capacity(headers.len());\n        let mut case_sensitive_hdrs: hyper::HeaderMap<Bytes> =\n            hyper::HeaderMap::with_capacity(headers.len());\n        for (k, v) in headers.into_iter() {\n            match HeaderName::from_str(&k) {\n                Ok(key) => {\n                    hdr_map.insert(key.clone(), v);\n                    case_sensitive_hdrs.insert(key, Bytes::copy_from_slice(k.as_bytes()));\n                }\n                Err(e) => {\n                    tracing::error!(\"Failed to parse header {} {}\", k, e);\n                }\n            }\n        }\n        (hdr_map, case_sensitive_hdrs.into())\n    }\n\n    pub fn headers(mut self, headers: CaseSensitiveHeaderMap) -> Self {\n        let (hdrs, case_map) = Self::build_headers(headers);\n        self.headers = Some(hdrs);\n        self.header_names = Some(case_map);\n        self\n    }\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Add helpers on the request builder to set the raw body and a JSON body while ensuring Content-Type is tracked."},{"role":"assistant","content":"<think>\nWe serialize payloads ourselves so hyper can stream them without reqwest's buffering, and we run this inside tokio tasks. Setting both the bytes and the content type lets later header construction reuse the value without extra allocations.\n</think>\n\n```rust\nuse http::{header::HeaderName, HeaderMap, HeaderValue, Method, StatusCode, Version};\nuse serde::Serialize;\n\n    pub fn body(mut self, body: Vec<u8>, content_type: HeaderValue) -> Self {\n        self.body = Some(body);\n        self.content_type = Some(content_type);\n        self\n    }\n\n    pub fn json_body<T: Serialize>(self, body: T) -> Result<Self, serde_json::Error> {\n        let body = serde_json::to_vec(&body)?;\n        Ok(self.body(body, HeaderValue::from_static(\"application/json\")))\n    }\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Expose setters for HTTP version, timeout, and user agent on the webhook request builder."},{"role":"assistant","content":"<think>\nHyper needs the version up front and tokio's timeout handling depends on us storing the duration, while reqwest users still expect to tweak the User-Agent. I'll just stash these fields so the final build step can emit the right headers without rebuilding strings.\n</think>\n\n```rust\nuse std::{\n    collections::HashMap,\n    future::Future,\n    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr},\n    pin::Pin,\n    str::FromStr,\n    sync::Arc,\n    task::{ready, Poll},\n    time::{Duration, Instant},\n};\n\nuse http::{header::HeaderName, HeaderMap, HeaderValue, Method, StatusCode, Version};\n\n    pub fn version(mut self, version: Version) -> Self {\n        self.version = Some(version);\n        self\n    }\n\n    pub fn timeout(mut self, timeout: Duration) -> Self {\n        self.timeout = Some(timeout);\n        self\n    }\n\n    pub fn user_agent(mut self, user_agent: HeaderValue) -> Self {\n        self.user_agent = Some(user_agent);\n        self\n    }\n```\n"}]} 
{"type":"chatml","messages":[{"role":"system","content":"You are the Svix Maintainer AI, an expert in the internal svix-server Rust architecture, specializing in HTTP request building and header management for webhook delivery."},{"role":"user","content":"Finish the request builder so it validates required fields and emits a Request with Host, Accept, Content-Type, optional User-Agent, and Authorization headers set correctly."},{"role":"assistant","content":"<think>\nBefore handing data to hyper we need to ensure URI and version exist, something reqwest enforces differently, and doing it here keeps tokio tasks from failing downstream. I'll preallocate the header map so Host stays first, set sensible defaults, add the case map, and only materialize Authorization if the caller didn't supply one.\n</think>\n\n```rust\nuse http::{header::HeaderName, HeaderMap, HeaderValue, Method, StatusCode, Version};\n\nimpl RequestBuilder {\n    fn validate(&self) -> Result<(), RequestBuildError> {\n        let mut errs: Vec<BuildError> = Vec::new();\n        if self.uri.is_none() {\n            errs.push(BuildError::UriMissing);\n        }\n        if self.version.is_none() {\n            errs.push(BuildError::VersionMissing);\n        }\n\n        if !errs.is_empty() {\n            Err(RequestBuildError(errs))\n        } else {\n            Ok(())\n        }\n    }\n\n    pub fn build(self) -> Result<Request, RequestBuildError> {\n        self.validate()?;\n\n        let custom_headers = self.headers.unwrap_or_default();\n\n        let uri = self.uri.unwrap();\n        let authority = uri.authority().expect(\"Missing authority\");\n        let host = match authority.port() {\n            Some(port) => HeaderValue::from_str(&format!(\"{}:{port}\", authority.host())),\n            None => HeaderValue::from_str(authority.host()),\n        }\n        .unwrap();\n\n        let mut headers = HeaderMap::with_capacity(3 + custom_headers.len());\n\n        // Ensure that host header is first -- even though this is technically\n        // not required by HTTP spec, some clients fail if it's not first:\n        headers.insert(http::header::HOST, host);\n        headers.insert(\n            http::header::ACCEPT,\n            self.accept.unwrap_or(HeaderValue::from_static(\"*/*\")),\n        );\n        headers.insert(\n            http::header::CONTENT_TYPE,\n            self.content_type\n                .unwrap_or(HeaderValue::from_static(\"application/json\")),\n        );\n\n        headers.extend(custom_headers);\n\n        if let Some(user_agent) = self.user_agent {\n            headers.insert(http::header::USER_AGENT, user_agent);\n        }\n\n        if let Some(auth_header) = self.basic_auth {\n            if !headers.contains_key(http::header::AUTHORIZATION) {\n                headers.insert(\n                    http::header::AUTHORIZATION,\n                    HeaderValue::from_bytes(&auth_header).unwrap(),\n                );\n            }\n        }\n\n        Ok(Request {\n            method: self.method.unwrap_or(Method::POST),\n            uri,\n            headers,\n            header_names: self.header_names,\n            body: self.body,\n            timeout: self.timeout,\n            version: self.version.unwrap(),\n        })\n    }\n}\n```\n"}]} 
